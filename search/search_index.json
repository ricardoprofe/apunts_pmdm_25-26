{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Multimedia and mobile device programming - 2DAM","text":""},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/","title":"Unit 01. Introduction to Mobile Development","text":""},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#1-mobile-devices","title":"1. Mobile Devices","text":"<p>We live in a hyper-connected society where we are permanently online thanks to mobile devices. These devices have evolved from being simple communication tools to becoming authentic personal assistants that help us in our daily lives.</p> <p>The evolution of mobile devices has been spectacular, from the first mobile phones that only allowed voice calls and SMS to the current smartphones, which are authentic pocket computers with which we can surf the internet, play multimedia content, play video games, take high-quality photos and videos, geolocate ourselves, etc.</p> <p>This evolution has been possible thanks to the development of hardware (processors, memory, screens, batteries, sensors, etc.) and software (operating systems and applications).</p> <p>IBM Simon</p> <p>The first true smartphone was the IBM Simon, manufactured in 1992 and distributed in the United States between 1994 and 1995.</p> <p></p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#11-types-of-mobile-devices","title":"1.1 Types of Mobile Devices","text":"<p>There are different types of mobile devices, the most common being:</p> <ul> <li> <p>Mobile Phones / Smartphones: They are the most common and popular. They have a touch screen and an operating system (Android, iOS) that allows the installation of applications (apps) that expand their functionalities.</p> </li> <li> <p>Tablets: They are devices with a screen size larger than that of a smartphone but smaller than that of a laptop. They are ideal for consuming multimedia content (videos, books, magazines, internet browsing) and are widely used in the educational field.</p> </li> <li> <p>Wearables: They are devices that can be worn on the body. The most common are smartwatches and smartbands (or activity bands). They are usually companions to the smartphone and are used to monitor physical activity, receive notifications, control music playback, etc.</p> </li> <li> <p>Cars (Smart/Connected Cars): Modern vehicles are now mobile computing platforms with internet access, operating systems, and app support, enabling connectivity with phones, other cars, and infrastructure.</p> </li> <li> <p>ChromeOS Devices (Chromebooks): These are lightweight, portable laptops and tablets that primarily rely on web and cloud-based applications, with added support for Android and Linux software.</p> </li> <li> <p>TVs (Smart TVs): Traditional televisions enhanced with integrated operating systems and internet connectivity, allowing users to stream content, browse the web, and interact with other smart devices.</p> </li> <li> <p>XR (Extended Reality): An umbrella term for immersive technologies, including:</p> <ul> <li>VR (Virtual Reality): Fully digital, immersive experiences using headsets.</li> <li>AR (Augmented Reality): Digital overlays on the real world, viewed via smartphones or glasses.</li> <li>MR (Mixed Reality): Advanced AR where digital and physical objects interact in real time.</li> </ul> </li> <li> <p>E-book readers: Devices designed specifically for reading digital books. They use electronic ink technology (e-ink), which mimics the appearance of paper and is much less tiring for the eyes than a conventional screen. Their autonomy is very high.</p> </li> </ul> <p></p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#12-characteristics-of-mobile-devices","title":"1.2 Characteristics of Mobile Devices","text":"<p>The main characteristics that define a mobile device are:</p> <ul> <li>Mobility: Its small size and weight, together with its wireless connectivity, allow it to be used anywhere.</li> <li>Wireless Connectivity: They can connect to the internet and other devices without cables, mainly through Wi-Fi and mobile data networks (3G, 4G, 5G). They also usually have other types of wireless connectivity such as Bluetooth, NFC, or GPS.</li> <li>Touch Screen: They are the main input and output element. Interaction is done through gestures (tap, double-tap, drag, pinch, etc.).</li> <li>Sensors: They incorporate numerous sensors that allow them to interact with the environment:<ul> <li>Accelerometer: Measures acceleration and tilt.</li> <li>Gyroscope: Measures orientation and rotation.</li> <li>Magnetometer: Digital compass that detects magnetic north.</li> <li>GPS: Determines the geographic location.</li> <li>Light Sensor: Adjusts screen brightness automatically.</li> <li>Proximity Sensor: Detects if the device is close to an object (e.g., turns off the screen during a call).</li> <li>Fingerprint Sensor / Face Recognition: For device unlocking and authentication.</li> </ul> </li> <li>Autonomy: They have a battery that allows them to operate for a certain time without being connected to the electrical grid. Autonomy is a key factor.</li> <li>Applications (Apps): Their functionality is extended by installing applications downloaded from official stores (Google Play, App Store) or other sources.</li> </ul>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#13-hardware-of-a-mobile-device","title":"1.3 Hardware of a Mobile Device","text":""},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#the-processor-and-the-soc","title":"The Processor and the SoC","text":"<p>A mobile device contains essentially the same hardware as a computer, but with a different architecture, as they are constrained by the device's smaller size. Therefore, when we talk about the processor in a mobile device, we must talk about the SoC or System on a Chip, an integrated circuit that combines different parts of the system, such as the CPU itself, the GPU (graphics processor), RAM, ROM, and USB or Wi-Fi controllers.</p> <p>It is worth highlighting the importance of the British company ARM Holdings in the world of mobile processors. It is the creator of the architecture of the same name, ARM (Advanced RISC Machines), a 32- and 64-bit RISC (Reduced Instruction Set Computer) architecture that is present in the majority of mobile devices.</p> <p></p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#ram-memory","title":"RAM Memory","text":"<p>The type of RAM memory found inside the SoC is dynamic (DRAM), which requires periodic refreshing and is very fast. To reduce energy consumption and minimize heating, this RAM is placed close to the CPU and GPU. This RAM is shared by both units.</p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#screens-on-mobile-devices","title":"Screens on Mobile Devices","text":"<p>One of the defining characteristics of smartphones is the screen, through which most of the interaction with the device takes place.</p> <p>There are primarily two types of technologies, with different variations and generations:</p> <ul> <li> <p>LCD or Inorganic: Liquid Crystal Display, which lets light pass through based on its polarity, just like computer monitors. For this, they have a backlight panel located behind the display, which can be made of fluorescent lights or LEDs. Within this type, we find TFT, LED, IPS, PLS, or Apple's Retina displays.</p> </li> <li> <p>OLED or Organic: These use organic materials that emit light by themselves when electricity is applied, meaning they do not need a backlight panel and can turn individual pixels on or off independently. These are thinner screens than LCDs, as they have fewer layers, with lower consumption, higher contrast, and greater brightness. Furthermore, this manufacturing technology allows panels to be flexible, leading to mobile phones with foldable or rollable screens. Within this family, we find AMOLED, Super AMOLED, or Dynamic AMOLED screens.</p> </li> </ul> <p></p> <p>Apart from the screen manufacturing technology, it is important to know some other characteristics about them.</p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#resolution-and-density","title":"Resolution and Density","text":"<p>The screen resolution refers to the number of pixels displayed on it and is determined by the number of pixels in the horizontal and vertical directions.</p> <p>From the resolution, we can determine the aspect ratio and the density of pixels per inch (ppi). This density is a measure that relates the size of the screen to its resolution. Two screens of different sizes with the same resolution will have different densities, and therefore, different image quality. Ideally, this density should be greater than 300 or 400 ppi.</p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#aspect-ratio","title":"Aspect Ratio","text":"<p>This is the relationship between the width and height of the screen. Traditionally, this ratio has followed the widescreen 16:9 format (for every 16 pixels in width, there are 9 in height). For example, the 1920x1080 format fulfills this proportion.</p> <p>However, a few years ago, the 18:9 (and even 19:9) ratio began to become popular, aimed at larger panels with almost no bezels. This ratio allows a device to be less wide than another with the same diagonal in a 16:9 format, thereby improving its ergonomics.</p> <p></p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#cameras","title":"Cameras","text":"<p>One of the components that is most often demanded in a mobile device is the photographic camera or cameras. These are mainly composed of:</p> <ul> <li>An optical block, which is relatively limited, although some devices allow for the connection of an external lens, and</li> <li>A sensor, composed of an array of photoreceptors, which translate light signals into electrical ones, thus obtaining the value for each point in the image.</li> </ul> <p>Over time, mobile devices have incorporated more cameras, besides the front and rear ones, so that currently we can find three, four, or even five cameras (telephoto, wide-angle, monochromatic, or even infrared).</p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#sensors","title":"Sensors","text":"<p>Mobile devices can incorporate a wide variety of sensors, with which we can obtain very diverse information from our environment. Among the sensors we can find in a mobile device, the following stand out:</p> <ul> <li> <p>GPS (Global Positioning System): Provides location services by using a continuous signal to GPS satellites, allowing it to show where on the planet we are. This device opens up a whole range of possibilities such as LBS or Location-Based Services.</p> </li> <li> <p>Accelerometer and Gyroscope: The gyroscope measures the device's movements thanks to angular acceleration, even allowing the detection of small rotations, making it very suitable for, for example, augmented reality applications. On the other hand, the accelerometer is less precise and allows detection of the device's position relative to the three axes: x, y, and z. With this, we can determine, for example, if the device is in a horizontal or vertical position, as well as detect turns, vibrations, tilt, or collisions.</p> </li> <li> <p>Light Sensor: Allows the detection of ambient light, so the device can adjust the screen brightness to adapt to different lighting conditions.</p> </li> <li> <p>Proximity Sensor: Allows the detection of the distance from the device to other objects through an infrared LED, and enables, for example, the screen to turn off when we bring it close to our face during a call.</p> </li> </ul> <p>In addition to these, we can find many others, such as biometric sensors (fingerprint or iris readers), magnetometer, barometer, capacitive sensors, infrared sensor, heart rate sensor, color spectrum sensor, or pedometer.</p> <p></p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#14-operating-systems-os","title":"1.4 Operating Systems (OS)","text":"<p>The OS is the most important software that manages the device's hardware and allows applications to run. The most common are:</p> <ul> <li> <p>Android: Developed by Google. It is the most used OS in the world. It is an open-source system, which allows manufacturers to adapt it to their devices.</p> </li> <li> <p>iOS: Developed by Apple. It is exclusively used on the company's devices (iPhone, iPad). It is a closed-source system, known for its security, performance, and integration with the Apple ecosystem.</p> </li> <li>Others: HarmonyOS (Huawei), etc.</li> </ul> <p></p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#15-applications-apps","title":"1.5 Applications (Apps)","text":"<p>Applications are programs designed to perform specific tasks on mobile devices. There are applications for almost everything: social networks, messaging, email, photography, music, video, maps, banking, news, games, etc.</p> <p>They are mainly downloaded from official stores:</p> <ul> <li> <p>Google Play Store (for Android).</p> </li> <li> <p>App Store (for iOS).</p> </li> </ul> <p>Mobile devices have countless uses, among which we can highlight:</p> <ul> <li>Communication: Calls, video calls, instant messaging (WhatsApp, Telegram), email, social networks (Instagram, TikTok, X - Twitter).</li> <li>Information: Internet browsing, reading news, consulting Wikipedia.</li> <li>Entertainment: Listening to music (Spotify), watching videos (YouTube, Netflix), playing games.</li> <li>Photography and Video: Taking photos, recording videos, editing them, and sharing them.</li> <li>Navigation and Maps: Geolocation, GPS navigation (Google Maps), searching for nearby places.</li> <li>E-commerce: Online shopping, banking applications, payment with the mobile phone (NFC).</li> <li>Productivity: Calendar, notes, document editing, task management.</li> <li>Health and Sports: Monitoring physical activity, counting steps, measuring heart rate.</li> </ul>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#16-technologies-for-mobile-application-development","title":"1.6 Technologies for Mobile Application Development","text":"<p>Developing an application that runs natively on a specific operating system requires using its native technologies. However, to minimize the need for platform-specific development, several technologies exist that aim to enable cross-platform development in the broadest sense. These range from responsive web applications to compiled applications, including hybrid or progressive web applications (PWAs), each with its own advantages and disadvantages.</p> <p>Let's look at each of them, categorized by their distance from or closeness to native code.</p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#webapps-or-responsive-web-applications","title":"WebApps or Responsive Web Applications","text":"<p>These are applications based on web technologies: HTML, CSS, and JavaScript. They require only a web browser to run. Being \"responsive\" means their interface adapts to any device. For this type of application, no native code development is necessary, and they are entirely cross-platform because they run on the operating system's own web browser. Therefore, we have a single codebase that runs on all platforms. The main disadvantage is that they do not offer as good a user experience as native apps and do not allow access to all of the system's components.</p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#hybrid-applications","title":"Hybrid Applications","text":"<p>These use the trio of HTML, CSS, and JavaScript to build a website that is loaded within a WebView component\u2014essentially a browser without the navigation bar or other options\u2014giving it the appearance of a native application. This type of application can access some device features, like location or the accelerometer, through this component. Currently, the most popular framework for developing hybrid applications is Ionic, which allows development using other web frameworks like React, Angular, or Vue. </p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#progressive-web-applications-pwas","title":"Progressive Web Applications (PWAs)","text":"<p>Closer to native applications are Progressive Web Applications (PWAs), which are revolutionizing the current landscape. These applications incrementally enhance their functionalities based on the mobile device they run on, to leverage more potential. They can access hardware, work offline or with poor connectivity, and offer system notifications. There are numerous frameworks for PWA development, including React PWA Library, Angular PWA Framework, Vue PWA Framework, Ionic PWA Framework, Svelte, PWA Builder, and Polymer.</p> <p></p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#compiled-applications","title":"Compiled Applications","text":"<p>These are technologies that aim to use a single programming language to generate mobile applications into the native code of each platform. Some of the most widely used technologies in this category are:</p> <ul> <li> <p>React Native and NativeScript: They use JavaScript as their base programming language. However, instead of building interfaces with HTML, they use the framework's own components, which are compiled to native code, making the use of a WebView as an intermediary unnecessary.</p> </li> <li> <p>Flutter: Developed and maintained by Google, Flutter allows for cross-platform application development using the Dart language, which compiles to native code that runs entirely on the device. Flutter's way of working involves designing user interfaces using widgets, integrated directly into the code. Flutter comes with a set of predefined widgets, such as buttons, navigation bars, etc.</p> </li> <li> <p>Kotlin Multiplatform and Compose Multiplatform: With Kotlin Multiplatform, we can share code between various platforms (Android, iOS, web, etc.) using Kotlin as the programming language. This means we can write an application's logic once and reuse it on different platforms, reducing development time and effort. With Compose Multiplatform, a technology based on Jetpack Compose, we can create shared user interfaces for Android, iOS, desktop, and web using Kotlin. This facilitates the creation of consistent and reusable user interfaces across various platforms.</p> </li> </ul> <p>The Most Popular Development SDKs</p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#programming-for-ios","title":"Programming for iOS","text":"<p>To program for iOS (iPhone, iPad, Apple Watch, etc.), you\u2019ll need a mix of hardware, software, and knowledge. Here\u2019s a clear breakdown:</p> <p>Hardware</p> <ul> <li>Mac computer (MacBook, iMac, Mac Mini, etc.)   iOS development officially requires macOS.</li> <li>iOS device (optional but recommended)   You can test apps in the simulator, but real device testing is important.</li> </ul> <p>Software</p> <ol> <li> <p>Xcode (free, from the Mac App Store)</p> </li> <li> <p>Apple\u2019s official IDE (Integrated Development Environment).</p> </li> <li> <p>Includes editor, compiler, debugger, Interface Builder (UI designer), and the iOS Simulator.</p> </li> <li> <p>iOS SDK (comes with Xcode)</p> </li> <li> <p>Provides APIs, frameworks (UIKit, SwiftUI, Core Data, ARKit, etc.), and tools needed for building iOS apps.</p> </li> <li> <p>Apple Developer Account (optional at first, required for publishing)</p> </li> <li> <p>Free: lets you learn, run apps on simulator.</p> </li> <li>Paid (\\$99/year): required to publish to the App Store and to install apps on your physical iPhone.</li> </ol> <p>Programming Languages</p> <ul> <li>Swift Apple\u2019s modern language, recommended for all new projects.</li> <li>Objective-C older language, still used in legacy apps and some libraries.</li> </ul>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#17-trends-and-future","title":"1.7 Trends and Future","text":"<p>The future of mobile devices points towards:</p> <ul> <li>5G Connectivity: Much higher speed and lower latency, enabling new applications.</li> <li>Folding screens and new formats.</li> <li>Augmented Reality (AR) and Virtual Reality (VR): More integrated into mobile devices.</li> <li>Artificial Intelligence (AI): Integrated into the device to improve photography, battery management, and personalize the user experience.</li> <li>More and better sensors.</li> <li>Greater integration with other devices (Internet of Things - IoT): Controlling the home, the car, etc., from the smartphone.</li> </ul>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#2-introduction-to-android-development","title":"2. Introduction to Android development","text":"<p>As we saw previously, there are different technologies for mobile application development.</p> <p>In the next units, we will focus on native applications for the Android operating system, maintained by Google and based on the Linux kernel.</p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#21-origins-of-android","title":"2.1 Origins of Android","text":"<p>The origins of Android lie with the Palo Alto (California) company Android Inc., founded in 2003 by Andy Rubin. This company began by developing an operating system for digital cameras, but due to the sector's low profitability, they decided to pivot to mobile devices, a market then dominated by Symbian and Windows Mobile. In 2005, Google acquired Android Inc., and two years later, alongside the creation of the Open Handset Alliance\u2014a consortium of various technology companies aimed at developing open standards for mobile devices\u2014the first version of Android, Apple Pie, was announced. This version began to be incorporated into devices in 2008, and two years later, it captured nearly half of the market share.</p> <p></p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#22-the-android-operating-system","title":"2.2 The Android Operating System","text":"<p>Android is the most widely used operating system for mobile devices today. As we know, it is an operating system for touch-screen devices based on the Linux kernel and other open software standards.</p> <p>Android is developed as open source software, meaning both its source code and its issue tracker are accessible. The Android Open Source Project (https://source.android.com/) contains the Android source code, released under the Apache license.</p> <p>In June 2025, the latest version of Android, Android 16, was launched. Since its first version, it has continuously incorporated updates and new functionalities into the system. Furthermore, the ease it provides for application development has resulted in a large community of developers, whose work has produced over three million apps on the Google Play Store, the official Android application repository.</p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#23-characteristics","title":"2.3 Characteristics","text":"<p>Some of the most relevant characteristics of Android are:</p> <ul> <li>Adaptable to a wide variety of screen sizes and resolutions, with support for 2D and 3D graphics libraries based on OpenGL.</li> <li>Natively supports multi-touch screens.</li> <li>Offers local storage through a lightweight database, SQLite.</li> <li>Supports a wide range of connectivity technologies.</li> <li>Includes a web browser based on the WebKit rendering engine and the V8 JavaScript engine from Google Chrome.</li> <li>Native applications are programmed with Java or Kotlin and are compiled for the ART (Android Runtime) virtual machine.</li> <li>Incorporates support for a wide variety of multimedia formats and streaming.</li> <li>Supports a vast array of hardware devices and sensors.</li> <li>Features a very extensive catalog of applications through the Google Play service.</li> </ul>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#24-android-versions","title":"2.4 Android Versions","text":"<p>Android has undergone a significant transformation since its first versions. As a summary, we will look at some characteristics of the most relevant updates.</p> <p>The system began its journey in 2008 with versions 1.0 and 1.1, which included apps like Gmail, Maps, Calendar, and YouTube. It was in version 1.5, Cupcake, that a version name was introduced, and a large number of interface improvements were included, such as the on-screen keyboard, which allowed devices to eliminate physical keyboards. Subsequently, with version 1.6, Donut, the system began to adapt to different screen sizes and resolutions.</p> <p>Versions 2.0 and 2.2 (Eclair and Froyo) introduced aspects like voice-guided navigation, real-time traffic information, and the bottom dock. Version 3.0, Honeycomb, was launched specifically for larger devices, like tablets, and in version 4.0, Ice Cream Sandwich, in 2011, this new interface, Holo, was unified for tablets and smartphones, thus entering the era of modern design.</p> <p>But the biggest change was yet to come with versions 5.0 and 5.1, Lollipop, in 2014. Google reinvented Android in what is perhaps the most important update to the system, introducing the Material Design standard\u2014a set of design specifications affecting the operating system, the web, and apps. With Material, flat color designs were introduced to give weight and depth to different interface elements using shadows, layers, or animations.</p> <p>Subsequent versions included some interface improvements, such as split-screen mode in Android 7.0/7.1 (Nougat) and the picture-in-picture floating window in Android 8/8.1 (Oreo). With Android 10, the dessert-based version code names were abandoned, and some aspects of the interface were reinvented regarding gestures and the navigation system.</p> <p>In Android 11, in 2020, substantial changes to privacy arrived, allowing users to grant apps temporary permissions to access location, camera, or microphone only when required, instead of permanently during installation.</p> <p>And in 2021, Android 12 arrived, representing the biggest update since Android 5.0, with the introduction of Material You, which allows for system design personalization to automatically adjust to the user's settings. This means, for example, that the theme's color palette adapts to the user's chosen wallpaper. Additionally, under the hood, it offers a simpler and more granular way to control how apps access our data through the new privacy dashboard.</p> <p>In August 2022, Android 13 (Tiramisu) appeared, evolving Material You and presenting improvements in security, audio, and integration with other Google products. Android 14 (Upside Down Cake), in October 2023, incorporated improvements in customization, privacy, and accessibility.</p> <p>In September 2024, the launch of Android 15 is expected, bringed improvements to the user interface, security, and performance.</p> <p>The last release is Android 16, in June 2025. Android 16's major updates include a new \"Material 3 Expressive\" UI with advanced animations and blur effects, a desktop mode for tablets, and an expanded Linux terminal to run full desktop applications. It also enhances privacy with features like Notification Cooldown and introduces improved media sharing via Bluetooth LE Audio.</p> <p></p> <p>Android versions</p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#25-android-architecture","title":"2.5 Android Architecture","text":"<p>The Android architecture is composed of a stack of layers, based on the Linux kernel, and is adapted to a wide variety of devices. The different components of the system are shown in the following figure:</p> <p></p> <p>Original at: https://developer.android.com/guide/platform</p> <p>We can see the following components:</p> <ul> <li> <p>System Applications: These form the base system and include the email client, calendar, SMS application, Maps, camera app, browser, contacts app, dialer, among others.</p> </li> <li> <p>Application Framework (Java API Framework): Offers applications access to all Android functions, as well as the ability to publish and securely offer their functionalities to others. All this is designed to simplify the reuse of system components and modular services. Among these services we can find:</p> <ul> <li>An enriched view system for building the user interface,</li> <li>A resource manager, to access application resources such as translations, images, or layout files,</li> <li>A notification manager, to display alerts in the status bar,</li> <li>An activity manager, to manage the application lifecycle and handle navigation,</li> <li>Content providers, so that applications can access data provided by other applications.</li> </ul> </li> <li> <p>C/C++ Libraries: These are libraries used by some system components, offered to developers through the Application Framework. Some of these libraries include the standard C library, 3D graphics libraries, multimedia libraries, or the SQLite database.</p> </li> <li> <p>Android Runtime: Includes the ART virtual machine itself and the core Java libraries. Apps run their own processes as instances of the ART virtual machine, following the process virtualization paradigm (similar to the JVM for PC). The executables for this virtual machine are in DEX format, a bytecode specifically designed for Android and optimized to occupy minimal memory space.</p> </li> <li> <p>Hardware Abstraction Layer (HAL): Consists of a series of library modules for the different hardware components of the device, such as the camera or sensors, and offers an interface to the upper layers to facilitate access to them.</p> </li> <li> <p>Linux Kernel: This is the foundation of the Android platform, providing it with basic system functionalities such as process management, memory management, networking, drivers, and security.</p> </li> </ul>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#26-apps-for-android","title":"2.6 Apps for Android","text":"<p>Android applications are natively programmed in Kotlin or Java and are compiled by the Android SDK, along with data and resource files (interfaces, images, etc.), to generate an <code>.apk</code> file. This file contains the application itself and the information Android needs for its installation.</p> <p>Android implements the principle of least privilege in applications, which provides a certain level of security. This principle is based on:</p> <ul> <li>Android is a multi-user operating system, as it is based on Linux. The peculiarity is that for Android, each application is a different user.</li> <li>Each app has a user ID known only to the system, which establishes the necessary permissions for it to access its resources.</li> <li>Each process has its own virtual machine, so its code runs independently. In principle, each app will have its own process.</li> </ul> <p>With this, each application only has access to the components it needs. However, an application can share data with other applications and access system services, either by having two applications share the same user ID or by requesting user permission to access device data and resources (camera, microphone, Bluetooth connection, SD card, contacts, etc.).</p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#27-api-levels-compatibility-libraries-and-jetpack","title":"2.7 API Levels, Compatibility Libraries, and Jetpack","text":"<p>We have seen how different versions of Android introduce substantial changes in terms of operation and features. For developers, more than the version, we are interested in the API levels. These levels determine the compatibility of applications with Android versions. With each new version of the system, one or more API levels are introduced, which determine which device functionalities will be available to us.</p> <p>Info</p> <p>Android 16 is API level 36.</p> <p>When we start developing an Android application, we must consider which API functionalities we will need and establish the minimum level that our application will require. For example, if we develop an application that we want to follow Material Design standards, we must use a minimum API level 21, which was introduced in Android 5.0. Or if we desire functionalities present in Android 11 or 12, we must use API levels 30 and 31, respectively.</p> <p>To provide new functionalities or use equivalent functionalities in earlier versions of Android, Google launched a compatibility layer through Support Libraries. Currently, these libraries are integrated into Android Jetpack, a set of libraries that allows developers to focus on application logic and follow recommended practices, reducing boilerplate code and producing consistent code across different system versions.</p> <p>Jetpack Compose</p> <p>Traditionally, the design of native user interfaces has used XML files, which must be injected and manipulated from the source code.</p> <p>With Jetpack Compose, a more modern toolkit for interface development is introduced, following a declarative model. This means we describe the state of the interface, and Compose takes care of the rest, simplifying the code and making it more maintainable and reusable.</p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#3-android-studio","title":"3. Android Studio","text":"<p>Android Studio is the official IDE for Android development, based on JetBrains' IntelliJ IDE. Until 2014, Eclipse with the Android Development Tools (ADT) plugin was used.</p> <p>The main characteristics of Android Studio are:</p> <ul> <li>It is a cross-platform IDE (Windows, Linux, macOS)</li> <li>It is distributed under the Apache 2.0 license (free),</li> <li>It uses Gradle for building packages,</li> <li>It includes a series of templates for common application layouts,</li> <li>It allows Android-specific code refactoring,</li> <li>It offers support for development on different devices: smartphones, tablets, televisions, or wearables,</li> <li>It incorporates the Device Manager component, which allows creating and managing virtual Android devices to run, debug applications, or analyze performance, as well as linking physical devices to our development environment,</li> <li>It includes support for Google Cloud Platform, enabling integration with various Google services.</li> </ul>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#31-device-manager","title":"3.1 Device Manager","text":"<p>The built-in Device Manager in Android Studio allows us to create and manage virtual Android devices, as well as link physical devices to our development environment.</p> <p>We must keep in mind that the architecture and system for which we develop our applications are different from those of our development machine, not to mention that we can also create applications for a wide range of devices.</p> <p>For testing and debugging applications, we can either directly connect a device to the machine and enable developer mode, or use virtualized devices. The advantage of virtualization is that we can test our applications with a wide range of devices and different configurations. The disadvantage is that we will have to create a virtual machine for each device we want to test, with the associated consumption of storage space and memory.</p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#32-android-studio-installation","title":"3.2 Android Studio installation","text":"<p>The best way of install Android Studio i to download the installer and follow the installation instructions. Once installed, Android Studio automatically checks for updates.</p> <p>But before start the installation, read carefully the system requirements.</p> <p>Download Android Studio</p> <p>Installation guide (with system requirements)</p> <p>Download and install Android Studio (Codelab)</p> <p>Task</p> <p>Install Android Studio</p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#33-genymotion-emulator-installation","title":"3.3 Genymotion emulator installation","text":"<p>Genymotion is a third-party Android emulator and virtual device management platform. It is a powerful alternative to the emulator that comes bundled with Android Studio (which is now based on the Android Emulator Hypervisor Driver for faster performance).</p> <p>While Android Studio's Device Manager is the official tool for creating and running Android Virtual Devices (AVDs), Genymotion is often favored by developers for its significantly faster performance, advanced features, and ease of use for specific testing scenarios.</p> <p>Additionally, Genymotion offers a cloud service that allows you to run emulators on remote servers. This is ideal for continuous integration/continuous deployment (CI/CD) pipelines, automated testing on a large scale, or accessing a powerful emulator from a less powerful local machine.</p> <p>As a drawback, if you use the free license of Genymotion, you won't have access to the latest Android version and to the pro widgets.</p> <p>Genymotion download</p> <p>Requirements and installation guides</p> <p>Task</p> <p>Install Genymotion Desktop and create and launch an Android Virtual Device with the latest API allowed.</p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#34-yout-first-android-app","title":"3.4 Yout first Android app","text":"<p>Once you have Android Studio installed, it's time to create your first Android app. The purpose of this section is to practice the basic use of IDE and emulators.</p> <p>Task</p> <ol> <li>Follow the guide at Create your first Android app codcelab</li> <li>Run the app on the Android Emulator. You can follow this codelab</li> <li>Close the Android emulator and start the Genymotion virtual device. Run your app on the Genymotion device.</li> <li>Connect your Android device and run the app on it. You can follow this codelab</li> </ol>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#35-structure-of-an-android-project","title":"3.5 Structure of an Android project","text":"<p>Android Studio uses Gradle as the project build tool. Android projects are organized into modules, where each module will be a different application. This allows us to have multiple versions of our application for different types of devices (tablets, wearables, etc.) under the same project.</p> <p>Below, we see the structure generated in an Android project, from both the Project Files view in the side tool window and the Android view.</p> <p></p> <p>In the project files view, we can see the typical file structure of a Gradle project, with general application files in the root folder, as well as the specific folder for the application module (<code>app</code>). However, the Android view presents a more compact and simplified view of this information, organized into several main logical folders: <code>app</code> (which contains <code>manifests</code>, <code>kotlin+java</code>, and <code>res</code>), plus the <code>Gradle Scripts</code> folder.</p> <p>Let's see some of the most important elements of this organization:</p> <ul> <li>The Gradle build scripts, in Kotlin DSL format (<code>build.gradle.kts</code>). This includes both the general script located in the root (with information common to all modules) and the one specific to the application module (<code>app/build.gradle.kts</code>). In the Android view, both scripts are shown under <code>Gradle Scripts</code>, indicating whether it's the script for the project or the module.</li> <li>Inside the module folder (<code>app</code>) we find the <code>src</code> folder, which contains the application's source code (<code>app/src/main</code>). In the Android view, this is located in the <code>kotlin+java</code> folder and is displayed in package name format instead of showing the directory structure.</li> <li>The <code>app/src/main/res</code> folder, which will contain the application's resources (images, layouts, text strings, etc.). If we look at the detail, this folder contains many subfolders for the different types of resources. In the Android view, this content is displayed in a more compact and organized way, according to the resource type.</li> <li>The application descriptor file: <code>app/AndroidManifest.xml</code>, with information associated with it. As we will see, this is one of the most important files in our project, as it defines aspects such as the application name, package, icon, and its different components.</li> </ul>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#gradle-scripts","title":"Gradle Scripts","text":""},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#general-build-script","title":"General Build Script","text":"<p>As mentioned, an Android project defines a general configuration script <code>build.gradle.kts</code> for the project, located in the root folder, and another located in the <code>app</code> folder, which refers to the application module itself.</p> <p>The content of the general build script will have the following structure:</p> <pre><code>plugins {\nalias(libs.plugins.android.application) apply false\nalias(libs.plugins.kotlin.android) apply false\nalias(libs.plugins.kotlin.compose) apply false\n}\n</code></pre> <p>It contains aliases to the plugins it uses, defined in the version catalog file <code>libs.versions.toml</code>.</p> <p>In previous versions, plugins were specified in this same file, but now this catalog is used to manage the versions of plugins and dependencies, to facilitate maintenance and version updates, since all are defined in the same place.</p> <p>This file, located in the <code>gradle</code> folder, contains, among other things:</p> <pre><code>[versions]\nagp = \"8.13.0\"\nkotlin = \"2.0.21\"\n...\n\n[libraries]\n...\n\n[plugins]\nandroid-application = { id = \"com.android.application\", version.ref = \"agp\" }\nkotlin-android = { id = \"org.jetbrains.kotlin.android\", version.ref = \"kotlin\" }\nkotlin-compose = { id = \"org.jetbrains.kotlin.plugin.compose\", version.ref = \"kotlin\" }\n</code></pre> <p>This means it uses the plugins <code>com.android.application</code> (it's an Android application), <code>kotlin-android</code> (it's a Kotlin application) and <code>kotlin-compose</code>, with versions <code>8.13.0</code> for the first and <code>2.0.21</code> for the second.</p> <p>The utility of these plugins is to correctly configure the project build process, ensuring that the Kotlin code is compiled properly and packaged correctly for Android.</p> <p>Although by default plugins are loaded immediately, we can use the <code>apply false</code> syntax to load them later in the configuration files of each module.</p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#module-scripts","title":"Module Scripts","text":"<p>The build file most important is the <code>build.gradle.kts</code> of the application module itself. The main blocks that compose it are the following:</p> <pre><code>plugins {\nalias(libs.plugins.android.application)\nalias(libs.plugins.kotlin.android)\nalias(libs.plugins.kotlin.compose)\n}\n</code></pre> <p>This is where the plugins that the module will depend on are specified; specifically those defined in the general build file.</p> <pre><code>android {\nnamespace = \"com.example.helloandroid\"\ncompileSdk = 36\n\ndefaultConfig {\napplicationId = \"com.example.helloandroid\"\nminSdk = 24\ntargetSdk = 36\nversionCode = 1\nversionName = \"1.0\"\n\ntestInstrumentationRunner = \"androidx.test.runner.AndroidJUnitRunner\"\n}\n\nbuildTypes {\nrelease {\nisMinifyEnabled = false\nproguardFiles(\ngetDefaultProguardFile(\"proguard-android-optimize.txt\"),\n\"proguard-rules.pro\"\n)\n}\n}\ncompileOptions {\nsourceCompatibility = JavaVersion.VERSION_11\ntargetCompatibility = JavaVersion.VERSION_11\n}\nkotlinOptions {\njvmTarget = \"11\"\n}\nbuildFeatures {\ncompose = true\n}\n}\n</code></pre> <p>This <code>android</code> block is where some of the most important aspects of the application are configured. It contains the namespace of our application (<code>namespace</code>) and the SDK version it was developed with (<code>compileSdk</code>).</p> <p>Furthermore, it includes several sub-blocks, such as:</p> <ul> <li><code>defaultConfig</code>: Specifies the default configuration, with parameters such as the application ID (<code>applicationId</code>), the minimum SDK version the application will work with (<code>minSdk</code>), or the version it was developed for (<code>targetSdk</code>), among others.</li> <li><code>buildTypes</code>: Where parameters for the different builds can be specified. When creating a module, two builds are created by default: <code>release</code> and <code>debug</code>. Here we specify options like code optimization with Proguard, etc.</li> <li><code>compileOptions</code>, where the Java version to be used to compile the project (<code>sourceCompatibility</code>) and the Java version the compilation will target (<code>targetCompatibility</code>) are specified. In this case, the value <code>JavaVersion.VERSION_1_8</code> refers to Java version 8.</li> <li><code>kotlinOptions</code> specifies some options for Kotlin; in this case <code>jvmTarget</code>, which indicates the Java version that will be used for the Kotlin code.</li> </ul> <p>And finally, we have the following project dependencies block:</p> <pre><code>dependencies {\nimplementation(libs.androidx.core.ktx)\nimplementation(libs.androidx.lifecycle.runtime.ktx)\nimplementation(libs.androidx.activity.compose)\nimplementation(platform(libs.androidx.compose.bom))\nimplementation(libs.androidx.compose.ui)\nimplementation(libs.androidx.compose.ui.graphics)\nimplementation(libs.androidx.compose.ui.tooling.preview)\nimplementation(libs.androidx.compose.material3)\ntestImplementation(libs.junit)\nandroidTestImplementation(libs.androidx.junit)\nandroidTestImplementation(libs.androidx.espresso.core)\nandroidTestImplementation(platform(libs.androidx.compose.bom))\nandroidTestImplementation(libs.androidx.compose.ui.test.junit4)\ndebugImplementation(libs.androidx.compose.ui.tooling)\ndebugImplementation(libs.androidx.compose.ui.test.manifest)\n}\n</code></pre> <p>Among these dependencies, we highlight the Jetpack libraries (<code>libs.androidx.core.ktx</code>), as well as the Compose libraries (<code>libs.androidx.compose...</code>), among others. Note that we are also using aliases here, and the name and versions of the libraries are specified in the <code>gradle/libs.versions.toml</code> file.</p> <p>At this point, we we can see how, unlike other types of Gradle applications, the main class (<code>mainClass</code>) is not specified, and the <code>application</code> section doesn't even exist. As we will see next, the entry point will be specified in the Manifest file.</p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#the-androidmanifestxml-file-and-application-components","title":"The AndroidManifest.xml File and Application Components","text":"<p>The Manifest file is a file specific to each application that contains information about it. This information is used by the Android build tools, the system itself, and Google Play.</p> <p>Among the information we can find in it, we can highlight:</p> <ul> <li>The different components of the application and their properties: Activities (<code>&lt;activity&gt;</code>), Services (<code>&lt;service&gt;</code>), Broadcast Receivers (<code>&lt;receiver&gt;</code>), and Content Providers (<code>&lt;provider&gt;</code>). We will discuss these components later.</li> <li>The application's permissions to access protected system resources or other applications, as well as the permissions that other applications must possess to access this application's content.</li> <li>The different hardware and software features that our application will need, so that Google Play prevents its installation on devices that do not have these features.</li> </ul> <p>As an example, let's look at the <code>AndroidManifest.xml</code> of a typical \"Hello World\" application, like the one we created. The general structure of the file is as follows:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\nxmlns:tools=\"http://schemas.android.com/tools\"&gt;\n\n&lt;application&gt; ...\n    &lt;/application&gt;\n&lt;/manifest&gt;\n</code></pre> <p>As we can see, the root element <code>manifest</code> defines two namespaces:</p> <ul> <li><code>xmlns:android</code>, with which we can define Android-specific attributes (<code>android:</code>) in the document, which serve to define the application's behavior and its interaction with the system. Furthermore, it allows us to define information related to components (activities, services, etc.).</li> <li><code>xmlns:tools</code> allows us to use certain debugging and helper tools from the IDE, but it has no effect on the application's operation.</li> </ul> <p>In older versions of Android Studio, with Gradle prior to 7.3, the package name was also specified in the <code>manifest</code> tag, instead of in the project's Gradle build file. Therefore, in old projects, you might find it in this file.</p> <p>Let's now move on to the <code>application</code> element, which contains all the information about the application:</p> <pre><code>&lt;application\nandroid:allowBackup=\"true\"\nandroid:dataExtractionRules=\"@xml/data_extraction_rules\"\nandroid:fullBackupContent=\"@xml/backup_rules\"\nandroid:icon=\"@mipmap/ic_launcher\"\nandroid:label=\"@string/app_name\"\nandroid:roundIcon=\"@mipmap/ic_launcher_round\"\nandroid:supportsRtl=\"true\"\nandroid:theme=\"@style/Theme.HelloAndroid\"&gt;\n&lt;activity&gt; ... &lt;/activity&gt;\n&lt;/application&gt;\n</code></pre> <p>As we can see, several Android-specific attributes are defined here, such as the icon, label, or theme that defines the application's appearance. Many of these elements are referenced preceded by the <code>@</code> symbol, which indicates that they refer to application resources.</p> <p>Inside <code>application</code>, as mentioned, the different components of the application are defined. In this case, there is a single activity:</p> <pre><code>&lt;activity\nandroid:name=\".MainActivity\"\nandroid:exported=\"true\"\nandroid:label=\"@string/app_name\"\nandroid:theme=\"@style/Theme.HelloAndroid\"&gt;\n&lt;intent-filter&gt;\n&lt;action android:name=\"android.intent.action.MAIN\" /&gt;\n&lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;\n&lt;/intent-filter&gt;\n&lt;/activity&gt;\n</code></pre> <p>With this, we indicate that the application contains an activity named <code>.MainActivity</code> (actually <code>com.example.helloandroid.MainActivity</code>), and that this activity can receive messages from outside the application (<code>android:exported=\"true\"</code>), or in other words, that this activity will be an entry point to our application.</p> <p>Furthermore, an <code>intent-filter</code> element is defined, which specifies the actions this activity will react to. In this case, the action <code>android.intent.action.MAIN</code> is defined with the category <code>android.intent.category.LAUNCHER</code>. With <code>MAIN</code> we indicate that this is the entry point to the application, and by specifying the <code>LAUNCHER</code> category, we indicate that this activity should appear in the application launcher.</p> <p>Within this same <code>application</code> element, we will define the rest of the application's components. Any components not included will not be visible to the system.</p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#application-resources","title":"Application Resources","text":"<p>The application's resources folder (<code>res</code>) contains, organized in subfolders, the different types of resources used by the application. When programming any application, it is convenient to keep resources external to the application to facilitate their independent maintenance.</p> <p>Although there are several physical folders for the different types of resources, the Android view presents us with a logical organization of all of them. Among these logical folders we can find:</p> <ul> <li><code>drawable/</code>: Contains graphic design elements that can be drawn on the device screen: not only images but also layer lists, states, or levels, among many others.</li> <li><code>mipmap/</code>: Contains the different application icons, in different densities (dpi).</li> <li><code>layout/</code>: For apps that use XML layouts, contains the layouts of different parts of the user interface, in XML format.</li> <li><code>values/</code>: Contains files in XML format with simple values, such as character strings, integer values, or colors.</li> <li><code>xml/</code>: XML files that can be read at runtime, with some special configurations.</li> </ul>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/","title":"The Kotlin language","text":"<p>Kotlin is a cross-platform, statically typed, general-purpose high-level programming language with type inference. Kotlin is designed to interoperate fully with Java, and the JVM version of Kotlin's standard library depends on the Java Class Library. </p> <p>Kotlin mainly targets the JVM, but also compiles to JavaScript or native code.Language development costs are borne by JetBrains, while the Kotlin Foundation protects the Kotlin trademark.</p> <p>The Android Kotlin compiler emits Java 8 bytecode by default (which runs in any later JVM), but allows targeting Java 9 up to 20, for optimizing. </p> <p>On 7 May 2019, Google announced that the Kotlin programming language had become its preferred language for Android app developers. Since the release of Android Studio 3.0 in October 2017, Kotlin has been included as an alternative to the standard Java compiler.</p> <p>References:</p> <ul> <li>Kotlin docs</li> <li>Kotlin for Android</li> <li>Kotlin playground</li> </ul>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#hello-world","title":"Hello world","text":"<p>Open the Kotlin Playground and write and execute this code:</p> <pre><code>fun main() {\nprintln(\"Hello, world!\")\n}\n</code></pre> <p><code>fun main()</code> is the entry point of the program. All Kotlin programs are required to have a main function, which is the specific place in your code where the program starts running. </p> <p><code>println</code> is a function that takes an argument as a String and outputs its content to the console.</p> <p>Tip</p> <p>You can also run Kotlin code in Android Studio creating a new file on an exisiting project and running that file.</p>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#variables","title":"Variables","text":"<p>To create a variable, use <code>var</code> or <code>val</code>, and assign a value to it with the equal sign (<code>=</code>):</p> <pre><code>var name = \"Mary\"\nval birthyear = 1974\n</code></pre> <p>The difference between <code>var</code> and <code>val</code> is that variables declared with the <code>var</code> keyword can be modified, while <code>val</code> variables cannot. <code>val</code> variables are immutable.</p> <p>Kotlin uses type inference, but you can specify the type when create a variable:</p> <pre><code>var name: String = \"Mary\"\nval birthyear: Int = 1974\n</code></pre> <p>The general rule for naming Kotlin variables are:</p> <ul> <li>Names can contain letters, digits, underscores, and dollar signs.</li> <li>Names should start with a letter, <code>$</code> and <code>_</code> </li> <li>Names are case sensitive (\"myVar\" and \"myvar\" are different variables)</li> <li>Names should start with a lowercase letter and it cannot contain whitespace</li> <li>Reserved words (like Kotlin keywords, such as var or String) cannot be used as names</li> </ul>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#types","title":"Types","text":"<p>In Kotlin, everything is an object in the sense that you can call member functions and properties on any variable.</p> <p>For integer numbers, there are four types with different sizes and value ranges:</p> <p></p> <p>When you initialize a variable with no explicit type specification, the compiler automatically infers the type with the smallest range enough to represent the value starting from Int. If it doesn't exceed the range of Int, the type is Int. If it does exceed that range, the type is Long. To specify the Long value explicitly, append the suffix L to the value. To use the Byte or Short type, specify it explicitly in the declaration. </p> <pre><code>val one = 1 // Int\nval threeBillion = 3000000000 // Long\nval oneLong = 1L // Long\nval oneByte: Byte = 1\n</code></pre> <p>Info</p> <p>In addition to signed integer types, Kotlin also provides unsigned integer types</p> <p>For real numbers, Kotlin provides floating-point types Float and Double that adhere to the IEEE 754 standard. Float reflects the IEEE 754 single precision, while Double reflects double precision.</p> <p></p> <p>For variables initialized with fractional numbers, the compiler infers the Double type.</p> <p>The String data type is used to store a sequence of characters (text). String values must be surrounded by double quotes:</p> <pre><code>val myText: String = \"Hello World\"\n</code></pre> <p>String literals may contain template expressions (pieces of code that are evaluated and whose results are concatenated into a string). When a template expression is processed, Kotlin automatically calls the <code>.toString()</code> function on the expression's result to convert it into a string. A template expression starts with a dollar sign ($) and consists of a variable name:</p> <pre><code>var name: String = \"Mary\"\nval age: Int = 34\nprintln(\"Hello $name!\")\nprintln(\"Yout age is $age\")\n</code></pre> <p>Template expressions can also hold an expression in curly braces:</p> <pre><code>val num1 = 3\nval num2 = 4\nprintln(\"$num1 + $num2 is ${num1 + num2}\")\n</code></pre> <p>The Boolean data type can only take the values <code>true</code> or <code>false</code>:</p> <pre><code>val isTrue: Boolean = true\nval isFalse: Boolean = false\n</code></pre> <p>The Char data type is used to store a single character. A <code>char</code> value must be surrounded by single quotes:</p> <pre><code>val letter = 'A'\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#type-conversion","title":"Type Conversion","text":"<p>In Kotlin, numeric type conversion is different from Java. For example, it is not possible to convert an Int type to a Long type with the following code:</p> <pre><code>val x: Int = 5\nval y: Long = x\nprintln(y) // Error: Type mismatch \n</code></pre> <p>To convert a numeric data type to another type, you must use one of the following functions: <code>toByte()</code>, <code>toShort()</code>, <code>toInt()</code>, <code>toLong()</code>, <code>toFloat()</code>, <code>toDouble()</code>, <code>toString()</code> or <code>toChar()</code>:</p> <pre><code>val x: Int = 5\nval y: Long = x.toLong()\nprintln(y)\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#nullable-types-and-elvis-operator","title":"Nullable types and Elvis operator","text":"<p>Kotlin is a safe language, and among other things, it prevents us from programming errors such as NullPointerException since it does not allow variable values to be null by default.</p> <p>If we want to specify that a variable can contain a null value, it is necessary to explicitly define it as nullable. To do this, when we define it, we add a question mark <code>?</code> to its type:</p> <pre><code>var name: String? = null //Nullable type\nvar age: Int = 50   //Non-nullable type\nage = null //Error\n</code></pre> <p>In addition, Kotlin also provides us with the <code>?:</code> operator, known as the Elvis operator, to specify an alternative value when the variable is null.</p> <pre><code>var name : String? = null\nprintln(name.length) // Error\nprintln(name?.length ?: -1) //prints -1\nname = Mary\nprintln(name?.length ?: -1) //prints 4\n</code></pre> <p>In this example we've used the <code>?.</code> safe call operator. It prevents to cause an exception when the variable is null and Kotlin can't call the member function (length in this case).</p>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#constants","title":"Constants","text":"<p>We can declare constants in Kotlin using the <code>const</code> keyword. Constants must be initialized with a value at the time of declaration, and their value cannot be changed later. Constants can only be of primitive types and String.</p> <pre><code>const val PI = 3.14159\nconst val APP_NAME = \"MyKotlinApp\"\n</code></pre> <p>Tip</p> <p>Use snake_case for naming constants: all uppercase letters with words separated by underscores.</p> <p>The difference between <code>val</code> and <code>const val</code> is that <code>val</code> can be assigned a value at runtime, while <code>const val</code> must be assigned a value at compile time. Additionally, <code>const val</code> can only be used for top-level or object-level properties, while <code>val</code> can be used in any scope.</p>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#operators","title":"Operators","text":""},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#arithmetic-operators","title":"Arithmetic Operators","text":"Operator Name Description Example + Addition Adds together two values x + y - Subtraction Subtracts one value from another x - y * Multiplication Multiplies two values x * y / Division Divides one value from another x / y % Modulus Returns the division remainder x % y ++ Increment Increases the value by 1 ++x -- Decrement Decreases the value by 1 --x"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#assignment-operators","title":"Assignment Operators","text":"Operator Example Same As = x = 5 x = 5 += x += 3 x = x + 3 -= x -= 3 x = x - 3 *= x *= 3 x = x * 3 /= x /= 3 x = x / 3 %= x %= 3 x = x % 3"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#comparison-operators","title":"Comparison Operators","text":"<p>Comparison operators are used to compare two values, and returns a Boolean value: either <code>true</code> or <code>false</code>.</p> Operator Name Example == Equal to x == y != Not equal x != y &gt; Greater than x &gt; y &lt; Less than x &lt; y &gt;= Greater than or equal to x &gt;= y &lt;= Less than or equal to x &lt;= y <p>The <code>===</code> operator (and its negated counterpart <code>!==</code>) checks for referencial equality. <code>a === b</code> evaluates to true if and only if <code>a</code> and <code>b</code> point to the same object:</p> <pre><code>fun main() {\nvar a = \"Hello\"\nvar b = a\nvar c = \"world\"\nvar d = \"world\"\n\nprintln(a === b)\n// true\nprintln(a === c)\n// false\nprintln(c === d)\n// true\n}\n</code></pre> <p>For values represented by primitive types at runtime (for example, <code>Int</code>), the <code>===</code> equality check is equivalent to the <code>==</code> check.</p>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#logical-operators","title":"Logical Operators","text":"Operator Name Description Example &amp;&amp; Logical and Returns true if both statements are true <code>x &lt; 5 &amp;&amp;  x &lt; 10</code> || Logical or Returns true if one of the statements is true <code>x &lt; 5 || x &lt; 4</code> ! Logical not Reverse the result, returns false if the result is true <code>!(x &lt; 5)</code>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#comments","title":"Comments","text":"<p>Kotlin has single-line comments and multi-line comments:</p> <pre><code>// This is a single-line comment\n\n/* This is\n  a multi-line\n  comment */\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#control-structures","title":"Control structures","text":""},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#if-else","title":"if - else","text":"<p>The structure is similar to other languages:</p> <pre><code>if (condition1) {\n// block of code to be executed if condition1 is true\n} else if (condition2) {\n// block of code to be executed if the condition1 is false and condition2 is true\n} else {\n// block of code to be executed if the condition1 is false and condition2 is false\n}\n</code></pre> <p>In Kotlin, <code>if-else</code> can return a value for each case that can be assigned to a variable:</p> <pre><code>val message = if (age &lt; 18) {\n\"You are under-age.\"\n} else {\n\"You are adult.\"\n}\n</code></pre> <p>Warning</p> <p>When using <code>if</code> as an expression, you must also include <code>else</code> (required).</p> <p>That can be shortened to:</p> <pre><code>val msg = if (age &lt; 18) \"You are under-age.\" else \"You are adult.\"\n</code></pre> <p>This is equivalent to the ternary operator of other languages.</p>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#when","title":"when","text":"<p>The <code>when</code> statement is similar to <code>switch-case</code> of C/Java:</p> <pre><code>when (trafficLightColor) {\n\"Red\" -&gt; println(\"Stop\")\n\"Yellow\" -&gt; println(\"Slow\")\n\"Green\" -&gt; println(\"Go\")\nelse -&gt; println(\"Invalid traffic-light color\")\n}\n</code></pre> <p>In the same way that if, when can return the result and can be assigned to a variable:</p> <pre><code>val msg = when (trafficLightColor) {\n\"Red\" -&gt; \"Stop\"\n\"Yellow\" -&gt; \"Slow\"\n\"Green\" -&gt; \"Go\"\nelse -&gt; \"Invalid traffic-light color\"\n}\n\nprintln(msg)\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#while-and-do-while","title":"while and do-while","text":"<p><code>while</code> and <code>do-while</code> loops are similar to C/Java:</p> <pre><code>while (condition) {\n// code block to be executed\n}\n</code></pre> <pre><code>do {\n// code block to be executed\n}\nwhile (condition);\n</code></pre> <p>In the same way, we have <code>break</code> and <code>continue</code> statements.</p>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#for","title":"for","text":"<p>Unlike Java and other programming languages, there is no traditional <code>for</code> loop in Kotlin.</p> <p>In Kotlin, the <code>for</code> loop is used to loop through arrays, ranges, and other things that contains a countable number of values.</p> <p>To loop through array elements, use the <code>for</code> loop together with the <code>in</code> operator:</p> <pre><code>val numbers = arrayOf(10, 14, 2, 15, 20)\nfor (x in numbers) {\nprintln(x)\n}\n</code></pre> <p>With the <code>for</code> loop, we can also iterate ranges:</p> <pre><code>for (x in 0..10) {\nprintln(x)\n} </code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#functions","title":"Functions","text":""},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#definition-and-invocation","title":"Definition and invocation","text":"<p>To declare a function in Kotlin we do:</p> <pre><code>fun funcName(param1 : Type1, param2 : Type2...) : ReturnType {\n// function body\nreturn\n}\n</code></pre> <p>Some examples:</p> <pre><code>fun simplefunction() {\nprintln(\"Simple function\")\n}\n\nfun functionWithParams(name: String): Unit\n{\nprintln(\"Hello $name\")\n}\n\nfun sum(x: Int, y: Int): Int {\nreturn (x + y)\n}\n\n//Function call\nprintln(sum(4, 5)) //prints 9\n</code></pre> <p>We look at some features of function declarations:</p> <ul> <li>They are declared using the keyword fun</li> <li>Names start with lower case and are expressed in camelCase</li> <li>Function parameters are specified after the name, in parentheses, and in the form parameter : Type. These types must necessarily be specified</li> <li>The return type of the function may be specified after the parenthesis with the argument list, followed by <code>:</code>.</li> <li>When the function does not return any significant value, its default return type is <code>Unit</code> , which would be the equivalent of <code>void</code> in Java or C.</li> </ul> <p>Warning</p> <p>Unlike in some languages, such as Java, where a function can change the value passed into a parameter, parameters in Kotlin are immutable. You cannot reassign the value of a parameter from within the function body.</p>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#named-parameters","title":"Named parameters","text":"<p>You can use named parameters when call a function:</p> <pre><code>fun hello(name: String, age: Int)\n{\nprintln(\"Hello $name, you are $age years old\")\n}\n\nhello(age = 16, name = \"Sean\") // Hello Sean, you are 16 years old\n</code></pre> <p>In this case, you can write the arguments in any order.</p>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#default-arguments","title":"Default arguments","text":"<p>Function parameters can also specify default arguments.</p> <pre><code>fun hello(name: String = \"Nonamed\", age: Int)\n{\nprintln(\"Hello $name, you are $age years old\")\n}\n\nhello(age = 16, name = \"Sean\") // Hello Sean, you are 16 years old\nhello(age = 16) // Hello Nonamed, you are 16 years old\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#single-expression-functions","title":"Single-expression functions","text":"<p>When the function body consists of a single expression, the curly braces can be omitted and the body specified after an = symbol:</p> <pre><code>fun double(x: Int): Int = x * 2\n</code></pre> <p>Explicitly declaring the return type is optional when this can be inferred by the compiler:</p> <pre><code>fun double(x: Int) = x * 2\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#lambda-expressions","title":"Lambda expressions","text":"<p>Lambda expressions provide a concise syntax to define a function without the <code>fun</code> keyword. You can store a lambda expression directly in a variable without a function reference on another function.</p> <p>Before the assignment operator (<code>=</code>), you add the <code>val</code> or <code>var</code> keyword followed by the name of the variable, which is what you use when you call the function. After the assignment operator (<code>=</code>) is the lambda expression, which consists of a pair of curly braces that form the function body:</p> <pre><code>fun main() {\nhello() // prints \"Hello world!\"\n}\n\nval hello = {\nprintln(\"Hello world!\")\n}\n</code></pre> <p>You can assign the lambda function to a variable and use it as a function too:</p> <pre><code>fun main() {\nval myHello = hello\nmyHello() // prints \"Hello world!\"\n}\n\nval hello = {\nprintln(\"Hello world!\")\n}\n</code></pre> <p>The full syntactic form of lambda expressions is as follows:</p> <pre><code>val sum: (Int, Int) -&gt; Int = { x: Int, y: Int -&gt; x + y }\n</code></pre> <ul> <li> <p>A lambda expression is always surrounded by curly braces.</p> </li> <li> <p>Parameter declarations in the full syntactic form go inside curly braces and have optional type annotations.</p> </li> <li> <p>The body goes after the <code>-&gt;</code>.</p> </li> <li> <p>If the inferred return type of the lambda is not Unit, the last (or possibly single) expression inside the lambda body is treated as the return value.</p> </li> </ul> <p>If you leave all the optional annotations out, what's left looks like this:</p> <pre><code>val sum = { x: Int, y: Int -&gt; x + y }\n</code></pre> <p>Another example of a lambda expression without arguments and return type:</p> <pre><code>val hello: () -&gt; Unit = { println(\"Hello world!\") }\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#trailing-lambdas","title":"Trailing lambdas","text":"<p>If the last parameter of a function is a function, then a lambda expression passed as the corresponding argument can be placed outside the parentheses:</p> <pre><code>val numbers = listOf(1, 2, 3)\nval sum = numbers.fold(0) { acc, i -&gt; acc + i }\nprintln(sum) // prints 6\n</code></pre> <p>Such syntax is also known as trailing lambda.</p> <p>If the lambda is the only argument in that call, the parentheses can be omitted entirely:</p> <pre><code>run { println(\"...\") }\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#it-for-single-parameter-functions","title":"<code>it</code> for single parameter functions","text":"<p>If the lambda has a single argument, we can use the keyword <code>it</code>, which represents that argument passed to the lambda function.</p> <p>The expression:</p> <pre><code>array.forEach { item -&gt; println(item * 4) }\n</code></pre> <p>can be shortened to:</p> <pre><code>array.forEach { println(it * 4) }\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#classes-and-objects","title":"Classes and objects","text":"<p>Kotlin is an object-oriented programming language, and everything in Kotlin is associated with classes and objects, along with their properties and methods.</p>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#defining-a-class","title":"Defining a class","text":"<p>To define a class in Kotlin, use the <code>class</code> keyword followed by the class name and curly braces. Class names should start with an uppercase letter and use camelCase.</p> <pre><code>class Car {\nvar color: String = \"Red\"\nvar model: String = \"Toyota\"\nvar year: Int = 2020\n\nfun start() {\nprintln(\"Car started\")\n}\n\nfun stop() {\nprintln(\"Car stopped\")\n}\n}\n</code></pre> <p>To create an instance of a class (an object), use the class name followed by parentheses:</p> <pre><code>val myCar = Car()\nmyCar.color = \"Blue\"\nmyCar.start() // prints \"Car started\"\n</code></pre> <p>As you can see, we access the properties and methods of the class using the dot (<code>.</code>) notation.</p> <p>You can define class properties using <code>val</code> or <code>var</code>. Properties defined with <code>val</code> are read-only and cannot be modified after initialization, while properties defined with <code>var</code> can be modified.</p>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#getter-and-setter-functions-in-properties","title":"Getter and setter functions in properties","text":"<p>Kotlin provides built-in getter and setter functions for class properties. </p> <pre><code>class Person {\nvar name: String = \"\"\nget() = field\nset(value) { field = value\n} }\n</code></pre> <p>You can customize these functions if needed.</p> <pre><code>class Person {\nvar name: String = \"John\"\nget() = field.uppercase() // Custom getter\nset(value) {\nfield = value.trim() } // Custom setter\n}\n</code></pre> <p>To access the property, you can use the dot notation:</p> <pre><code>val person = Person()\nprintln(person.name) // prints \"JOHN\"\nperson.name = \"  Alice  \"\nprintln(person.name) // prints \"ALICE\"\n</code></pre> <p>Remember that the properties defined with <code>val</code> cannot have a setter function, as they are read-only. And therefore, you cannot modify their value after initialization:</p> <pre><code>class Person {\nval id: Int = 0\nget() = field\n// set(value) { field = value } // Error: Val cannot have a setter\n}\n\nval person = Person()\nperson.id = 5 // Error: Val cannot be reassigned\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#constructors","title":"Constructors","text":"<p>The primary purpose of the constructor is to initialize the properties of the class when an object is created.</p> <p>A default constructor is provided by Kotlin if you don't define any constructors in your class. However, you can define your own constructors.</p> <pre><code>class Person(val id: Int, var name: String) {\nfun displayInfo() {\nprintln(\"ID: $id, Name: $name\")\n}\n} val person = Person(1, \"John\")\nperson.displayInfo() // prints \"ID: 1, Name: John\"\n</code></pre> <p>You can also define a secondary constructor using the <code>constructor</code> keyword:</p> <pre><code>class Person(val id: Int) {\nvar name: String = \"\"\n\nconstructor(id: Int, name: String) : this(id) {\nthis.name = name\n}\n\nfun displayInfo() {\nprintln(\"ID: $id, Name: $name\")\n}\n}\n\nfun main() {\nval person1 = Person(1)\nval person2 = Person(2, \"Alice\")\nperson1.displayInfo() // prints \"ID: 1, Name: \"\nperson2.displayInfo() // prints \"ID: 2, Name: Alice\"\n}\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#inheritance","title":"Inheritance","text":"<p>Kotlin supports inheritance, allowing you to create a new class based on an existing class. The new class (subclass) inherits properties and methods from the existing class (superclass).</p> <p>To enable inheritance, the superclass must be marked with the <code>open</code> keyword:</p> <pre><code>open class Animal {\nopen fun sound() {\nprintln(\"Animal makes a sound\")\n}\n}\n\nclass Dog : Animal() {\noverride fun sound() {\nprintln(\"Dog barks\")\n}\n}\n</code></pre> <p>In this example, the <code>Animal</code> class is the superclass, and the <code>Dog</code> class is the subclass that inherits from <code>Animal</code>. The <code>sound</code> method in the <code>Dog</code> class overrides the method in the <code>Animal</code> class.</p> <p>Note how we must call the constructor of the superclass using parentheses <code>()</code>. If the superclass has a primary constructor with parameters, you must provide the required arguments when calling it.</p> <pre><code>open class Animal(val name: String) {\nopen fun sound() {\nprintln(\"$name makes a sound\")\n}\n}\n\nclass Dog(name: String) : Animal(name) {\noverride fun sound() {\nprintln(\"$name barks\")\n}\n}\n\nfun main() {\nval dog = Dog(\"Buddy\")\ndog.sound() // prints \"Buddy barks\"\n}\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#overriding-methods-and-properties","title":"Overriding methods and properties","text":"<p>To override a method in a subclass, you must use the <code>override</code> keyword. The method in the superclass must be marked with the <code>open</code> keyword to allow it to be overridden.</p> <pre><code>open class Animal {\nopen fun sound() {\nprintln(\"Animal makes a sound\")\n}\n} class Cat : Animal() {\noverride fun sound() {\nprintln(\"Cat meows\")\n}\n}\n\nfun main() {    val cat = Cat()\ncat.sound() // prints \"Cat meows\"\n}\n</code></pre> <p>Similar to methods, you can also override properties in a subclass. The property in the superclass must be marked with the <code>open</code> keyword to allow it to be overridden.</p> <pre><code>open class Person {\nopen var name: String = \"John\"\n} class Student : Person() {\noverride var name: String = \"Alice\"\n}\n\nfun main() {\nval student = Student()\nprintln(student.name) // prints \"Alice\"\n}\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#calling-superclass-methods","title":"Calling superclass methods","text":"<p>You can call a method from the superclass using the <code>super</code> keyword:</p> <pre><code>open class Animal {\nopen fun sound() {\nprintln(\"Animal makes a sound\")\n}\n}\n\nclass Dog : Animal() {\noverride fun sound() {\nsuper.sound() // Call the superclass method\nprintln(\"Dog barks\")\n}\n}\n\nfun main() {\nval dog = Dog()\ndog.sound() // prints \"Animal makes a sound\" followed by \"Dog barks\"\n}   </code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#has-a-relationships","title":"HAS-A relationships","text":"<p>In addition to inheritance (IS-A relationship), Kotlin also supports composition (HAS-A relationship). This means that a class can contain references to other classes as properties.</p> <pre><code>class Engine(val horsePower: Int) {\nfun start() {\nprintln(\"Engine with $horsePower HP started\")\n}\n}\n\nclass Car(val model: String, val engine: Engine) {\nfun start() {\nengine.start()\nprintln(\"$model car started\")\n}\n} fun main() {\nval engine = Engine(150)\nval car = Car(\"Toyota\", engine)\ncar.start() // prints \"Engine with 150 HP started\" followed by \"Toyota car started\"\n}\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#visibility-modifiers","title":"Visibility modifiers","text":"<p>Kotlin provides several visibility modifiers to control the accessibility of classes, objects, interfaces, constructors, functions, properties, and their setters.</p> <ol> <li>Public: The default visibility modifier. The member is visible everywhere.</li> <li>Private: The member is visible only within the class or file where it is declared.</li> <li>Protected: The member is visible within the class and its subclasses.</li> <li>Internal: The member is visible within the same module.</li> </ol> <pre><code>class Example {\nprivate var privateVar: Int = 1\nprotected var protectedVar: Int = 2\ninternal var internalVar: Int = 3\npublic var publicVar: Int = 4\n} fun main() {\nval example = Example()\n\nprintln(example.publicVar) // Accessible\nprintln(example.privateVar) // Error: Not accessible\nprintln(example.protectedVar) // Error: Not accessible\nprintln(example.internalVar) // Accessible if in the same module\n}\n</code></pre> <p>Info</p> <p>A module is a collection of source files and build settings that let you divide your project into discrete units of functionality. Your project can have one or many modules. You can independently build, test, and debug each module.</p> <p>In an Android project, a module is typically an Android app or a library.</p> <p>A package is like a directory or a folder that groups related classes, whereas a module provides a container for your app's source code, resource files, and app-level settings. A module can contain multiple packages.</p> <p>You can also apply visibility modifiers to methods:</p> <pre><code>class Example {\nprivate fun privateMethod() {\nprintln(\"Private method\")\n}\n}\n\nfun main() {\nval example = Example()\nexample.privateMethod() // Error: Not accessible\n}\n</code></pre> <p>And to constructors:</p> <pre><code>class Example private constructor(val value: Int) {\ncompanion object {\nfun create(value: Int): Example {\nreturn Example(value)\n}\n}\n}\n\nfun main() {\nval example = Example.create(5) // Correct way to create an instance\nval example2 = Example(5) // Error: Constructor is private\n}\n</code></pre> <p>Info</p> <p>In this example we are using a companion object to provide a factory method for creating instances of the class, since the constructor is private.</p> <p>This table helps you determine the appropriate visibility modifiers based on where the property or methods of a class or constructor should be accessible:</p> Modifier Accessible in same class Accessible in subclass Accessible in same module Accessible outside module private \u2714 \ud835\uddeb \ud835\uddeb \ud835\uddeb protected \u2714 \u2714 \ud835\uddeb \ud835\uddeb internal \u2714 \u2714 \u2714 \ud835\uddeb public \u2714 \u2714 \u2714 \u2714"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#property-delegation","title":"Property delegation","text":"<p>Property delegation is a design pattern that allows you to delegate the responsibility of getting and setting a property to another object. In Kotlin, you can use the <code>by</code> keyword to delegate a property to another object.</p> <p>In Android development, we use delegates for example to use the remembered state in Jetpack Compose:</p> <pre><code>var name by rememberSaveable { mutableStateOf(\"John\") }\n</code></pre> <p>In order to use the <code>by</code> keyword, <code>rememberSaveable</code> and <code>mutableStateOf</code>, you need the next imports:</p> <pre><code>import androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.rememberSaveable\nimport androidx.compose.runtime.setValue\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#data-classes","title":"Data classes","text":"<p>A data class is a special type of class in Kotlin that is used to hold data. Data classes automatically generate useful methods such as <code>toString()</code>, <code>equals()</code>, <code>hashCode()</code>, and <code>copy()</code> based on the properties defined in the primary constructor.</p> <pre><code>data class User(val name: String, val age: Int)\n\nfun main() {\nval user1 = User(\"Alice\", 30)\nval user2 = User(\"Alice\", 30)\n\nprintln(user1) // User(name=Alice, age=30)\nprintln(user1 == user2) // true\nprintln(user1.copy(age = 31)) // User(name=Alice, age=31)\n}\n</code></pre> <p>A data class is equivalent to a Java class with only properties, getters, setters, <code>toString()</code>, <code>equals()</code>, and <code>hashCode()</code> methods.</p> <p>The <code>copy</code> function creates a new instance of the data class with the same property values as the original instance, but allows you to modify specific properties. In the example above, we created a new <code>User</code> instance with the same name as <code>user1</code>, but with a different age.</p>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#generic-classes","title":"Generic classes","text":"<p>Generics allow you to create classes, interfaces, and functions that can work with different data types while providing type safety. You can define a generic class by adding a type parameter in angle brackets (<code>&lt;&gt;</code>) after the class name.</p> <pre><code>class Box&lt;T&gt;(val value: T) {\nfun getVal(): T {\nreturn value\n}\n}   fun main() {\nval intBox = Box(123)\nval strBox = Box(\"Hello\")\n\nprintln(intBox.getVal()) // prints 123\nprintln(strBox.getVal()) // prints \"Hello\"\n}\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#enum-classes","title":"Enum classes","text":"<p>An enum class is a special type of class in Kotlin that represents a group of related constants. Each constant is an instance of the enum class.</p> <pre><code>enum class Direction {\nNORTH, SOUTH, EAST, WEST\n}   fun main() {\nval dir = Direction.NORTH\nprintln(dir) // prints \"NORTH\"\n}\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#singleton-objects","title":"Singleton objects","text":"<p>In Kotlin, you can create a singleton object using the <code>object</code> keyword. A singleton object is a class that has only one instance throughout the application.</p> <pre><code>object Database {\nfun connect() {\nprintln(\"Connected to the database\")\n}\n}   fun main() {\nDatabase.connect() // prints \"Connected to the database\"\n}\n</code></pre> <p>You can also create companion objects within a class. A companion object is an object that is associated with a class and can access its private members.</p> <pre><code>class MyClass {\ncompanion object {\nfun create(): MyClass {\nreturn MyClass()\n}\n}\n}   fun main() {\nval myClass = MyClass.create()\n} // creates an instance of MyClass\n</code></pre> <p>An example of companion object is the <code>Modifier</code> object in Jetpack Compose:</p> <pre><code>import androidx.compose.ui.Modifier\n\nval myModifier = Modifier.padding(16.dp).fillMaxWidth()\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#interfaces","title":"Interfaces","text":"<p>An interface is a contract that defines a set of methods and properties that a class must implement. In Kotlin, you can define an interface using the <code>interface</code> keyword.</p> <pre><code>interface Shape {\nfun area(): Double\nfun perimeter(): Double\n}\n\nclass Circle(private val radius: Double) : Shape {\noverride fun area(): Double {\nreturn Math.PI * radius * radius\n}\n\noverride fun perimeter(): Double {\nreturn 2 * Math.PI * radius\n}\n}\n\nfun main() {\nval circle = Circle(5.0)\nprintln(\"Area: ${circle.area()}\") // prints \"Area: 78.53981633974483\"\nprintln(\"Perimeter: ${circle.perimeter()}\") // prints \"Perimeter: 31.41592653589793\"\n}\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#collections","title":"Collections","text":"<p>Kotlin provides several collection types to store and manipulate groups of related data. The most commonly used collection types are lists, sets, and maps.</p>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#arrays","title":"Arrays","text":"<p>An array is a collection of elements of the same type. You can create an array using the <code>arrayOf</code> function or the <code>Array</code> class.</p> <pre><code>val numbers = arrayOf(1, 2, 3, 4, 5)\nval strings = Array(3) { i -&gt; \"Item $i\" } // creates an array of strings with 3 elements\n</code></pre> <p>You can access the elements of an array using their index:</p> <pre><code>println(numbers[0]) // prints 1\nnumbers[1] = 10\nprintln(numbers[1]) // prints 10\n</code></pre> <p>You can also use the <code>size</code> property to get the number of elements in an array:</p> <pre><code>println(numbers.size) // prints 5\n</code></pre> <p>To acces all the elements of an array, you can use a <code>for</code> loop:</p> <pre><code>for (num in numbers) {\nprintln(num)\n}\n</code></pre> <p>Or the <code>forEach</code> method:</p> <pre><code>numbers.forEach { num -&gt; println(num) }\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#lists","title":"Lists","text":"<p>A list is an ordered collection of elements that can contain duplicates. You can create a list using the <code>listOf</code> function for an immutable list or the <code>mutableListOf</code> function for a mutable list.</p> <pre><code>val immutableList = listOf(1, 2, 3, 4, 5)\nval mutableList = mutableListOf(1, 2, 3, 4, 5)\n</code></pre> <p>You can access the elements of a list using their index, use the <code>size</code> property, and iterate through the elements in the same way as with arrays.</p> <p>You can add or remove elements from a mutable list using the <code>add</code> and <code>remove</code> methods:</p> <pre><code>mutableList.add(6)\nmutableList.remove(2)\nprintln(mutableList) // prints [1, 3, 4, 5, 6]\n</code></pre> <p>With removeAt you can remove an element at a specific index:</p> <pre><code>mutableList.removeAt(0)\nprintln(mutableList) // prints [3, 4, 5, 6]\n</code></pre> <p>Lists provides the <code>contains</code> method to check if an element is in the list:</p> <pre><code>println(mutableList.contains(4)) // prints true\nprintln(mutableList.contains(2)) // prints false\n</code></pre> <p>Lists also provide many useful methods for manipulating and transforming the data, such as <code>filter</code>, <code>map</code>, <code>reduce</code>, <code>sort</code>, and more.</p>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#sets","title":"Sets","text":"<p>A set is an unordered collection of unique elements. You can create a set using the <code>setOf</code> function for an immutable set or the <code>mutableSetOf</code> function for a mutable set.</p> <pre><code>val immutableSet = setOf(1, 2, 3, 4, 5)\nval foodSet = mutableSetOf(\"Pizza\", \"Burger\", \"Pasta\")\n\nprintln(immutableSet) // prints [1, 2, 3, 4, 5]\nprintln(foodSet) // prints [Pizza, Burger, Pasta]\n</code></pre> <p>You can add an remove elements using the <code>add</code> and <code>remove</code> methods:</p> <pre><code>foodSet.add(\"Salad\")\nprintln(foodSet) // prints [Pizza, Burger, Pasta, Salad]\n\nfoodSet.add(\"Pizza\") // Duplicate, won't be added\nprintln(foodSet) // prints [Pizza, Burger, Pasta, Salad]\n\nfoodSet.remove(\"Burger\")\nprintln(foodSet) // prints [Pizza, Pasta, Salad]\n\nimmutableSet.add(6) // Error: Cannot add to an immutable set\n</code></pre> <p>You can check if an element is in the set using the <code>contains</code> method:</p> <pre><code>println(foodSet.contains(\"Pasta\")) // prints true\nprintln(foodSet.contains(\"Burger\")) // prints false\nprintln(foodSet.size) // prints 3\n</code></pre> <p>As you can see, we can query the size of the set using the <code>size</code> property.</p>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#maps","title":"Maps","text":"<p>A map is a collection of key-value pairs. You can create a map using the <code>mapOf</code> function for an immutable map or the <code>mutableMapOf</code> function for a mutable map.</p> <pre><code>val foodCaloriesMap = mutableMapOf(\n\"Pizza\" to 266,\n\"Burger\" to 295,\n\"Pasta\" to 131\n)\nprintln(foodCaloriesMap) // prints {Pizza=266, Burger=295, Pasta=131}\n</code></pre> <p>You can also declare an empty mutable map and add key-value pairs later:</p> <pre><code>val countryCapitalMap = mutableMapOf&lt;String, String&gt;()\ncountryCapitalMap[\"USA\"] = \"Washington D.C.\"\ncountryCapitalMap[\"France\"] = \"Paris\"\nprintln(countryCapitalMap) // prints {USA=Washington, D.C., France=Paris}\n</code></pre> <p>You can access the values in a map using their keys:</p> <pre><code>println(foodCaloriesMap[\"Pizza\"]) // prints 266\nfoodCaloriesMap[\"Pizza\"] = 270 // Update value\nprintln(foodCaloriesMap[\"Pizza\"]) // prints 270\n</code></pre> <p>The <code>remove()</code> method removes the key-value pair with the specified key. It also returns the removed value, or <code>null</code>, if the specified key isn't in the map.</p> <pre><code>val removedCalories = foodCaloriesMap.remove(\"Burger\")\nprintln(removedCalories) // prints 295\nprintln(foodCaloriesMap) // prints {Pizza=270, Pasta=131}\n</code></pre> <p>You can check if a key is in the map using the <code>containsKey</code> method:</p> <pre><code>println(foodCaloriesMap.containsKey(\"Pasta\")) // prints true\nprintln(foodCaloriesMap.containsKey(\"Burger\")) // prints false\n</code></pre> <pre><code>println(foodCaloriesMap.size) // prints 2\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#collection-operations","title":"Collection operations","text":"<p>Kotlin provides many useful functions to manipulate collections. Here are some common operations:</p> <ul> <li><code>filter</code>: Returns a list containing only elements that match the given predicate.</li> </ul> <pre><code>val numbers = listOf(1, 2, 3, 4, 5, 6)\nval evenNumbers = numbers.filter { it % 2 == 0 }\nprintln(evenNumbers) // prints [2, 4, 6]\n</code></pre> <ul> <li><code>map</code>: Returns a list containing the results of applying the given transformation function to each element.</li> </ul> <pre><code>val squaredNumbers = numbers.map { it * it }\nprintln(squaredNumbers) // prints [1, 4, 9, 16, 25, 36]\n</code></pre> <ul> <li><code>reduce</code>: Accumulates value starting with the first element and applying the operation from left to right.</li> </ul> <pre><code>val sum = numbers.reduce { acc, num -&gt; acc + num }\nprintln(sum) // prints 21\n</code></pre> <ul> <li><code>sort</code>: Returns a list sorted according to natural sort order or by a specified comparator.</li> </ul> <pre><code>val unsortedNumbers = listOf(5, 2, 8, 1, 4)\nval sortedNumbers = unsortedNumbers.sorted()\nprintln(sortedNumbers) // prints [1, 2, 4, 5, 8]\n</code></pre> <ul> <li><code>forEach</code>: Performs the given action on each element.</li> </ul> <pre><code>numbers.forEach { num -&gt; println(num) }\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#exceptions-and-error-handling","title":"Exceptions and error handling","text":"<p>Kotlin provides a robust mechanism for handling exceptions and errors using <code>try</code>, <code>catch</code>, and <code>finally</code> blocks.</p>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#try-catch-finally","title":"try-catch-finally","text":"<p>The <code>try</code> block contains the code that may throw an exception. The <code>catch</code> block is used to handle the exception, and the <code>finally</code> block contains code that will always be executed, regardless of whether an exception was thrown or not.</p> <pre><code>try {\nval result = 10 / 0\nprintln(\"Result: $result\")\n} catch (e: ArithmeticException) {\nprintln(\"Error: Division by zero\")\n} finally {\nprintln(\"Execution completed\")\n}\n</code></pre> <p>The <code>finally</code> block is optional and can be omitted if not needed.</p>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#throwing-exceptions","title":"Throwing exceptions","text":"<p>You can throw exceptions in Kotlin using the <code>throw</code> keyword. You can throw both built-in exceptions and custom exceptions.</p> <pre><code>fun validateAge(age: Int) {\nif (age &lt; 0) {\nthrow IllegalArgumentException(\"Age cannot be negative\")\n}\n}\n\ntry {\nvalidateAge(-5)\n} catch (e: IllegalArgumentException) {\nprintln(\"Error: ${e.message}\")\n}\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#coroutines","title":"Coroutines","text":"<p>Coroutines are a powerful feature in Kotlin that allows you to write asynchronous and non-blocking code in a sequential manner. They are lightweight threads that can be suspended and resumed without blocking the main thread.</p> <p>To use coroutines in your Kotlin project, you need to add the following dependencies to your <code>build.gradle</code> file:</p> <p><pre><code>implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:1.5.2'\nimplementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.5.2' // For Android projects\n</code></pre> Once you have added the dependencies, you can start using coroutines in your code. Here is a simple example of how to use coroutines:</p> <pre><code>import kotlinx.coroutines.*\n\nfun main() {\nGlobalScope.launch {\ndelay(1000L)\nprintln(\"World!\")\n}\nprintln(\"Hello,\")\nThread.sleep(2000L)\n}\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#runblocking","title":"runBlocking","text":"<p>If we want to perform a synchronous operation blocking the main thread, we would do something like this:</p> <pre><code>fun main() {\nrunBlocking {\nprintln(\"Weather forecast\")\ndelay(1000)\nprintln(\"Sunny\")\n}\n}\n</code></pre> <p>The <code>delay</code> function is a special suspending function that does not block the thread, but only suspends the coroutine for a specific time.</p> <p>The <code>runBlocking</code> function is used to start a new coroutine and block the current thread until its completion. It is typically used in main functions and tests.</p> <p>You can use <code>launch</code> inside <code>runBlocking</code> to start new coroutines. These coroutines will run concurrently with the main coroutine started by <code>runBlocking</code>, although the main coroutine will wait for their completion before it completes itself.</p> <pre><code>fun main() {\nrunBlocking {\nlaunch {\ndelay(1000L)\nprintln(\"World!\")\n}\nprintln(\"Hello,\")\n}\n}\n</code></pre> <p>This will print \"Hello,\" and \"World!\", because println(\"Hello,\") is executed immediately, while the coroutine launched with <code>launch</code> is delayed by 1 second before printing \"World!\". Finally, the <code>runBlocking</code> will wait for the launched coroutine to complete before exiting.</p>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#async-and-await","title":"async and await","text":"<p>The <code>async</code> function is used to start a new coroutine that returns a result. It returns a <code>Deferred</code> object, which represents a future result of the coroutine. You can use the <code>await</code> function to get the result of the coroutine.</p> <pre><code>fun main() {\nrunBlocking {\nval deferred = async {\ndelay(1000L)\n\"Hello, World!\"\n}\nprintln(\"Waiting for result...\")\nval result = deferred.await()\nprintln(result)\n}\n}\n</code></pre> <p>In this code, we start a new coroutine using <code>async</code>, which will return a string after a delay of 1 second. We then use <code>await</code> to get the result of the coroutine and print it.</p>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#suspending-functions","title":"Suspending functions","text":"<p>A suspending function is a special type of function that can be paused and resumed at a later time. Suspend functions are defined using the <code>suspend</code> keyword.</p> <pre><code>suspend fun fetchData(): String {\ndelay(1000L) // Simulate a long-running operation\nreturn \"Data fetched\"\n}\n</code></pre> <p>You can call suspend functions only from other suspend functions or from a coroutine.</p> <pre><code>fun main() {\nGlobalScope.launch {\nval data = fetchData()\nprintln(data)\n}\nThread.sleep(2000L)\n}\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#coroutine-scopes","title":"Coroutine scopes","text":"<p>A coroutine scope defines the context in which coroutines run. It is used to manage the lifecycle of coroutines and to ensure that they are cancelled when no longer needed.</p> <pre><code>fun main() {\nrunBlocking {\nlaunch {\n// Coroutine code here\n}\n}\n}\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#coroutinescope","title":"coroutineScope","text":"<p>The <code>coroutineScope</code> builder creates a new coroutine scope and suspends the current coroutine until all child coroutines are completed.</p> <pre><code>suspend fun fetchData(): String {\ndelay(1000L) // Simulate a long-running operation\nreturn \"Data fetched\"\n}\n\ncoroutineScope.launch {\nval data = fetchData()\nprintln(data)\n}\n</code></pre> <p>In Android, coroutine scopes are often tied to the lifecycle of components, such as activities or view models, to ensure that coroutines are cancelled when the component is destroyed.</p>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#viewmodelscope","title":"viewModelScope","text":"<p>In Android, the <code>viewModelScope</code> is a predefined coroutine scope that is tied to the lifecycle of a ViewModel. It is automatically cancelled when the ViewModel is cleared, making it a convenient way to launch coroutines in a ViewModel.</p> <pre><code>class MyViewModel : ViewModel() {\nfun fetchData() {\nviewModelScope.launch {\nval data = fetchData()\nprintln(data)\n}\n}\n}\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#references","title":"References","text":"<ul> <li>Kotlin coroutines</li> <li>Android Studio coroutines</li> </ul>"},{"location":"U02%20Android%20basics/U02.2%20Basic%20Android/","title":"Unit 2.2. Introduction to Mobile Development","text":"<p>In this unit we will learn the basics of Jetpack Compose. We will see the different components that make up a Compose application and how to create user interfaces with Compose.</p>"},{"location":"U02%20Android%20basics/U02.2%20Basic%20Android/#getting-started-with-jetpack-compose","title":"Getting Started with Jetpack Compose","text":"<p>Jetpack Compose is a modern toolkit for building Android UIs. It simplifies and accelerates UI development on Android with less code, powerful tools, and intuitive Kotlin APIs. You can build then UI by defining composable functions that describe your UI.</p> <p>To get started with Jetpack Compose, you need to set up your development environment. This includes installing Android Studio and the necessary SDKs. Once your environment is set up, you can create a new Compose project using the \"Empty Activity\" template and start building your user interface.</p> <p>Info</p> <p>To view how was developing with XML views, create a new project with \"Empty Views Activity\" template.</p>"},{"location":"U02%20Android%20basics/U02.2%20Basic%20Android/#composable-functions","title":"Composable Functions","text":"<p>A composable function is a special type of function that can be used to define a part of your UI. Composable functions are annotated with the <code>@Composable</code> annotation. Here is an example of a simple composable function that displays a text:</p> <pre><code>@Composable\nfun Greeting(name: String) {\nText(text = \"Hello, $name!\")\n}\n</code></pre> <p>An annotation is a special kind of metadata that can be added to code elements such as classes, functions, or properties. Annotations provide additional information about the code and can be used by the compiler or runtime to modify behavior or perform specific actions.</p> <p>Some annotations can take parameters, which allow you to provide additional information or configuration. For example, the <code>@Composable</code> annotation does not take any parameters, but other annotations like <code>@Preview</code> can take parameters to customize the preview behavior:</p> <pre><code>@Preview(showBackground = true)\n@Composable\nfun DefaultPreview() {\nGreeting(\"Android\")\n}\n</code></pre> <ul> <li>Composable functions can accept arguments, just like regular functions. In the example above, the <code>Greeting</code> function takes a <code>name</code> parameter and uses it to display a personalized greeting. They can also return values, although it's not common practice in Compose.</li> <li>Composable functions can be nested, allowing you to create complex UIs by combining smaller, reusable components. For example, you can create a <code>UserProfile</code> composable that includes a <code>ProfilePicture</code> and a <code>UserName</code> composable.</li> <li>The name of a composable function should be descriptive and follow the standard naming conventions for functions in Kotlin. It's common to use PascalCase for composable function names, as they represent UI components. Examples: <code>UserProfile</code>, <code>LoginButton</code>, <code>ProductList</code>.</li> </ul>"},{"location":"U02%20Android%20basics/U02.2%20Basic%20Android/#modifiers","title":"Modifiers","text":"<p>Modifiers are used to change the appearance or behavior of a composable function. They can be used to set properties such as size, padding, background color, and more. Modifiers are applied to composable functions using the <code>Modifier</code> class. Here is an example of how to use modifiers to set the padding and background color of a <code>Text</code> composable:</p> <pre><code>Text(\ntext = \"Hello, World!\",\nmodifier = Modifier\n.padding(16.dp)\n.background(Color.LightGray)\n)\n</code></pre> <p>Passing modifiers to custom composables is a common practice in Jetpack Compose. It allows you to provide flexibility and customization options for the composable's appearance and behavior. By accepting a <code>Modifier</code> parameter, you enable users of your composable to apply their own modifiers, such as padding, size, or click handling.</p> <p>Here is an example of a custom composable that accepts a <code>Modifier</code> parameter:</p> <pre><code>@Composable\nfun CustomButton(\nonClick: () -&gt; Unit,\nmodifier: Modifier = Modifier\n) {\nButton(\nonClick = onClick,\nmodifier = modifier\n) {\nText(\"Custom Button\")\n}\n}\n</code></pre> <p>Info</p> <p>In the example above, the <code>CustomButton</code> composable accepts a <code>modifier</code> parameter of the type <code>Modifier</code> with a default value of <code>Modifier</code> (a companion object that provides default values for the <code>Modifier</code> class).</p> <p>We can call this <code>CustomButton</code> composable and pass our own modifiers to customize its appearance:</p> <pre><code>CustomButton(\nonClick = { /* Handle click */ },\nmodifier = Modifier\n.padding(8.dp)\n.background(Color.Blue)\n)\n</code></pre> <p>dp and sp</p> <p>dp and sp are units of measurement used in Android development to ensure that UI elements are displayed consistently across different screen sizes and densities.</p> <ul> <li> <p>dp (density-independent pixels): A unit of measurement that is based on the physical density of the screen. It is used for defining layout dimensions and spacing. 1 dp is equivalent to one pixel on a 160 dpi screen. </p> </li> <li> <p>sp (scale-independent pixels): A unit of measurement that is similar to dp but is also scaled based on the user's font size preference. It is primarily used for defining font sizes. 1 sp is equivalent to one pixel on a 160 dpi screen, but it can be scaled up or down based on the user's font size settings.</p> </li> </ul>"},{"location":"U02%20Android%20basics/U02.2%20Basic%20Android/#lifecycle-of-composables","title":"Lifecycle of composables","text":"<p>Composable functions have a lifecycle that is managed by the Compose runtime. The lifecycle of a composable function includes the following stages: 1. Composition: When a composable function is called, it is composed, and its UI elements are created and added to the UI tree. 2. Recomposition: When the state of a composable function changes, it is recomposed, and its UI elements are updated to reflect the new state. 3. Disposal: When a composable function is no longer needed, it is disposed of, and its UI elements are removed from the UI tree.</p> <p></p>"},{"location":"U02%20Android%20basics/U02.2%20Basic%20Android/#layouts-and-ui-components","title":"Layouts and UI Components","text":""},{"location":"U02%20Android%20basics/U02.2%20Basic%20Android/#common-layouts","title":"Common Layouts","text":"<p>Jetpack Compose provides several layout components that help you arrange your UI elements. Some of the most commonly used layouts include:</p>"},{"location":"U02%20Android%20basics/U02.2%20Basic%20Android/#column","title":"Column","text":"<p>Arranges its children in a vertical sequence.</p> <pre><code>Column {\nText(\"Item 1\")\nText(\"Item 2\")\nText(\"Item 3\")\n}\n</code></pre>"},{"location":"U02%20Android%20basics/U02.2%20Basic%20Android/#row","title":"Row","text":"<p>Arranges its children in a horizontal sequence.</p> <pre><code>Row {\nText(\"Item 1\")\nText(\"Item 2\")\nText(\"Item 3\")\n}\n</code></pre>"},{"location":"U02%20Android%20basics/U02.2%20Basic%20Android/#box","title":"Box","text":"<p>Stacks its children on top of each other.</p> <pre><code>Box {\nText(\"Item 1\")\nText(\"Item 2\")\n}\n</code></pre> <p></p>"},{"location":"U02%20Android%20basics/U02.2%20Basic%20Android/#lazycolumn","title":"LazyColumn","text":"<p>A vertically scrolling list that only composes and lays out the currently visible items.</p> <pre><code>LazyColumn {\nitems(100) { index -&gt;\n\nText(\"Item #$index\")\n}\n}\n</code></pre>"},{"location":"U02%20Android%20basics/U02.2%20Basic%20Android/#spacer","title":"Spacer","text":"<p>A spacer is a composable that creates an empty space between UI elements. It can be used to adjust the layout and improve the visual appearance of your UI using modifiers to set its width and height, like <code>Modifier.width()</code> and <code>Modifier.height()</code>.</p> <pre><code>Row {\nText(\"Item 1\")\nSpacer(modifier = Modifier.width(16.dp))\nText(\"Item 2\")\n}\n</code></pre>"},{"location":"U02%20Android%20basics/U02.2%20Basic%20Android/#dividers","title":"Dividers","text":"<p>A divider is a composable that creates a visual divider between UI elements. You can implement dividers in your app using the <code>HorizontalDivider</code> and <code>VerticalDivider</code>.</p> <pre><code>Column {\nText(\"Item 1\")\nHorizontalDivider(\nthickness = 2.dp,\ncolor = Color.DarkGray\n)\nText(\"Item 2\")\n}\n</code></pre> <pre><code>Row {\nText(\"Item 1\")\nVerticalDivider()\nText(\"Item 2\")\n}\n</code></pre> <p>Layouts in Compose</p>"},{"location":"U02%20Android%20basics/U02.2%20Basic%20Android/#ui-components","title":"UI Components","text":"<p>Jetpack Compose provides a variety of UI components that you can use to build your user interface. Some of the most commonly used components include:</p>"},{"location":"U02%20Android%20basics/U02.2%20Basic%20Android/#text","title":"Text","text":"<p>Displays a text string.</p> <pre><code>Text(\"Hello, World!\")\n</code></pre> <p>But the recommendation is to display text from resources:</p> <pre><code>Text(stringResource(R.string.hello_world))\n</code></pre> <p>In this example, <code>R.string.hello_world</code> is a reference to a string resource defined in the <code>res/values/strings.xml</code> file.</p> <p>You can change the color, font size, font style, and more by using parameters:</p> <pre><code>Text(\ntext = \"Hello, World!\",\ncolor = Color.Red,\nfontSize = 24.sp,\nfontStyle = FontStyle.Italic,\nfontWeight = FontWeight.Bold,\nfontFamily = FontFamily.Serif,\ntextAlign = TextAlign.Center,\n)\n</code></pre> <p>You can also use the <code>style</code> parameter:</p> <pre><code>Text(\ntext = \"Hello, World!\",\nstyle = TextStyle(\nfontSize = 20.sp,\nfontWeight = FontWeight.Bold,\ncolor = Color.Blue\n)\n)\n</code></pre> <p>Don't forget to import the necessary classes:</p> <pre><code>import androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.text.TextStyle\n... </code></pre> <p>Text in Compose</p>"},{"location":"U02%20Android%20basics/U02.2%20Basic%20Android/#text-fields","title":"Text fields","text":"<p>A text field allows the user to enter and edit text.</p> <pre><code>var state by rememberSaveable { mutableStateOf(\"Hello\") }\nTextField(\nvalue = state,\nonValueChange = { state = it },\nlabel = { Text(\"Label\") },\n)\n</code></pre> <p></p> <p>In this code we use <code>rememberSaveable</code> to save the state of the text field across recompositions and configuration changes, such as screen rotations. And <code>mutableStateOf</code> to create a mutable state variable that holds the current value of the text field.</p> <p>You can also use <code>OutlinedTextField</code> for a different style:</p> <pre><code>var state by rememberSaveable { mutableStateOf(\"Hello\") }\nOutlinedTextField(\nvalue = state,\nonValueChange = { state = it },\nlabel = { Text(\"Label\") },\n)\n</code></pre> <p></p> <p>Other parameters you can use are <code>placeholder</code>, <code>leadingIcon</code>, <code>trailingIcon</code>, <code>isError</code>, <code>singleLine</code>, <code>maxLines</code>, <code>keyboardOptions</code>, <code>keyboardActions</code>, etc.</p> <p>TextField</p>"},{"location":"U02%20Android%20basics/U02.2%20Basic%20Android/#images","title":"Images","text":"<p>To display an image, you can use the <code>Image</code> composable. You can load images from resources, URLs, or other sources.</p> <pre><code>Image(\npainter = painterResource(R.drawable.ic_launcher_foreground),\ncontentDescription = \"My Image\",\n)\n</code></pre> <p><code>painterResource</code> is used to load an image from resources.</p> <p>You also need to provide a content description for accessibility purposes.</p> <p>Images</p>"},{"location":"U02%20Android%20basics/U02.2%20Basic%20Android/#buttons","title":"Buttons","text":"<p>A button is a clickable component that can be used to perform an action when clicked.</p> <p>There are several types of buttons available in Jetpack Compose, each with its own appearance and purpose:</p> Type Appearance Purpose Filled Solid background with contrasting text. High-emphasis buttons. These are for primary actions in an application, such as \"submit\" and \"save.\" The shadow effect highlights the button's importance. Filled tonal Background color varies to match the surface. Also for primary or significant actions. Filled tonal buttons provide more visual weight and suit functions such as \"add to cart\" and \"Sign in.\" Elevated Stands out by having a shadow. Serves a similar purpose to tonal buttons. Increase elevation to make the button appear even more prominently. Outlined Features a border with no fill. Medium-emphasis buttons, containing actions that are important but not primary. They pair well with other buttons to indicate alternative, secondary actions like \"Cancel\" or \"Back.\" Text Displays text with no background or border. Low-emphasis buttons, ideal for less critical actions such as navigational links, or secondary functions like \"Learn More\" or \"View details.\" <p></p> <pre><code>Button(\nonClick = { /* Handle click */ }) {\nText(\"Click Me\")\n}\n</code></pre> <p>Parameters:</p> <ul> <li>onClick:     The function that the system calls when the user presses the button.</li> <li>enabled:     When false, this parameter makes the button appear unavailable and inactive.</li> <li>contentPadding:     The padding within the button.</li> </ul> <p>Buttons</p>"},{"location":"U02%20Android%20basics/U02.2%20Basic%20Android/#floating-action-button-fab","title":"Floating Action Button (FAB)","text":"<p>A Floating Action Button (FAB) is a circular button that floats above the UI and is used for a primary action in an application.</p> <pre><code>FloatingActionButton(\nonClick = { /* Handle click */ }\n) {\nIcon(Icons.Filled.Add, contentDescription = \"Add\")\n}\n</code></pre> <p>In Material Design, there are four types of FAB:</p> <ul> <li>FAB: A floating action button of ordinary size.</li> <li>Small FAB: A smaller floating action button.</li> <li>Large FAB: A larger floating action button.</li> <li>Extended FAB: A floating action button that contains more than just an icon.</li> </ul> <p></p> <p>Some parameters you can use: * shape: The shape of the FAB. * containerColor: The background color of the FAB. * contentColor: The color of the content inside the FAB. * elevation: The elevation of the FAB.</p> <pre><code>FloatingActionButton(\nonClick = { /* Handle click */ },\nshape = CircleShape,\ncontainerColor = Color.DarkGray,\ncontentColor = Color.White,\nelevation = FloatingActionButtonDefaults.elevation(8.dp)\n) {\nIcon(Icons.Filled.Add, contentDescription = \"Add\")\n}\n</code></pre> <p>FAB</p> <p>More buttons:</p> <ul> <li>Icon buttons</li> <li>Segmented buttons</li> </ul>"},{"location":"U02%20Android%20basics/U02.2%20Basic%20Android/#snackbar","title":"Snackbar","text":"<p>A Snackbar is a small banner that appears at the bottom of the screen to provide feedback about an operation. It can also contain an action button.</p> <p>To implement a snackbar, you first create <code>SnackbarHost</code>, which includes a <code>SnackbarHostState</code> property. <code>SnackbarHostState</code> provides access to the <code>showSnackbar()</code> function which you can use to display your snackbar.This suspending function requires a <code>CoroutineScope</code> such as with using <code>rememberCoroutineScope</code> - and can be called in response to UI events to show a Snackbar.</p> <pre><code>val snackbarHostState = remember { SnackbarHostState() }\nval scope = rememberCoroutineScope()\nButton(onClick = {\nscope.launch {\nsnackbarHostState.showSnackbar(\"Hello, Snackbar!\")\n}\n}) {\nText(\"Show Snackbar\")\n}\nSnackbarHost(hostState = snackbarHostState)\n</code></pre> <p></p> <p>You can provide an optional action and adjust the duration of the Snackbar:</p> <pre><code>val snackbarHostState = remember { SnackbarHostState() }\nval scope = rememberCoroutineScope()\nButton(onClick = {\nscope.launch {\nval result = snackbarHostState\n.showSnackbar(\nmessage = \"Snackbar\",\nactionLabel = \"Action\",\n// Defaults to SnackbarDuration.Short\nduration = SnackbarDuration.Indefinite\n)\nwhen (result) {\nSnackbarResult.ActionPerformed -&gt; {\n/* Handle snackbar action performed */\n}\nSnackbarResult.Dismissed -&gt; {\n/* Handle snackbar dismissed */\n}\n}\n}\n}) {\nText(\"Show Snackbar\")\n}\nSnackbarHost(hostState = snackbarHostState)\n</code></pre> <p>Some parameters: * actionLabel: The label for the action button. * duration: The duration for which the snackbar is displayed. It can be <code>SnackbarDuration.Short</code>, <code>SnackbarDuration.Long</code>, or <code>SnackbarDuration.Indefinite</code>.</p> <p>Snackbar</p>"},{"location":"U02%20Android%20basics/U02.2%20Basic%20Android/#cards","title":"Cards","text":"<p>A <code>Card</code> is a composable that displays content and actions on a single topic. Cards are used to group related information and make it easier to scan and understand.</p> <pre><code>Card(\nmodifier = Modifier.padding(16.dp),\nelevation = CardDefaults.cardElevation(\ndefaultElevation = 6.dp\n)\n) {\nColumn(modifier = Modifier.padding(16.dp)) {\nText(\"Card Title\", fontWeight = FontWeight.Bold)\nSpacer(modifier = Modifier.height(8.dp))\nText(\"Card content goes here.\")\nSpacer(modifier = Modifier.height(8.dp))\nButton(onClick = { /* Handle click */ }) {\nText(\"Click me\")\n}\n}\n}\n</code></pre> <p></p> <p>Similar to <code>Card</code> is <code>ElevatedCard</code>, which has a more pronounced shadow effect.</p> <p>Cards</p>"},{"location":"U02%20Android%20basics/U02.2%20Basic%20Android/#surface","title":"Surface","text":"<p>A <code>Surface</code> is a composable that provides a background for other UI elements. It can be used to create cards, buttons, and other components that need a background.</p> <pre><code>Surface(\nmodifier = Modifier.padding(16.dp),\ncolor = MaterialTheme.colorScheme.primary,\nshape = RoundedCornerShape(8.dp),\nshadowElevation = 4.dp\n) {\nText(\ntext = \"Hello, Surface!\",\nmodifier = Modifier.padding(16.dp),\ncolor = Color.White\n)\n}\n</code></pre> <p></p>"},{"location":"U02%20Android%20basics/U02.2%20Basic%20Android/#scaffold","title":"Scaffold","text":"<p>A <code>Scaffold</code> is a layout structure that provides a framework for implementing the basic material design layout structure. It includes slots for the most common top-level material components such as <code>TopAppBar</code>, <code>BottomAppBar</code> and <code>FloatingActionButton</code>.</p> <p>You usually pass a lambda to the <code>Scaffold</code> content parameter, which provides the inner padding values to be applied to the content inside the scaffold.</p> <pre><code>Scaffold(\ntopBar = {\nTopAppBar(\ntitle = { Text(\"My App\") },\ncolors = topAppBarColors(\ncontainerColor = MaterialTheme.colorScheme.primaryContainer,\ntitleContentColor = MaterialTheme.colorScheme.primary,\n),\n)\n},\nfloatingActionButton = {\nFloatingActionButton(onClick = { /* Handle click */ }) {\nIcon(Icons.Filled.Add, contentDescription = \"Add\")\n}\n},\nbottomBar = {\nBottomAppBar {\nText(\ntext = \"Bottom App Bar\",\nmodifier = Modifier.padding(16.dp),\ncolor = MaterialTheme.colorScheme.onPrimaryContainer\n)\n}\n},\n) { innerPadding -&gt;\nColumn(modifier = Modifier.padding(innerPadding)) {\nText(\"Hello, Scaffold!\") }\n}\n</code></pre> <p></p> <p>Scaffold</p> <p>App bars</p>"},{"location":"U02%20Android%20basics/U02.2%20Basic%20Android/#other-components","title":"Other components","text":"<ul> <li>Checkbox</li> <li>Radio Button</li> <li>Switch</li> <li>Progress Indicator</li> <li>Slider</li> <li>Tabs</li> <li>Menus</li> <li>Dialogs</li> <li>Tooltips</li> <li>Badges</li> <li>Chips</li> </ul>"},{"location":"U02%20Android%20basics/U02.2%20Basic%20Android/#theming-and-styling","title":"Theming and Styling","text":"<p>It's very easy to apply theming and styling in Jetpack Compose. You can use the <code>MaterialTheme</code> composable to apply a material design theme to your app.</p> <p><pre><code>class MainActivity : ComponentActivity() {\noverride fun onCreate(savedInstanceState: Bundle?) {\nsuper.onCreate(savedInstanceState)\nsetContent {\nMaterialTheme {\n// Your app content goes here\n}\n}\n}\n}\n</code></pre> You can create your own custom theme by defining colors, typography, and shapes. You can then apply your custom theme using the <code>MaterialTheme</code> composable.</p> <pre><code>@Composable\nfun MyAppTheme(content: @Composable () -&gt; Unit) {\nMaterialTheme(\ncolorScheme = lightColorScheme(\nprimary = Color(0xFF6200EE),\nsecondary = Color(0xFF03DAC5)\n),\ntypography = MaterialTheme.typography.copy(\nbodyLarge = TextStyle(\nfontFamily = FontFamily.Serif,\nfontWeight = FontWeight.Normal,\nfontSize = 16.sp\n)\n),\nshapes = MaterialTheme.shapes.copy(\nsmall = RoundedCornerShape(4.dp),\nmedium = RoundedCornerShape(8.dp),\nlarge = RoundedCornerShape(12.dp)\n),\ncontent = content\n)\n}\n</code></pre> <p>It's a good practice to create a separate file for your theme, colors, typography, and shapes. For example, you can create a file named <code>Theme.kt</code> and define your custom theme there.</p> <pre><code>@Composable\nfun MyAppTheme(content: @Composable () -&gt; Unit) {\nMaterialTheme(\ncolors = myColorPalette,\ntypography = myTypography,\nshapes = myShapes,\ncontent = content\n)\n}\n</code></pre> <p>An example of <code>myTypography</code>:</p> <pre><code>val myTypography = Typography(\nbodyLarge = TextStyle(\nfontFamily = FontFamily.Serif,\nfontWeight = FontWeight.Normal,\nfontSize = 16.sp\n)\n)\n</code></pre> <p><code>myShapes</code> example:</p> <pre><code>val myShapes = Shapes(\nsmall = RoundedCornerShape(4.dp),\nmedium = RoundedCornerShape(8.dp),\nlarge = RoundedCornerShape(12.dp)\n)\n</code></pre> <p>And <code>myColorPalette</code>:</p> <pre><code>val myColorPalette = lightColorScheme(\nprimary = Color(0xFF6200EE),\nsecondary = Color(0xFF03DAC5),\nbackground = Color(0xFFFFFFFF),\nsurface = Color(0xFFFFFFFF),\nonPrimary = Color(0xFFFFFFFF),\nonSecondary = Color(0xFF000000),\nonBackground = Color(0xFF000000),\nonSurface = Color(0xFF000000),\n)\n</code></pre>"},{"location":"U03%20Android%20architecture/U03.1%20Android%20architecture%20copy/","title":"Unit 3.1. Android architecture","text":"<p>Android architecture is a set of guidelines and best practices for building Android applications. It provides a structured approach to app development, making it easier to manage complexity and maintain code quality. The key components of Android architecture include:</p> <ol> <li> <p>Activities and Fragments: The building blocks of the user interface in Android. Activities represent a single screen, while fragments are reusable components that can be embedded within activities.</p> </li> <li> <p>ViewModel: A class that holds and manages UI-related data in a lifecycle-conscious way. ViewModels survive configuration changes, such as screen rotations, making them ideal for storing UI state.</p> </li> <li> <p>Repository: A class that abstracts data access from multiple sources, such as a local database and a remote server. Repositories provide a clean API for data access, making it easier to switch between data sources.</p> </li> <li> <p>Room: A persistence library that provides an abstraction layer over SQLite. Room simplifies database access and allows for compile-time verification of SQL queries.</p> </li> <li> <p>Dependency Injection: A design pattern that allows for the decoupling of components in an application.</p> </li> </ol> <p>By following these architectural guidelines, developers can create robust, maintainable, and testable Android applications.</p> <p>Fragments</p> <p>Fragments are modular sections of an activity, used to reuse UI components in the old Android architecture. However, with the introduction of Jetpack Compose, fragments are less commonly used in modern Android development.</p>"},{"location":"U03%20Android%20architecture/U03.1%20Android%20architecture%20copy/#references","title":"References","text":"<ul> <li>Guide to App Architecture</li> </ul>"},{"location":"U03%20Android%20architecture/U03.1%20Android%20architecture%20copy/#activities","title":"Activities","text":"<p>Activities are the entry point for interacting with the user in an Android application. Each activity is a single screen with a user interface, and it is responsible for managing the lifecycle of the UI components it contains.</p> <p>Every activity has what is known as a lifecycle, which consists of the different states that an activity can go through, from when the activity first initializes to its destruction, at which time the operating system (OS) reclaims its memory. Typically, the entry point of a program is the <code>main()</code> method. Android activities, however, begin with the <code>onCreate()</code> method.  As the user starts your app, navigates between activities, navigates inside and outside of your app, the activity changes state.</p> <p>The following diagram shows all the activity lifecycle states. As their names indicate, these states represent the status of the activity. An activity can go back and forth between states throughout the lifecycle.</p> <p>Note</p> <p>An Android app can have multiple activities. However, it is recommended to have a single activity.</p> <p></p> <p>Note</p> <p>The <code>onRestart()</code> method is not called every time the state transitions between Created and Started. It is only called if <code>onStop()</code> was called and the activity is subsequently restarted.</p> <p>The lifecycle states are:</p> <ul> <li><code>onCreate()</code>: Activity is being created.</li> <li><code>onStart()</code>: Activity becomes visible.</li> <li><code>onResume()</code>: Activity starts interacting with the user, having focus.</li> <li><code>onPause()</code>: Activity is partially visible, but not in focus.</li> <li><code>onStop()</code>: Activity is completely hidden, but still in memory.</li> <li><code>onDestroy()</code>: Activity is being destroyed.</li> <li><code>onRestart()</code>: Activity is being restarted after being stopped.</li> </ul> <p>Task: exploring lifecycle</p> <ol> <li>Create a new project from the source code of this GitHub repository.</li> <li>Open the <code>MainActivity.kt</code> file and examine the lifecycle methods that have been overridden: <code>onStart</code>, <code>onResume</code>, <code>onPause</code>, <code>onStop</code>, <code>onRestart</code>, <code>onDestroy</code>... Note how thre's a <code>Log.d</code> statement in each method.</li> <li>Run the app on an emulator or a physical device and inspect the logcat output. You should see the lifecycle methods being called as you interact with the app (e.g., opening, closing, navigating away from the app).</li> <li>Do the next to observe the lifecycle methods being called:<ul> <li>Rotate the device to see how the activity is recreated.</li> <li>Press the home button to send the app to the background and then return to it.</li> <li>Open another app to see how your activity is paused and stopped.</li> <li>Press the shared button to share content from your app. See how the activity is paused and resumed.</li> <li>With the app open, go to Setting and make a change, for example, change the device's rotation setting. See how the activity is recreated.</li> </ul> </li> </ol>"},{"location":"U03%20Android%20architecture/U03.1%20Android%20architecture%20copy/#lifecycle-of-a-composable","title":"Lifecycle of a composable","text":"<p>The UI of your app is initially built from running composable functions in a process called Composition.</p> <p>When the state of your app changes, a recomposition is scheduled. Recomposition is when Compose re-executes the composable functions whose state might have changed and creates an updated UI. The Composition is updated to reflect these changes.</p> <p>Composable functions have their own lifecycle that is independent of the Activity lifecycle. Its lifecycle is composed of the events: enters the Composition, recomposing 0 or more times, and then leaving the Composition.</p> <p></p> <p>In order for Compose to track and trigger a recomposition, it needs to know when state has changed. To indicate to Compose that it should track an object's state, the object needs to be of type State or MutableState. The State type is immutable and can only be read. A MutableState type is mutable and allows reads and writes.</p> <p>To create the mutable variable revenue, you declare it using <code>mutableStateOf</code> and an initial value.</p> <p>To instruct Compose to retain and reuse its value during recompositions, you need to declare it with the <code>rememberSaveable</code> function. This function tells Compose to save and restore the value across recompositions and configuration changes, such as screen rotations.</p> <pre><code>var revenue by rememberSaveable { mutableStateOf(0) }\n</code></pre> <p>Info</p> <p>You can also use <code>remember</code> instead of <code>rememberSaveable</code>. The difference is that <code>remember</code> only retains the value during recompositions, but not across configuration changes, i.e., if the screen is rotated or the activity is recreated.</p>"},{"location":"U03%20Android%20architecture/U03.1%20Android%20architecture%20copy/#the-log-class","title":"The Log class","text":"<p>The <code>Log</code> class in Android is used for logging messages that can help developers debug their applications. It provides a way to print messages to the logcat, which is a system-wide logging facility that collects and displays log messages from various sources, including the Android system and applications.</p> <p>First, you must import the <code>Log</code> class at the top of your Kotlin file:</p> <pre><code>import android.util.Log\n</code></pre> <p>A good practice is to define a constant for the log tag, which is a string that identifies the source of the log message (usually the activity's name). This helps in filtering log messages in logcat.</p> <pre><code>private const val TAG = \"MainActivity\"\n</code></pre> <p>Then, you can use the various logging methods provided by the <code>Log</code> class to log messages at different levels of severity:</p> <pre><code>Log.v(TAG, \"Verbose log message\")\nLog.d(TAG, \"Debug log message\")\nLog.i(TAG, \"Info log message\")\nLog.w(TAG, \"Warning log message\")\nLog.e(TAG, \"Error log message\")\n</code></pre>"},{"location":"U03%20Android%20architecture/U03.1%20Android%20architecture%20copy/#intents","title":"Intents","text":"<p>An Intent in Android is a messaging object that you can use to request an action from another app component. Intents are used for various purposes, such as starting activities, services, or broadcasting messages.</p> <p>There are two main types of intents:</p> <ul> <li>Explicit Intents: These intents specify the exact component (activity, service, etc.) to start by providing the class name. They are typically used for starting activities within the same application.</li> </ul> <p>Example of an explicit intent to start a new activity:</p> <pre><code>val intent = Intent(this, SecondActivity::class.java)\nstartActivity(intent)\n</code></pre> <ul> <li>Implicit Intents: These intents do not specify a specific component but instead declare a general action to perform. The Android system then determines the best component to handle the intent based on the action and data provided.</li> </ul> <p>Example of an implicit intent to view a webpage:</p> <pre><code>val intent = Intent(\nIntent.ACTION_VIEW,\nUri.parse(\"https://www.example.com\")\n)\nstartActivity(intent)\n</code></pre>"},{"location":"U03%20Android%20architecture/U03.1%20Android%20architecture%20copy/#intent-filters","title":"Intent Filters","text":"<p>An Intent Filter is a declaration in the AndroidManifest.xml file that specifies the types of intents an activity, service, or broadcast receiver can respond to. Intent filters allow components to be discovered and invoked by other applications based on the actions and data they can handle.</p> <p>For example, to declare an activity that can handle the \"VIEW\" action for web URLs, you would add the following intent filter to the activity in the AndroidManifest.xml file:</p> <pre><code>&lt;activity android:name=\".SecondActivity\"&gt;\n&lt;intent-filter&gt;\n&lt;action android:name=\"android.intent.action.VIEW\" /&gt;\n&lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;\n&lt;data android:scheme=\"http\" /&gt;\n&lt;data android:scheme=\"https\" /&gt;\n&lt;/intent-filter&gt;\n&lt;/activity&gt;\n</code></pre> <p>This intent filter specifies that <code>SecondActivity</code> can handle the \"VIEW\" action for both \"http\" and \"https\" schemes.</p>"},{"location":"U03%20Android%20architecture/U03.2%20The%20MVVM%20pattern/","title":"Unit 3.2 The MVVM design pattern","text":"<p>The Model-View-ViewModel (MVVM) is a software architectural pattern that facilitates the separation of the development of the graphical user interface (the view) from the business logic or back-end logic (the model) such that the view is not dependent on any specific model platform. This separation allows for easier management of complex applications, improved testability, and enhanced maintainability.</p> <p>In Android development, MVVM is commonly used in conjunction with Jetpack libraries such as LiveData, ViewModel, and Data Binding. Here's a brief overview of each component in the MVVM pattern:</p> <ol> <li>Model: The Model represents the data and business logic of the application. It is responsible for managing the data, whether it comes from a local database, a remote server, or any other source. The Model should be independent of the View and ViewModel, allowing for easy testing and modification.</li> <li>View: The View is the user interface of the application. It displays data to the user and captures user input. In Android, the View is typically represented by Activities, Fragments, or custom Views. The View should be as passive as possible, meaning it should not contain any business logic or data manipulation code.</li> <li>ViewModel: The ViewModel acts as a bridge between the Model and the View. It is responsible for preparing and managing the data for the View, handling user interactions, and updating the View when the data changes. The ViewModel should not reference the View directly, allowing for better separation of concerns and easier testing.</li> </ol> <p></p>"},{"location":"U03%20Android%20architecture/U03.2%20The%20MVVM%20pattern/#recommended-app-architecture","title":"Recommended app architecture","text":"<p>Each app should have at least two layers:</p> <ul> <li>UI layer: a layer that displays the app data on the screen but is independent of the data.</li> <li>Data layer: a layer that stores, retrieves, and exposes the app data.</li> </ul> <p>You can add another layer, called the domain layer, to simplify and reuse the interactions between the UI and data layers. This layer is optional, but recommended for complex apps.</p> <p></p>"},{"location":"U03%20Android%20architecture/U03.2%20The%20MVVM%20pattern/#ui-layer","title":"UI layer","text":"<p>The role of the UI layer, or presentation layer (the View in the MVVM pattern), is to display the application data on the screen. Whenever the data changes due to a user interaction, such as pressing a button, the UI should update to reflect the changes.</p> <p>The UI layer is made up of the following components:</p> <ul> <li>UI elements: components that render the data on the screen. You build these elements using Jetpack Compose.</li> <li>State holders: components that hold the data, expose it to the UI, and handle the app logic. An example state holder is ViewModel.</li> </ul> <p></p>"},{"location":"U03%20Android%20architecture/U03.2%20The%20MVVM%20pattern/#viewmodel","title":"ViewModel","text":"<p>The ViewModel component holds and exposes the state the UI consumes. The UI state is application data transformed by ViewModel. ViewModel lets your app follow the architecture principle of separating the UI from the model.</p> <p>ViewModel stores the app-related data that isn't destroyed when the activity is destroyed and recreated by the Android framework. Unlike the activity instance, ViewModel objects are not destroyed. The app automatically retains ViewModel objects during configuration changes so that the data they hold is immediately available after the recomposition.</p> <p>To implement ViewModel in your app, extend the ViewModel class, which comes from the architecture components library and stores app data within that class.</p> <pre><code>class MyViewModel : ViewModel() {\n// Your app data here\n}\n</code></pre> <p>To create an instance of your ViewModel class on your composable functions, use the <code>viewModel()</code> function from the <code>androidx.lifecycle.viewmodel.compose</code> package. This function creates a ViewModel the first time the system calls it and retains the same instance during recompositions.</p> <pre><code>@Composable\nfun MyScreen() {\nval myViewModel: MyViewModel = viewModel()\n// Use the ViewModel\n}\n</code></pre>"},{"location":"U03%20Android%20architecture/U03.2%20The%20MVVM%20pattern/#ui-state","title":"UI State","text":"<p>The UI is what the user sees, and the UI state is what the app says they should see. The UI is the visual representation of the UI state. Any changes to the UI state immediately are reflected in the UI.</p> <p>The UI state is usually a data class that holds all the data the UI needs to display. For example, in a weather app, the UI state might include the current temperature, humidity, and weather conditions.</p> <pre><code>data class WeatherUiState(\nval temperature: String,\nval humidity: String,\nval conditions: String\n)\n</code></pre> <p>The ViewModel exposes the UI state to the UI layer using observable data holders, such as StateFlow or LiveData. The UI layer observes these data holders and updates the UI whenever the UI state changes.</p> <pre><code>class WeatherViewModel : ViewModel() {\nprivate val _uiState = MutableStateFlow(WeatherUiState(\"\", \"\", \"\"))\nval uiState: StateFlow&lt;WeatherUiState&gt; = _uiState\n\nfun updateWeather(temperature: String, humidity: String, conditions: String) {\n_uiState.value = WeatherUiState(temperature, humidity, conditions)\n}\n}\n</code></pre> <p>The UI layer collects the UI state from the ViewModel and uses it to render the UI.</p> <pre><code>@Composable\nfun WeatherScreen(weatherViewModel: WeatherViewModel = viewModel()) {\nval uiState by weatherViewModel.uiState.collectAsState()\nWeatherContent(uiState)\n}\n\n@Composable\nfun WeatherContent(uiState: WeatherUiState) {\n// Render the UI using the uiState\n}\n</code></pre>"},{"location":"U03%20Android%20architecture/U03.2%20The%20MVVM%20pattern/#data-layer","title":"Data layer","text":"<p>The data layer is responsible for managing the app's data. It handles data storage, retrieval, and manipulation. The data layer can interact with various data sources, such as local databases, remote servers, or in-memory caches.</p> <p></p> <p>We will see the data layer in more detail in the next unit.</p>"},{"location":"U03%20Android%20architecture/U03.3%20ViewModel%20guided%20practice/","title":"Unit 3.3 ViewModel guided practice","text":"<p>In this guided practice, we will add a <code>ViewModel</code> to an existing Jetpack Compose application to manage its UI state.</p> <p></p> <p>We will use the Tip Time project you already know from previous units.</p> <p>Get the repository from GitHub and make sure you are in the main branch:</p> <pre><code>git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-tip-calculator.git\ncd basic-android-kotlin-compose-training-tip-calculator\ngit checkout main\n</code></pre>"},{"location":"U03%20Android%20architecture/U03.3%20ViewModel%20guided%20practice/#1-create-the-viewmodel","title":"1. Create the ViewModel","text":"<p>Create a new Kotlin file called <code>TipTimeViewModel.kt</code> in the <code>ui/viewmodels</code> package (create the package first).</p> <pre><code>// TipTimeViewModel.kt\n\nclass TipTimeViewModel : ViewModel() {\n}\n</code></pre>"},{"location":"U03%20Android%20architecture/U03.3%20ViewModel%20guided%20practice/#2-create-the-data-class","title":"2. Create the data class","text":"<p>Create a new Kotlin class called <code>TipTimeState.kt</code> in the <code>ui/viewmodels</code> package.</p> <p>in ui/viewmodels:</p> <pre><code>// TipTimeState.kt\n\ndata class TipTimeState (\nval amountInput: String = \"\",\nval tipInput: String = \"15\",\nval roundUp: Boolean = false,\nval tip: String = \"\" )\n</code></pre> <p>This data class holds the UI state for the Tip Time app, including the input amount, tip percentage, round-up option, and calculated tip amount.</p>"},{"location":"U03%20Android%20architecture/U03.3%20ViewModel%20guided%20practice/#3-stateflow","title":"3. StateFlow","text":"<p>StateFlow is a data holder observable flow that emits the current and new state updates. Its value property reflects the current state value.</p> <p>To update state and send it to the flow, assign a new value to the value property of the MutableStateFlow class.</p> <pre><code>// TipTimeViewModel.kt\n\nclass TipTimeViewModel : ViewModel() {\nprivate val _uiState = MutableStateFlow(TipTimeState())\nval uiState : StateFlow&lt;TipTimeState&gt; = _uiState.asStateFlow()\n}\n</code></pre> <p>The <code>asStateFlow()</code> makes this mutable state flow a read-only state flow.</p> <p><code>_uiState</code> is a backing property for the public read-only property <code>uiState</code>.</p> <p>Info</p> <p>A backing property lets you return something from a getter other than the exact object.</p> <p>For var properties, the Kotlin framework generates getters and setters.</p> <p>For getter and setter methods, you can override one or both of these methods and provide your own custom behavior. To implement a backing property, you override the getter method to return a read-only version of your data.</p>"},{"location":"U03%20Android%20architecture/U03.3%20ViewModel%20guided%20practice/#4-pass-the-logic-to-the-viewmodel","title":"4. Pass the logic to the viewmodel","text":"<p>Refactor the <code>calculateTip</code> function: move it to the <code>ViewModel</code> file. Put inside the function the calculated variables from the <code>TipTimeLayout()</code>: <code>amount</code>, <code>tipPercent</code> and <code>roundUp</code>.</p> <pre><code>// TipTimeViewModel.kt\n\nclass TipTimeViewModel : ViewModel() {\n...\n\nprivate fun calculateTip(): Unit {\n// Get the current values from the sate\nval amount = _uiState.value.amountInput.toDoubleOrNull() ?: 0.0\nval tipPercent = _uiState.value.tipInput.toDoubleOrNull() ?: 15.0\nval roundUp = _uiState.value.roundUp\n\nvar tip = tipPercent / 100 * amount\nif (roundUp) {\ntip = ceil(tip)\n}\n\nval formattedTip = NumberFormat.getCurrencyInstance().format(tip)\n\n// Update the state with the calculated tip\n_uiState.update { currentState -&gt;\ncurrentState.copy(tip = formattedTip)\n}\n}\n\n}\n</code></pre> <p>The <code>_uiState.update</code> function updates the current state with the new calculated tip, making a copy of the previous state and modifying only the tip property.</p> <p>The next step is to create functions to update the state from the UI.</p> <pre><code>// TipTimeViewModel.kt\n\nclass TipTimeViewModel : ViewModel() {\n...\n\nfun updateAmountInput(newAmount: String) {\n_uiState.update { currentState -&gt;\ncurrentState.copy(amountInput = newAmount)\n}\ncalculateTip() // Recalculate the tip each time the amount changes\n}\n\nfun updateTipInput(newTipPercent: String) {\n_uiState.update { currentState -&gt;\ncurrentState.copy(tipInput = newTipPercent)\n}\ncalculateTip() // Recalculate the tip each time the amount changes\n}\n\nfun updateRoundUp(shouldRoundUp: Boolean) {\n_uiState.update { currentState -&gt;\ncurrentState.copy(roundUp = shouldRoundUp)\n}\ncalculateTip() // Recalculate the tip each time the amount changes\n}\n\n...\n\n}\n</code></pre>"},{"location":"U03%20Android%20architecture/U03.3%20ViewModel%20guided%20practice/#5-pass-the-data-to-the-ui","title":"5. Pass the data to the ui","text":"<p>Now, we need to modify the UI layer to use the ViewModel.</p> <p>Pass the ViewModel instance to the UI, from the <code>TipTimeViewModel</code> to the <code>TipTimeLayout()</code> in the <code>MainActivity.kt</code> file. In the <code>TipTimeLayout()</code>, use the <code>ViewModel</code> instance to access the <code>uiState</code> using <code>collectAsState()</code>.</p> <pre><code>// MainActivity.kt\n\nfun TipTimeLayout(\ntipTimeViewModel: TipTimeViewModel = viewModel()\n) {\nval tipTimeUiState by tipTimeViewModel.uiState.collectAsState()\n...\n</code></pre> <p>To use this the <code>viewModel()</code> function, you must include the necessary dependency in your build.gradle.kts (or build.gradle) app file:</p> <pre><code>// build.gradle.kts\ndependencies {\n...\nimplementation \"androidx.lifecycle:lifecycle-viewmodel-compose:2.9.4\"\n...\n}\n</code></pre> <p>Update the EditFields, Text and Switch to use the ViewModel instance:</p> <pre><code>// TipTimeLayout.kt\n\nfun TipTimeLayout(\ntipTimeViewModel: TipTimeViewModel = viewModel() //ViewModel injection\n) {\n...\nEditNumberField(\n// Other options\nvalue = tipTimeUiState.amountInput , onValueChanged = { tipTimeViewModel.updateAmountInput(it) },\n)\n\nEditNumberField(\n// Other options\nvalue = tipTimeUiState.tipInput, onValueChanged = { tipTimeViewModel.updateTipInput(it) },\n)\n\nRoundTheTipRow(\nroundUp = tipTimeUiState.roundUp, onRoundUpChanged = { tipTimeViewModel.updateRoundUp(it) },\n// Other options\n)\n\nText(\ntext = stringResource(R.string.tip_amount, tipTimeUiState.tip), // Other options\n)\n}\n</code></pre> <p><code>tipTimeViewModel</code> and <code>tipTimeUiState</code> are the only objects we need to save and retrieve the state. Delete all the other variables related to state in the <code>TipTimeLayout()</code> function.</p> <p>That's all! Check the behavior of the app. It should work as before, but now the logic is separated from the UI.</p> <p>Check also rotations and configuration changes. The data should persist.</p>"},{"location":"U03%20Android%20architecture/U03.3%20ViewModel%20guided%20practice/#6-uml-diagrams-and-source-code","title":"6. UML diagrams and source code","text":""},{"location":"U03%20Android%20architecture/U03.3%20ViewModel%20guided%20practice/#class-diagram","title":"Class diagram","text":"<pre><code>classDiagram\n    class MainActivity {\n        +onCreate(Bundle)\n    }\n\n    class TipTimeLayout {\n        +TipTimeLayout(TipTimeViewModel)\n    }\n\n    class TipTimeViewModel {\n        +uiState: StateFlow&lt;TipTimeState&gt;\n        +updateAmountInput(String)\n        +updateTipInput(String)\n        +updateRoundUp(Boolean)\n        -calculateTip()\n    }\n\n    class TipTimeState {\n        +amountInput: String\n        +tipInput: String\n        +roundUp: Boolean\n        +tip: String\n    }\n\n    MainActivity --&gt; TipTimeLayout : creates\n    TipTimeLayout ..&gt; TipTimeViewModel : updates\n    TipTimeLayout ..&gt; TipTimeState : observes\n    TipTimeViewModel --&gt; TipTimeState : holds and updates</code></pre>"},{"location":"U03%20Android%20architecture/U03.3%20ViewModel%20guided%20practice/#sequence-diagram","title":"Sequence diagram","text":"<pre><code>sequenceDiagram\n    participant TextField as \"TextField (UI)\"\n    participant TipTimeViewModel as \"ViewModel\"\n    participant TipTimeState as \"Data Model\"\n    Note over TextField: User enters text\n    TextField-&gt;&gt;TipTimeViewModel: onValueChanged(text)\n    TipTimeViewModel-&gt;&gt;TipTimeViewModel: updateAmountInput(text)\n    TipTimeViewModel-&gt;&gt;TipTimeState: copy(...) with new value\n    TipTimeState--&gt;&gt;TipTimeViewModel: returns a new state object\n    Note over TipTimeViewModel: updates its internal StateFlow\n    TipTimeViewModel--&gt;&gt;TextField: recomposes with the new value</code></pre>"},{"location":"U03%20Android%20architecture/U03.3%20ViewModel%20guided%20practice/#source-code","title":"Source code","text":"<p>Tip Time with ViewModel on GitHub</p>"},{"location":"U03%20Android%20architecture/U03.4%20Navigation/","title":"Unit 3.4 Android Navigation","text":"<p>Navigation refers to the interactions that let users navigate across, into, and back out from the different pieces of content within your app.</p>"},{"location":"U03%20Android%20architecture/U03.4%20Navigation/#key-concepts","title":"Key concepts","text":"Concept Purpose Type Host A UI element that contains the current navigation destination. That is, when a user navigates through an app, the app essentially swaps destinations in and out of the navigation host. <code>NavHost</code> Graph A data structure that defines all the navigation destinations within the app and how they connect together. <code>NavGraph</code> Controller The central coordinator for managing navigation between destinations. The controller offers methods for navigating between destinations, handling deep links, managing the back stack, and more. <code>NavController</code> Destination A node in the navigation graph. When the user navigates to this node, the host displays its content. <code>NavDestination</code>Typically created when constructing the navigation graph. Route Uniquely identifies a destination and any data required by it.You can navigate using routes. Routes take you to destinations. Any serializable data type."},{"location":"U03%20Android%20architecture/U03.4%20Navigation/#set-up-the-environment","title":"Set up the environment","text":"<p>To include navigation support in your project, add the following dependencies to your app's build.gradle file:</p> <pre><code>plugins {\n// Kotlin serialization plugin for type safe routes and navigation arguments\nkotlin(\"plugin.serialization\") version \"2.0.21\"\n}\n\ndependencies {\nval nav_version = \"2.9.5\"\n\n// Jetpack Compose integration\nimplementation(\"androidx.navigation:navigation-compose:$nav_version\")\n\n// Views/Fragments integration\nimplementation(\"androidx.navigation:navigation-fragment:$nav_version\")\nimplementation(\"androidx.navigation:navigation-ui:$nav_version\")\n\n// Feature module support for Fragments\nimplementation(\"androidx.navigation:navigation-dynamic-features-fragment:$nav_version\")\n\n// Testing Navigation\nandroidTestImplementation(\"androidx.navigation:navigation-testing:$nav_version\")\n\n// JSON serialization library, works with the Kotlin serialization plugin\nimplementation(\"org.jetbrains.kotlinx:kotlinx-serialization-json:1.7.3\")\n}\n</code></pre>"},{"location":"U03%20Android%20architecture/U03.4%20Navigation/#create-a-navigation-controller","title":"Create a navigation controller","text":"<p>A <code>NavController</code> is the central component of the Navigation Architecture Component. It manages app navigation within a <code>NavHost</code>.</p> <p>When using the navigation component with Jetpack Compose, you can create a <code>NavController</code> by calling the <code>rememberNavController()</code> function. This function creates and remembers a <code>NavController</code> instance that you can use to navigate between composables.</p> <pre><code>val navController: NavHostController = rememberNavController()\n</code></pre>"},{"location":"U03%20Android%20architecture/U03.4%20Navigation/#create-a-navigation-host","title":"Create a navigation host","text":"<p>Once you have a <code>NavController</code>, you can create a <code>NavHost</code> to host your composables and manage navigation between them. The <code>NavHost</code> is responsible for displaying the current destination and handling navigation actions.</p> <p>Place your NavHost inside a composable function, typically within your app's main screen or activity.</p> <pre><code>Scaffold {\nval navController: NavHostController = rememberNavController()\n\nNavHost(\nnavController = navController,\nstartDestination = \"home\"\n) {\ncomposable(\"home\") { HomeScreen(navController) }\ncomposable(\"details\") { DetailsScreen(navController) }\n}\n}\n</code></pre> <p>In this example, the <code>NavHost</code> is set up with two destinations: \"home\" and \"details\". The <code>startDestination</code> parameter specifies the initial screen to display when the app starts.</p>"},{"location":"U03%20Android%20architecture/U03.4%20Navigation/#navigate-between-destinations","title":"Navigate between destinations","text":"<p>To navigate between destinations, you can use the <code>navigate()</code> method of the <code>NavController</code>. You can call this method from within your composable functions, typically in response to user actions such as button clicks.</p> <pre><code>@Composable\nfun HomeScreen(navController: NavHostController) {\nButton(onClick = {\nnavController.navigate(\"details\")\n}) {\nText(\"Go to Details\")\n}\n}\n</code></pre> <p>You also can navigate to the previous destination using the <code>navigateUp()</code> method:</p> <pre><code>@Composable\nfun DetailsScreen(navController: NavHostController) {\nButton(onClick = {\nnavController.navigateUp()\n}) {\nText(\"Back\")\n}\n}\n</code></pre>"},{"location":"U03%20Android%20architecture/U03.4%20Navigation/#routes","title":"Routes","text":"<p>A route is a string that uniquely identifies a destination in the navigation graph. You can define routes with enum classes for better type safety and organization.</p> <pre><code>enum class AppDestinations(val route: String) {\nHOME(\"home\"),\nDETAILS(\"details\")\n}\n...\nNavHost(\nnavController = navController,\nstartDestination = AppDestinations.HOME.route\n) {\ncomposable(AppDestinations.HOME.route) { HomeScreen(navController) }\ncomposable(AppDestinations.DETAILS.route) { DetailsScreen(navController) }\n}\n</code></pre>"},{"location":"U03%20Android%20architecture/U03.4%20Navigation/#summary","title":"Summary","text":"<p>In this unit, you have learned the basics of Android Navigation using Jetpack Compose. You have seen how to set up a navigation controller, create a navigation host, define destinations, and navigate between them using routes. With this knowledge, you can build more complex navigation flows in your Android applications.</p>"},{"location":"U03%20Android%20architecture/U03.5%20Navigation%20guided%20practice/","title":"Unit 3.5 Android Navigation Guided Practice","text":"<p>In this guided practice, we will add navigation to the TipTime application using the Jetpack Navigation component. We will add one more screen and a top bar with navigation capabilities.</p>"},{"location":"U03%20Android%20architecture/U03.5%20Navigation%20guided%20practice/#parts-of-the-navigation-component","title":"Parts of the Navigation Component","text":"<p>The Navigation component has three main parts:</p> <ul> <li>NavController: Responsible for navigating between destinations\u2014that is, the screens in your app.</li> <li>NavGraph: Maps composable destinations to navigate to.</li> <li>NavHost: Composable acting as a container for displaying the current destination of the NavGraph.</li> </ul> <p>In this guided practice, you'll focus on the NavController and the NavHost. Within the NavHost, you'll define the destinations for the TipTime app's NavGraph.</p>"},{"location":"U03%20Android%20architecture/U03.5%20Navigation%20guided%20practice/#1-create-the-tiptimeresult-and-start-layouts","title":"1. Create the TipTimeResult and Start layouts","text":"<p>Move the <code>Column</code> from inside the <code>TipTimeLayout</code> composable to its own composable function called <code>TipTimeStartScreen</code>. Add parameters for the <code>tipTimeViewModel</code> and <code>modifier</code>.</p> <pre><code>// TipTimeStartScreen.kt\n\n@Composable\nfun TipTimeStartScreen(\nmodifier: Modifier = Modifier,\ntipTimeViewModel: TipTimeViewModel = viewModel(),\n) {\nval tipTimeUiState by tipTimeViewModel.uiState.collectAsState()\n\nColumn(\n... // Existing content\n</code></pre> <p>Note how we pass the <code>tipTimeViewModel</code> as a parameter. The <code>uiState</code> is collected from the ViewModel as before.</p> <p>Create a new Kotlin file called <code>TipTimeResultScreen.kt</code> in the <code>ui</code> package.</p> <pre><code>// TipTimeResultScreen.kt\n\n@Composable\nfun TipTimeResultScreen(\nmodifier: Modifier = Modifier,\ntipTimeViewModel: TipTimeViewModel = viewModel(),\n) {\nval tipTimeUiState by tipTimeViewModel.uiState.collectAsState()\n\nColumn(\nmodifier = modifier\n.statusBarsPadding()\n.verticalScroll(rememberScrollState())\n.safeDrawingPadding(),\nhorizontalAlignment = Alignment.Companion.CenterHorizontally,\nverticalArrangement = Arrangement.Center\n) {\nText(\ntext = stringResource(R.string.tip_amount, tipTimeUiState.tip),\nstyle = MaterialTheme.typography.titleLarge,\n)\nText(\ntext = stringResource(R.string.total, tipTimeUiState.total),\nstyle = MaterialTheme.typography.titleLarge,\n)\n}\n}\n</code></pre>"},{"location":"U03%20Android%20architecture/U03.5%20Navigation%20guided%20practice/#2-defining-routes","title":"2. Defining routes","text":"<p>In the TipTime app, you will have the following routes:</p> <ul> <li>Start: The main screen where users can enter their tip amount and select a tip percentage.</li> <li>TipResult: The screen that displays the calculated tip amount and total bill.</li> </ul> <p>A route is a string that uniquely identifies a destination in the navigation graph. You can define routes as constants in a separate file for better organization.</p> <p>Create a new Kotlin file called <code>Routes.kt</code> in the <code>ui</code> package.</p> <pre><code>// Routes.kt\n\n...\nimport com.example.tiptime.R\n\nenum class Routes(@StringRes val title: Int) {\nStart (title = R.string.app_name),\nTipResult (title = R.string.tip_result)\n}\n</code></pre> <p>In this class we define an enum class <code>Routes</code> with two routes: <code>Start</code> and <code>TipResult</code>. Each route has an associated string resource for the title.</p>"},{"location":"U03%20Android%20architecture/U03.5%20Navigation%20guided%20practice/#3-add-a-navhost","title":"3. Add a NavHost","text":"<p>A NavHost is a composable that displays other composable destination, based on a given route. For example, if the current route is <code>TipResult</code>, the NavHost will display the <code>TipResultScreen</code> composable.</p> <p>The syntax for a NavHost is as follows:</p> <pre><code>NavHost(\nnavController: NavController,\nstartDestination: String,\nmodifier: Modifier = Modifier,\n) {\n// Content\n}\n</code></pre> <p>There are two important parameters.</p> <ul> <li>navController: An instance of the <code>NavHostController</code> class. You can use this object to navigate between screens, for example, by calling the <code>navigate()</code> method to navigate to another destination. You can obtain the <code>NavHostController</code> by calling <code>rememberNavController()</code> from a composable function.</li> <li>startDestination: A string route defining the destination shown by default when the app first displays the NavHost. In the case of the TipTime app, this should be the Start route.</li> </ul> <p>Like other composables, NavHost also takes a modifier parameter.</p> <p>Inside the TipTimeLayout composable, add the NavHost as follows (if you don't have a Scaffold yet, add it now):</p> <pre><code>// TipTimeLayout.kt\n\n...\nimport androidx.navigation.NavHostController\nimport androidx.navigation.compose.NavHost\nimport androidx.navigation.compose.rememberNavController\n...\n\n@Composable\nfun TipTimeLayout(\ntipTimeViewModel: TipTimeViewModel = viewModel(),\nnavController: NavHostController = rememberNavController()\n) {\nScaffold() { innerPadding -&gt;\nval tipTimeUiState by tipTimeViewModel.uiState.collectAsState()\n\nNavHost(\nnavController = navController,\nstartDestination = Routes.Start.name,\nmodifier = Modifier.padding(innerPadding)\n) {\n\n}\n...\n</code></pre> <p>Before adding the destinations, ensure you have the necessary dependencies for navigation in your <code>build.gradle.kts</code> (or <code>build.gradle</code>) app file:</p> <pre><code>// build.gradle.kts\ndependencies {\n...\nimplementation \"androidx.navigation:navigation-compose:2.9.4\"\n...\n}\n</code></pre>"},{"location":"U03%20Android%20architecture/U03.5%20Navigation%20guided%20practice/#4-add-destinations-to-the-navhost","title":"4. Add destinations to the NavHost","text":"<p>Inside the NavHost block, add the composable destinations for the Start and Result screens, adding a <code>composable()</code> function.</p> <p>The composable function has two required parameters:</p> <ol> <li>route: A string that uniquely identifies the name of the destination. You'll use the name of the enum values defined in the <code>Routes</code> enum class.</li> <li>content: A composable function that defines the UI for the destination.</li> </ol> <pre><code>// TipTimeLayout.kt\n\nNavHost(\nnavController = navController,\nstartDestination = Routes.Start.name,\nmodifier = Modifier.padding(innerPadding)\n) {\ncomposable( route = Routes.Start.name) {\nTipTimeStartScreen(\ntipTimeViewModel = tipTimeViewModel,\nmodifier = Modifier\n.fillMaxSize()\n.padding(40.dp)\n)\n\n}\ncomposable(route = Routes.TipResult.name) {\nTipTimeResultScreen(\ntipTimeViewModel = tipTimeViewModel,\nmodifier = Modifier\n.fillMaxSize()\n.padding(40.dp)\n)\n}\n}\n...\n</code></pre> <p>Run the app on the emulator or a physical device to ensure everything is working correctly. You should see the Start screen of the TipTime app.</p>"},{"location":"U03%20Android%20architecture/U03.5%20Navigation%20guided%20practice/#5-navigate-between-destinations","title":"5. Navigate between destinations","text":"<p>We will add 2 buttons to our app that will allow us to navigate from the Start to the Result screen and back.</p> <p>Add a button to the <code>TipTimeStartScreen</code> composable that navigates to the Result screen when clicked. It needs a lambda which will be called when the button is clicked.</p> <pre><code>// TipTimeStartScreen.kt\n\n@Composable\nfun TipTimeStartScreen(\nonNextButtonClicked: () -&gt; Unit, //ADD THIS\nmodifier: Modifier = Modifier,\ntipTimeViewModel: TipTimeViewModel = viewModel(),\n) {\nval tipTimeUiState by tipTimeViewModel.uiState.collectAsState()\n\nColumn(\n// Existing content\n) {\n// Existing content\nSpacer(modifier = Modifier.height(30.dp))\nButton(\nonClick = onNextButtonClicked,\n) {\nText(stringResource(R.string.next))\n}\n\n}\n</code></pre> <p>The <code>onNextButtonClicked</code> parameter is the lambda function that will be called when the button is clicked.</p> <p>Do the same on the <code>TipTimeResultScreen</code> composable to navigate back to the Start screen.</p> <pre><code>// TipTimeResultScreen.kt\n\n@Composable\nfun TipTimeResultScreen(\nonBackButtonClicked: () -&gt; Unit, //ADD THIS\nmodifier: Modifier = Modifier,\ntipTimeViewModel: TipTimeViewModel = viewModel(),\n) {\nval tipTimeUiState by tipTimeViewModel.uiState.collectAsState()\n\nColumn(\n// Existing content\n) {\n// Existing content\nSpacer(modifier = Modifier.height(30.dp))\nButton(\nonClick = onBackButtonClicked,\n) {\nText(stringResource(R.string.back))\n}\n}\n}\n</code></pre> <p>Now, go back to the <code>TipTimeLayout</code> composable and pass the navigation actions to the <code>TipTimeStartScreen</code> and <code>TipTimeResultScreen</code> composables.</p> <pre><code>// TipTimeLayout.kt\n\n...kotlin\nNavHost(\nnavController = navController,\nstartDestination = Routes.Start.name,\nmodifier = Modifier.padding(innerPadding)\n) {\ncomposable( route = Routes.Start.name) {\nTipTimeStartScreen(\ntipTimeViewModel = tipTimeViewModel,\nonNextButtonClicked = { navController.navigate(Routes.TipResult.name) }, //ADD THIS\nmodifier = Modifier\n.fillMaxSize()\n.padding(40.dp)\n)\n}\ncomposable(route = Routes.TipResult.name) {\nTipTimeResultScreen(\ntipTimeViewModel = tipTimeViewModel,\nonBackButtonClicked = { navController.navigate(Routes.Start.name) }, //ADD THIS\nmodifier = Modifier\n.fillMaxSize()\n.padding(40.dp)\n)\n}\n}\n</code></pre> <p>The <code>onNextButtonClicked</code> lambda navigates to the <code>TipResult</code> route when the button is clicked, and the <code>onBackButtonClicked</code> lambda navigates back to the <code>Start</code> route.</p> <p>Run your app again. You should be able to navigate between the Start and Result screens using the buttons.</p>"},{"location":"U03%20Android%20architecture/U03.5%20Navigation%20guided%20practice/#6-add-a-topappbar-with-navigation-support","title":"6. Add a TopAppBar with navigation support","text":"<p>First, create a new composable function called <code>TipTimeTopBar</code> in the <code>TipTimeLayout.kt</code> file (create it in a separate file if you want).</p> <pre><code>@Composable\nfun TipTimeTopBar(\ncurrentScreen: Routes,\ncanNavigateBack: Boolean,\nmodifier: Modifier = Modifier,\nnavigateUp: () -&gt; Unit = {},\n) {\n\n}\n</code></pre> <p>The parameters are as follows:</p> <ul> <li>currentScreen: The current screen being displayed. This is used to set the title of the top bar.</li> <li>canNavigateBack: A boolean indicating whether the user can navigate back from the current screen. This is used to determine whether to show the back button.</li> <li>navigateUp: A lambda function that is called when the back button is clicked.</li> </ul> <p>In the body of the <code>TipTimeTopBar</code> function, add a <code>TopAppBar</code> composable.</p> <pre><code>fun TipTimeTopBar(\n// existing parameters\n) {\nTopAppBar(\ntitle = { Text(stringResource(currentScreen.title)) },\ncolors = TopAppBarDefaults.topAppBarColors(\ncontainerColor = MaterialTheme.colorScheme.primaryContainer,\n),\nmodifier = modifier,\nnavigationIcon = {\nif (canNavigateBack) {\nIconButton(onClick = navigateUp) {\nIcon(\nimageVector = Icons.AutoMirrored.Filled.ArrowBack,\ncontentDescription = stringResource(R.string.back)\n)\n}\n}\n}\n)\n}\n</code></pre> <p>The <code>title</code> will display the title of the current screen, stored in the <code>Routes</code> enum class. If <code>canNavigateBack</code> is true, a back button will be displayed that calls the <code>navigateUp</code> lambda when clicked.</p> <p>To use the icons remember to include the required dependency in your <code>build.gradle.kts</code> (or <code>build.gradle</code>) app file:</p> <pre><code>// build.gradle.kts\ndependencies {\n...\nimplementation(\"androidx.compose.material:material-icons-extended-android:1.6.8\")\n...\n</code></pre> <p>And, in the <code>TipTimeLayout</code> composable:</p> <pre><code>import androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.automirrored.filled.ArrowBack\n</code></pre> <p>The Up button should only show if there's a composable on the back stack. If the app has no screens on the back stack (we are at the Start screen) then the Up button should not be shown. To check this, you need a reference to the back stack. For that, you can use the <code>currentBackStackEntryAsState()</code> extension function of <code>NavController</code>.</p> <pre><code>// TipTimeLayout.kt\n\nimport androidx.navigation.compose.currentBackStackEntryAsState\n\n@Composable\nfun TipTimeLayout(\ntipTimeViewModel: TipTimeViewModel = viewModel(),\nnavController: NavHostController = rememberNavController()\n) {\n// Get current back stack entry\nval backStackEntry by navController.currentBackStackEntryAsState()\n// Get the name of the current screen\nval currentScreen = Routes.valueOf(\nbackStackEntry?.destination?.route ?: Routes.Start.name\n)\n...\n</code></pre> <p><code>currentScreen</code> is equal to the result of calling the <code>valueOf()</code> class function of <code>Routes</code>. The route of the destination is the indicated by <code>backStackEntry</code>, or the default value of <code>Routes.Start.name</code>.</p> <p>Now, we can pass the value of <code>currentScreen</code> to the <code>TipTimeTopBar</code> composable. For the <code>canNavigateBack</code> parameter, pass in a boolean expression checking if the <code>previousBackStackEntry</code> property of <code>navController</code> is not equal to <code>null</code>. Finally, to navigate back to the previous screen, call the <code>navigateUp()</code> method of <code>navController</code>:</p> <pre><code>// TipTimeLayout.kt\n\nScaffold(\ntopBar = {\nTipTimeTopBar(\ncurrentScreen = currentScreen,\ncanNavigateBack = navController.previousBackStackEntry != null,\nnavigateUp = { navController.navigateUp() },\n)\n...\n</code></pre> <p>Check the app again. You should see the TopAppBar with the title of the current screen. When you navigate to the Result screen, the back button should appear, allowing you to navigate back to the Start screen.</p>"},{"location":"U03%20Android%20architecture/U03.5%20Navigation%20guided%20practice/#7-add-a-share-button","title":"7. Add a share button","text":"<p>We want to add a share button to the TopAppBar on the Result screen. This button will allow users to share the tip amount and total bill using other apps on their device.</p> <p>To do that, we must first create an intent to share the text. The intent type that we need is <code>ACTION_SEND</code> with MIME type <code>\"text/plain\"</code>.</p> <p>In <code>TipTimeLayout.kt</code>, create a private function called <code>createShareIntent</code> that takes the tip and total values as parameters and returns an <code>Intent</code>:</p> <pre><code>// TipTimeLayout.kt\n\nimport android.content.Intent\n\nprivate fun createShareIntent(context: Context, tip: String, total: String) {\nval shareText = context.getString(R.string.tip_amount_total_bill, tip, total)\n// Create an ACTION_SEND implicit intent with order details in the intent extras\nval intent = Intent(Intent.ACTION_SEND).apply {\ntype = \"text/plain\"\nputExtra(Intent.EXTRA_SUBJECT, context.getString(R.string.your_tip))\nputExtra(Intent.EXTRA_TEXT, shareText)\n}\ncontext.startActivity(\nIntent.createChooser(\nintent,\ncontext.getString(R.string.your_tip)\n)\n)\n}\n</code></pre> <p>Context</p> <p>The Context in Android is an interface to global information about an application environment. It allows access to application-specific resources and classes, as well as up-calls for application-level operations such as launching activities, broadcasting, and receiving intents, etc.</p> <p>Don't forget to create the string resources:</p> <pre><code>// res/values/strings.xml\n...\n&lt;string name=\"tip_amount_total_bill\"&gt;Tip Amount: %s\\nTotal Bill: %s&lt;/string&gt;\n&lt;string name=\"your_tip\"&gt;Your tip&lt;/string&gt;\n&lt;string name=\"share\"&gt;Share&lt;/string&gt;\n...\n</code></pre> <p>We need 2 more parameters in the <code>TipTimeTopBar</code> composable (<code>showShare</code> and <code>onShareClicked</code>), along with an <code>actions</code> parameter:</p> <pre><code>// AppBar.kt\n\n@Composable\nfun TipTimeTopBar(\n// Existing parameters\nshowShare: Boolean = false,\nonShareClicked: () -&gt; Unit = {},\n) {\nTopAppBar(\n// Existing parameters\nactions = {\nif (showShare) {\nIconButton(onClick = onShareClicked) {\nIcon(\nimageVector = Icons.Filled.Share,\ncontentDescription = stringResource(R.string.share)\n)\n}\n}\n}\n)\n}\n</code></pre> <p>The <code>actions</code> content is displayed at the end of the top app bar. This should typically be <code>IconButtons</code>. The default layout here is a Row, so icons inside will be placed horizontally.</p> <p>The last step is to call pass the new parameter values to the <code>TipTimeTopBar</code> from the Scaffold topBar:</p> <pre><code>// TipTimeLayout.kt\n\n...\nScaffold(\ntopBar = {\nTipTimeTopBar(\n// existing parameters\nshowShare = currentScreen == Routes.TipResult,\nonShareClicked = { createShareIntent(context, tip = uiState.tip, total = uiState.total) }\n)\n...\n</code></pre> <p>The <code>showShare</code> boolean is true only when the current screen is the <code>TipResult</code> screen. The <code>onShareClicked</code> lambda calls the <code>createShareIntent</code> function with the tip and total values from the <code>uiState</code>.</p> <p>This should work. Launch your app and check if the share button appears on the Result screen. When clicked, it should open a chooser dialog with available apps to share the tip amount and total bill.</p>"},{"location":"U03%20Android%20architecture/U03.5%20Navigation%20guided%20practice/#source-code","title":"Source code","text":"<p>You can find the complete source code for this guided practice on GitHub: TipTime with Navigation, branch <code>navigation</code>.</p>"},{"location":"U04%20Persistence%20with%20Room/U04.1%20Persistence%20with%20Room/","title":"Unit 4.1. Android persistence with Room","text":"<p>Room is a persistence library that provides an abstraction layer over SQLite to allow fluent database access while harnessing the full power of SQLite. It simplifies the database interactions and provides compile-time checks of SQL queries, reducing the likelihood of runtime errors.</p>"},{"location":"U04%20Persistence%20with%20Room/U04.1%20Persistence%20with%20Room/#sqlite","title":"SQLite","text":"<p>SQLite is a lightweight, embedded relational database management system (RDBMS) that is widely used in mobile applications, including Android. It is a serverless database engine that stores data in a single file on the device's file system. SQLite supports standard SQL syntax and provides features such as transactions, indexing, and data types.</p> <p>SQLite is similar to other relational database management systems, but it has some differences in the types of data.</p> <p>In the next table you can see the mapping between SQLite data types and Java/Kotlin data types:</p> SQLite Data Type Kotlin Data Type INTEGER Int, Long REAL Float, Double TEXT String INTEGER (0 or 1) Boolean BLOB Byte[] NULL null <p>The tipical SQL operations are similar to other RDBMS.</p> <pre><code>-- Insert a new record\nINSERT INTO users (name, age) VALUES ('John Doe', 30);\n\n-- Query records\nSELECT * FROM users ORDER BY name LIMIT 10;\nSELECT * FROM users WHERE id = 12;\n\n-- Update a record\nUPDATE users SET age = 31 WHERE name = 'John Doe';\n\n-- Delete a record\nDELETE FROM users WHERE name = 'John Doe';\n</code></pre>"},{"location":"U04%20Persistence%20with%20Room/U04.1%20Persistence%20with%20Room/#the-data-layer","title":"The data layer","text":"<p>The data layer is responsible for managing the app's data, including storing, retrieving, and updating data. In Android, the data layer can be implemented using various technologies, such as SQLite, Room, SharedPreferences, or network APIs.</p> <p></p> <p>In this unit, we will focus on using Room as the data layer for Android applications.</p>"},{"location":"U04%20Persistence%20with%20Room/U04.1%20Persistence%20with%20Room/#room-components","title":"Room components","text":"<p>Room is an ORM (Object Relational Mapping) library that provides an abstraction layer over SQLite. It simplifies database access and provides compile-time checks for SQL queries.</p> <p>Room consists of three main components: Entity, DAO (Data Access Object), and Database.</p> <p></p>"},{"location":"U04%20Persistence%20with%20Room/U04.1%20Persistence%20with%20Room/#declaring-room-dependencies","title":"Declaring Room dependencies","text":"<p>To use Room in your Android project, you need to add the following dependencies to your <code>build.gradle</code> file:</p> <pre><code>dependencies {\nval room_version = \"2.8.3\"\n\nimplementation(\"androidx.room:room-runtime:$room_version\")\n\n// If this project uses any Kotlin source, use Kotlin Symbol Processing (KSP)\n// See Add the KSP plugin to your project\nksp(\"androidx.room:room-compiler:$room_version\")\n\n// If this project only uses Java source, use the Java annotationProcessor\n// No additional plugins are necessary\nannotationProcessor(\"androidx.room:room-compiler:$room_version\")\n\n// optional - Kotlin Extensions and Coroutines support for Room\nimplementation(\"androidx.room:room-ktx:$room_version\")\n\n// optional - RxJava2 support for Room\nimplementation(\"androidx.room:room-rxjava2:$room_version\")\n\n// optional - RxJava3 support for Room\nimplementation(\"androidx.room:room-rxjava3:$room_version\")\n\n// optional - Guava support for Room, including Optional and ListenableFuture\nimplementation(\"androidx.room:room-guava:$room_version\")\n\n// optional - Test helpers\ntestImplementation(\"androidx.room:room-testing:$room_version\")\n\n// optional - Paging 3 Integration\nimplementation(\"androidx.room:room-paging:$room_version\")\n}\n</code></pre> <p>For adding KSP to your project, include the following in your top-level <code>build.gradle</code> file:</p> <pre><code>plugins {\n//Previously declared plugins\nid(\"com.google.devtools.ksp\") version \"2.0.21-1.0.27\" apply false\n}\n</code></pre> <p>Then, enable KSP in your app-level <code>build.gradle.kts</code> file:</p> <pre><code>//Previously declared plugins\nplugins {\nid(\"com.google.devtools.ksp\")\n}\n</code></pre> <p>Info</p> <p>KSP (Kotlin Symbol Processing) is a powerful tool for generating code at compile time. It is specifically designed for Kotlin and provides better performance and integration with Kotlin features compared to traditional annotation processors. Room uses KSP to generate the necessary code for database operations based on the annotations you provide in your Entity and DAO classes.</p> <p>More about Room</p>"},{"location":"U04%20Persistence%20with%20Room/U04.1%20Persistence%20with%20Room/#entity","title":"Entity","text":"<p>An Entity represents a table in the database. It is defined using a Kotlin data class annotated with <code>@Entity</code>. Each property of the data class corresponds to a column in the table.</p> <pre><code>import androidx.room.Entity\nimport androidx.room.PrimaryKey\n\n@Entity(tableName = \"users\")\ndata class User(\n@PrimaryKey(autoGenerate = true)\nval id: Int = 0,\nval name: String,\nval age: Int\n)\n</code></pre> <p>Another annotations that we can use in an Entity are:</p> <ul> <li><code>@ColumnInfo</code>: Specifies the column name in the database.</li> <li><code>@Ignore</code>: Excludes a property from being persisted in the database.</li> <li><code>@Embedded</code>: Allows embedding another data class as a column in the entity (used for relationships between entities).</li> <li><code>@ForeignKey</code>: Defines a foreign key relationship between two entities.</li> <li><code>@Index</code>: Creates an index on one or more columns to improve query performance.</li> <li><code>@TypeConverters</code>: Specifies custom type converters for complex data types.</li> <li><code>@Relation</code>: Defines a relationship between two entities (used in conjunction with <code>@Embedded</code>).</li> </ul> <p>Example:</p> <pre><code>@Entity(tableName = \"orders\")\ndata class Order(\n@PrimaryKey(autoGenerate = true)\nval orderId: Int = 0,\n@ForeignKey(\nentity = User::class,\nparentColumns = [\"id\"],\nchildColumns = [\"userId\"],\nonDelete = ForeignKey.CASCADE\n)\nval userId: Int,\n@ColumnInfo(name = \"product_name\")\nval product: String,\n@ColumnInfo(name = \"quantity_ordered\")\nval quantity: Int\n@Ignore\nval tempData: String // This property will not be persisted in the database\n)\n</code></pre> <p>More about Entities</p>"},{"location":"U04%20Persistence%20with%20Room/U04.1%20Persistence%20with%20Room/#dao-data-access-object","title":"DAO (Data Access Object)","text":"<p>A DAO is an interface that defines the methods for accessing the database. It is annotated with <code>@Dao</code> and contains methods for performing CRUD (Create, Read, Update, Delete) operations on the entities.</p> <pre><code>import androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.Query\nimport androidx.room.Update\nimport androidx.room.Delete\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface UserDao {\n@Insert(onConflict = OnConflictStrategy.IGNORE)\nsuspend fun insertUser(user: User): Long //Returns the new rowId\n\n@Query(\"SELECT * FROM users\")\nfun getAllUsers(): Flow&lt;List&lt;User&gt;&gt;\n\n@Query(\"SELECT * FROM users WHERE id = :userId\")\nsuspend fun getUserById(userId: Int): User?\n\n@Update\nsuspend fun updateUser(user: User)\n\n@Delete\nsuspend fun deleteUser(user: User)\n}\n</code></pre> <p>The <code>@Insert</code> operation can produce a conflict. A conflict occurs when you try to insert a new row that has the same primary key or unique constraint as an existing row in the table.</p> <p>There are  different conflict strategies:</p> <ul> <li><code>OnConflictStrategy.REPLACE</code>: Replaces the existing row with the new data.</li> <li><code>OnConflictStrategy.IGNORE</code>: Ignores the new data if a conflict occurs.</li> <li><code>OnConflictStrategy.ABORT</code>: Aborts the transaction if a conflict occurs (default behavior).</li> <li><code>OnConflictStrategy.FAIL</code>: Fails the transaction if a conflict occurs.</li> <li><code>OnConflictStrategy.ROLLBACK</code>: Rolls back the transaction if a conflict occurs.</li> </ul> <p>If the <code>@Insert</code> method receives a single parameter, it can return a long value, which is the new rowId for the inserted item.</p> <p>The <code>@Update</code> and <code>@Delete</code> methods can optionally return an integer value representing the number of rows affected by the operation.</p> <p>In the <code>@Query</code> method, you can pass parameters using the <code>:</code> syntax:</p> <pre><code>@Query(\"SELECT * FROM users WHERE id = :userId\")\nsuspend fun getUserById(userId: Int): User?\n\n@Query(\"SELECT * FROM user WHERE age BETWEEN :minAge AND :maxAge\")\nfun loadAllUsersBetweenAges(minAge: Int, maxAge: Int): Array&lt;User&gt;\n\n@Query(\"SELECT * FROM user WHERE first_name LIKE :search \" + \"OR last_name LIKE :search\")\nfun findUserWithName(search: String): List&lt;User&gt;\n</code></pre> <p>When do not use suspend functions in DAO methods</p> <p>You should not use <code>suspend</code> functions in DAO methods that return <code>LiveData</code> or <code>Flow</code>. These return types are designed to be observed and will automatically handle threading for you. Using <code>suspend</code> with these return types can lead to unexpected behavior and is not necessary.</p> <p>Flow vs. LiveData in Room DAOs</p> <p>Both <code>Flow</code> and <code>LiveData</code> are observable data holders that can be used to observe changes in the database. However, there are some differences between them:</p> <ul> <li> <p>Flow is a Kotlin coroutine-based API that provides a more flexible and powerful way to handle asynchronous data streams. It supports operators for transforming and combining data streams, making it suitable for complex data processing scenarios.</p> </li> <li> <p>LiveData is a lifecycle-aware component that is part of the Android Architecture Components. It is designed to work seamlessly with the Android lifecycle, automatically managing subscriptions based on the lifecycle state of the observing components (e.g., Activities or Fragments).</p> </li> </ul> <p>In general, if you are using Kotlin coroutines and need more advanced data processing capabilities, <code>Flow</code> is a better choice. If you are working within the Android lifecycle and want a simpler way to observe data changes, <code>LiveData</code> may be more appropriate.</p> <p>More about DAOs</p>"},{"location":"U04%20Persistence%20with%20Room/U04.1%20Persistence%20with%20Room/#database","title":"Database","text":"<p>The database class is an abstract class that extends <code>RoomDatabase</code>. It is annotated with <code>@Database</code> and defines the entities and DAOs for the database.</p> <p>A singleton pattern is typically used to ensure that only one instance of the database is created throughout the app's lifecycle.</p> <p>An implementation example is shown below:</p> <pre><code>import androidx.room.Database\nimport androidx.room.Room\nimport androidx.room.RoomDatabase\nimport android.content.Context\n\n@Database(entities = [User::class, Order::class], version = 1)\nabstract class AppDatabase : RoomDatabase() {\nabstract fun userDao(): UserDao\nabstract fun orderDao(): OrderDao\n\ncompanion object {\n@Volatile\nprivate var INSTANCE: AppDatabase? = null\n\nfun getDatabase(context: Context): AppDatabase {\nreturn INSTANCE ?: synchronized(this) {\nval instance = Room.databaseBuilder(\ncontext.applicationContext,\nAppDatabase::class.java,\n\"app_database\"\n).build()\nINSTANCE = instance\ninstance\n}\n}\n}\n}\n</code></pre> <p>The version number on the Database annotation should be incremented whenever the database schema is changed. For example, if a new entity is added or an existing entity is modified, the version number should be increased to ensure that the database is properly migrated to the new schema.</p> <p>The <code>synchronized</code> block ensures that only one thread can access the database instance creation code at a time, preventing multiple instances from being created in a multi-threaded environment.</p>"},{"location":"U04%20Persistence%20with%20Room/U04.1%20Persistence%20with%20Room/#repository","title":"Repository","text":"<p>The Repository acts as a mediator between the data sources (Room database, network, etc.) and the rest of the application. It provides a clean API for data access and abstracts the underlying data sources.</p> <p>Although not strictly part of Room, the Repository pattern is commonly used in conjunction with Room.</p> <p></p> <p>It is usual to create a Repository class for each Entity/DAO pair. An example of a UserRepository is shown below:</p> <pre><code>class UserRepository(private val userDao: UserDao) {\nval allUsers: Flow&lt;List&lt;User&gt;&gt; = userDao.getAllUsers()\n\nsuspend fun insert(user: User): Long {\nreturn userDao.insertUser(user)\n}\n\nsuspend fun getUserById(userId: Int): User? {\nreturn userDao.getUserById(userId)\n}\n\nsuspend fun update(user: User) {\nuserDao.updateUser(user)\n}\n\nsuspend fun delete(user: User) {\nuserDao.deleteUser(user)\n}\n}\n</code></pre>"},{"location":"U04%20Persistence%20with%20Room/U04.1%20Persistence%20with%20Room/#using-the-data-in-the-ui-layer","title":"Using the data in the UI layer","text":"<p>In the UI layer, you can use ViewModels to interact with the Repository and observe data changes.</p> <pre><code>import androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport kotlinx.coroutines.flow.collect\nimport kotlinx.coroutines.launch\n\nclass UserViewModel(private val userRepository: UserRepository) : ViewModel() {\n\nval allUsers = userRepository.allUsers\n\nfun insertUser(user: User) {\nviewModelScope.launch {\nuserRepository.insert(user)\n}\n}\n\nfun getUserById(userId: Int) {\nviewModelScope.launch {\nuserRepository.getUserById(userId)?.let { user -&gt;\n// Update UI with user data\n}\n}\n}\n\nfun updateUser(user: User) {\nviewModelScope.launch {\nuserRepository.update(user)\n}\n}\n\nfun deleteUser(user: User) {\nviewModelScope.launch {\nuserRepository.delete(user)\n}\n}\n}\n</code></pre>"},{"location":"U04%20Persistence%20with%20Room/U04.2%20Room%20guided%20practice/","title":"Unit 4.2. Room guided practice","text":"<p>In this guided practice, you will enhance the Tip Time app by adding data persistence using Room. You will create a database to store tip calculations and retrieve them later.</p> <p></p>"},{"location":"U04%20Persistence%20with%20Room/U04.2%20Room%20guided%20practice/#the-data-layer","title":"The data layer","text":"<p>The data layer will consist of the following components:</p> <ol> <li>Entity: Represents a table within the database. Each entity is a data class annotated with <code>@Entity</code>.</li> <li>DAO (Data Access Object): Provides methods for accessing the database. DAOs are interfaces annotated with <code>@Dao</code>.</li> <li>Database: The main database class that holds the database and serves as the main access point for the underlying SQLite database. It is annotated with <code>@Database</code>.</li> <li>Repository: A class that abstracts access to multiple data sources. It mediates between the data layer and the rest of the app.</li> </ol> <p>We will create a new package named <code>data</code> to hold these components.</p>"},{"location":"U04%20Persistence%20with%20Room/U04.2%20Room%20guided%20practice/#1-add-room-dependencies","title":"1. Add Room dependencies","text":"<p>First, declare the KSP plugin in your top level <code>build.gradle.kts</code> file:</p> <pre><code>plugins {\n//Previously declared plugins\nid(\"com.google.devtools.ksp\") version \"2.0.21-1.0.27\" apply false\n}\n</code></pre> <p>Then, enable KSP in your app-level <code>build.gradle.kts</code> file:</p> <pre><code>//Previously declared plugins\nplugins {\nid(\"com.google.devtools.ksp\")\n}\n</code></pre> <p>Finally, add the following Room dependencies to your <code>build.gradle</code> file:</p> <pre><code>dependencies {\nval room_version = \"2.8.3\"\n\n// Previous dependencies\n\n//Room\nimplementation(\"androidx.room:room-runtime:$room_version\")\nksp(\"androidx.room:room-compiler:$room_version\")\nimplementation(\"androidx.room:room-ktx:$room_version\")\n}\n</code></pre> <p>Sync your project to download the dependencies.</p>"},{"location":"U04%20Persistence%20with%20Room/U04.2%20Room%20guided%20practice/#2-create-the-entity","title":"2. Create the Entity","text":"<p>In the <code>data</code> package, create a new Kotlin data class named <code>Tip</code> to represent the tip calculation entity. Annotate the class with <code>@Entity</code> and define the necessary fields:</p> <pre><code>//Tip.kt\n\nimport androidx.room.Entity\nimport androidx.room.PrimaryKey\n\n@Entity(tableName = \"tips\")\ndata class Tip(\n@PrimaryKey(autoGenerate = true)\nval id: Int = 0,\nval billAmount: Double,\nval tipPercentage: Int,\nval roundUp: Boolean,\n)\n</code></pre> <p>As you can see, we use annotations to define the table name. That means that Room will create and use a table named <code>tips</code> in the database.</p> <p>The <code>id</code> field is annotated with <code>@PrimaryKey</code> and set to auto-generate, so Room will automatically assign a unique ID to each tip calculation.</p>"},{"location":"U04%20Persistence%20with%20Room/U04.2%20Room%20guided%20practice/#3-create-the-dao","title":"3. Create the DAO","text":"<p>In the <code>data</code> package, create a new Kotlin interface named <code>TipDao</code>. Annotate the interface with <code>@Dao</code> and define methods for inserting and retrieving tip calculations:</p> <pre><code>//TipDao.kt\n\nimport androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface TipDao {\n@Query(\"SELECT * FROM tips ORDER BY id ASC\")\nfun getAllTips(): Flow&lt;List&lt;Tip&gt;&gt;\n\n@Query(\"SELECT * FROM tips WHERE id = :id\")\nfun getTipById(id: Int): Flow&lt;Tip?&gt;\n\n@Insert(onConflict = OnConflictStrategy.IGNORE)\nsuspend fun insertTip(tip: Tip)\n\n@Update\nsuspend fun updateTip(tip: Tip)\n\n@Delete\nsuspend fun deleteTip(tip: Tip)\n}\n</code></pre> <p>Similar to the entity, we use annotations to define SQL queries for retrieving data from the database.</p> <p>The select methods return a <code>Flow</code> of data, allowing us to observe changes in the database. They have the annotation <code>@Query</code> with the corresponding SQL query as a parameter.</p> <p>The onConflict strategy for the insert method is set to <code>IGNORE</code>, meaning that if a conflict occurs (e.g., trying to insert a tip with an existing ID), the insertion will be ignored.</p> <p>The insert, update, and delete methods are suspended functions, allowing them to be called from a coroutine.</p> <p>Info</p> <p>A suspended method is a special kind of function in Kotlin that can be paused and resumed at a later time. This is particularly useful for performing long-running operations, such as database operations or network requests, without blocking the main thread of the application.</p>"},{"location":"U04%20Persistence%20with%20Room/U04.2%20Room%20guided%20practice/#4-create-the-database","title":"4. Create the Database","text":"<p>In the <code>data</code> package, create a new Kotlin abstract class named <code>TipDatabase</code>. Annotate the class with <code>@Database</code> and define the database configuration:</p> <pre><code>//TipDatabase.kt\n\n@Database(entities = [Tip::class], version = 1, exportSchema = false)\nabstract class TipDatabase : RoomDatabase() {\n\nabstract fun tipDao(): TipDao\n\ncompanion object {\n@Volatile\nprivate var Instance: TipDatabase? = null\n\nfun getDatabase(context: Context): TipDatabase {\n// if the Instance is not null, return it, otherwise create a new database instance.\nreturn Instance ?: synchronized(this) {\nRoom.databaseBuilder(context, TipDatabase::class.java, \"tip_database\")                    .fallbackToDestructiveMigration(false)\n.build()\n.also { Instance = it }\n}\n}\n}\n}\n</code></pre> <p>The database class must satisfy the following conditions:</p> <ul> <li>The class must be annotated with a <code>@Database</code> annotation that includes an <code>entities</code> array that lists all of the data entities associated with the database.</li> <li>The class must be an abstract class that extends <code>RoomDatabase</code>.</li> <li>For each DAO class that is associated with the database, the database class must define an abstract method that has zero arguments and returns an instance of the DAO class.</li> </ul> <p>The version number is set to 1. If you make changes to the database schema in the future, you will need to increment this version number, so that Room can handle the migration.</p> <p>The method <code>getDatabase</code> implements the singleton pattern to ensure that only one instance of the database is created throughout the app's lifecycle. The <code>synchronized</code> block ensures that the database instance is created in a thread-safe manner.</p> <p>The <code>Room.databaseBuilder</code> method is used to create the database instance, specifying the context, the database class, and the database name. The parameter <code>fallbackToDestructiveMigration(false)</code> indicates that Room should not delete the database if a migration is needed but not found.</p>"},{"location":"U04%20Persistence%20with%20Room/U04.2%20Room%20guided%20practice/#5-create-the-repository","title":"5. Create the Repository","text":"<p>A repository class abstracts access to multiple data sources. It mediates between the data layer and the rest of the app. It's not mandatory, but it's a good practice to use it.</p> <p>In the <code>data</code> package, create a new Kotlin class named <code>TipRepository</code>. Define the repository class as follows:</p> <pre><code>//TipRepository.kt\n\nimport kotlinx.coroutines.flow.Flow\n\nclass TipRepository(private val tipDao: TipDao) {\n\nfun getAllTips(): Flow&lt;List&lt;Tip&gt;&gt; = tipDao.getAllTips()\n\nfun getTipById(id: Int): Flow&lt;Tip?&gt; = tipDao.getTipById(id)\n\nsuspend fun insertTip(tip: Tip) = tipDao.insertTip(tip)\n\nsuspend fun updateTip(tip: Tip) = tipDao.updateTip(tip)\n\nsuspend fun deleteTip(tip: Tip) = tipDao.deleteTip(tip)\n}\n</code></pre> <p>The data layer is done, you can run the app now to check that everything is working fine. No database operations are performed yet, so the app should work as before.</p>"},{"location":"U04%20Persistence%20with%20Room/U04.2%20Room%20guided%20practice/#6-add-the-save-functionality-to-the-viewmodel","title":"6. Add the save functionality to the ViewModel","text":"<p>Now that we have the data layer set up, we need to integrate it into the ViewModel to allow saving tip calculations.</p> <p>In the <code>TipViewModel</code>, change the constructor to accept an Application context and inherit from <code>AndroidViewModel</code> instead of <code>ViewModel</code>. This will allow us to access the database instance.</p> <p>Then, create an instance of the <code>TipRepository</code> using the <code>TipDatabase</code> and implement a method to save the tip calculation.</p> <pre><code>//TipTimeViewModel.kt\nimport android.app.Application\nimport androidx.lifecycle.AndroidViewModel\nimport androidx.lifecycle.viewModelScope\nimport kotlinx.coroutines.launch\n\nclass TipTimeViewModel(application: Application) : AndroidViewModel(application) {   // Existing properties and methods\n\nprivate val tipRepository: TipRepository = TipRepository(\nTipDatabase.getDatabase(application).tipDao()\n)\n\nfun saveTipCalculation() {\n// Launch a coroutine in the ViewModel's scope\nviewModelScope.launch {\nval tip = Tip(\nbillAmount = _uiState.value.amountInput.toDoubleOrNull() ?: 0.0,\ntipPercentage = _uiState.value.tipInput.toIntOrNull() ?: 15,\nroundUp = _uiState.value.roundUp\n)\n// Use the repository to insert the tip\ntipRepository.insertTip(tip)\n}\n}\n}\n</code></pre>"},{"location":"U04%20Persistence%20with%20Room/U04.2%20Room%20guided%20practice/#7-save-from-the-ui","title":"7. Save from the UI","text":"<p>Finally, we need to call the <code>saveTipCalculation</code> method from the UI when the user wants to save a tip calculation. You can add a button in the UI that triggers this action.</p> <p>For example, in your Composable function, change the <code>onNextButtonClicked</code> lambda to call the save method:</p> <pre><code>//TipTimeLayout.kt\n\ncomposable( route = Routes.Start.name) {\nTipTimeStartScreen(\ntipTimeViewModel = tipTimeViewModel,\nonNextButtonClicked = {\ntipTimeViewModel.saveTipCalculation()\nnavController.navigate(Routes.TipResult.name)\n},\nmodifier = Modifier\n.fillMaxSize()\n.padding(40.dp)\n)\n}\n</code></pre> <pre><code>sequenceDiagram\n    actor User\n\n    User-&gt;&gt;+EditScreen: Clicks \"Save\"/\"Update\" Button\n    EditScreen-&gt;&gt;+ViewModel: Calls saveTipCalculation()\n\n    ViewModel-&gt;&gt;+Repository: Calls insertTip(tip) or updateTip(tip)\n    Repository-&gt;&gt;+DAO: Calls insert(tip) or update(tip)\n    DAO-&gt;&gt;+Database: Executes SQL INSERT or UPDATE statement\n    Database--&gt;&gt;-DAO: Confirms operation success\n    DAO--&gt;&gt;-Repository: Returns confirmation\n    Repository--&gt;&gt;-ViewModel: Returns confirmation\n    ViewModel--&gt;&gt;-EditScreen: (Completes coroutine scope)\n</code></pre>"},{"location":"U04%20Persistence%20with%20Room/U04.2%20Room%20guided%20practice/#8-add-a-list-screen","title":"8. Add a list screen","text":"<p>Now that we have the ability to save tip calculations, let's add a new screen to display the list of saved tips.</p> <p>Change the name of your <code>TipTimeStartScreen</code> to <code>TipTimeEditScreen</code>. Create a new screen with the name <code>TipTimeStartScreen</code>, that will contain a lazy column to show the list of saved tips.</p> <p>Adjust your navigation to include the new screen:</p> <pre><code>//Routes.kt\n\nenum class Routes(@StringRes val title: Int) {\nStart (title = R.string.app_name),\nEditTip (title = R.string.edit_tip),\nTipResult (title = R.string.tip_result)\n}\n</code></pre> <p>The <code>TipTimeStartScreen</code> will contain the next composables:</p> <ul> <li><code>TipTimeStartScreen</code>: the main composable that contains the lazy column.</li> <li><code>TipList</code>: the lazy column that displays the list of saved tips.</li> <li><code>TipItem</code>: the individual item in the list that displays the tip details inside a card component.</li> </ul> <p>Lets see each composable implementation:</p> <pre><code>//TipTimeStartScreen.kt\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun TipTimeStartScreen(\nonItemClick: (Int) -&gt; Unit,\nmodifier: Modifier = Modifier,\nstartViewModel: StartViewModel = viewModel(),\ncontentPadding: PaddingValues = PaddingValues(0.dp)\n) {\nval uiState by startViewModel.uiState.collectAsState()\nval tipList = uiState.itemList\n\nColumn(\nhorizontalAlignment = Alignment.CenterHorizontally,\nmodifier = modifier,\n) {\nif (tipList.isEmpty()) {\nText(\ntext = stringResource(R.string.no_tips_description),\ntextAlign = TextAlign.Center,\nstyle = MaterialTheme.typography.titleLarge,\nmodifier = Modifier.padding(contentPadding),\n)\n} else {\nTipList(\ntipList = tipList,\nonItemClick = { onItemClick(it.id) },\ncontentPadding = contentPadding,\nmodifier = Modifier.padding(horizontal = 6.dp)\n)\n}\n}\n}\n</code></pre> <p>In this composable, we observe the <code>uiState</code> from the <code>StartViewModel</code> (that we will create later) to get the list of saved tips. If the list is empty, we display a message; otherwise, we show the <code>TipList</code> composable.</p> <pre><code>//TipTimeStartScreen.kt\n\n@Composable\nfun TipList(\ntipList: List&lt;Tip&gt;,\nonItemClick: (Tip) -&gt; Unit,\nmodifier: Modifier = Modifier,\ncontentPadding: PaddingValues,\n) {\nLazyColumn(\nmodifier = modifier,\ncontentPadding = contentPadding\n) {\nitems(items = tipList, key = { it.id }) { tip -&gt;\nTipItem(tip = tip,\nmodifier = Modifier\n.padding(6.dp)\n.clickable { onItemClick(tip) })\n}\n}\n}\n</code></pre> <p>Here we are using a <code>LazyColumn</code> to display the list of tips. Each item in the list is represented by the <code>TipItem</code> composable. When we click on an item, we call the <code>onItemClick</code> lambda with the selected tip.</p> <p>LazyColumn</p> <p>A <code>LazyColumn</code> is a vertically scrolling list that only composes and lays out the currently visible items. This makes it more efficient than a regular <code>Column</code> for displaying large lists of data, as it only creates the views that are currently needed.</p> <pre><code>//TipTimeStartScreen.kt\n\n@Composable\nfun TipItem(\ntip: Tip,\nmodifier: Modifier = Modifier\n) {\nCard(\nmodifier = modifier,\nelevation = CardDefaults.cardElevation(defaultElevation = 2.dp)\n) {\nColumn(\nmodifier = Modifier.padding(20.dp),\nverticalArrangement = Arrangement.spacedBy(8.dp),\n) {\nText(\ntext = stringResource(R.string.bill_amount)  + \": \" + tip.billAmount,\nstyle = MaterialTheme.typography.bodyLarge\n)\nSpacer(Modifier.weight(1f))\nText(\ntext = stringResource(R.string.tip_amount, tip.tipPercentage),\nstyle = MaterialTheme.typography.bodyMedium,\ntextAlign = TextAlign.End,\nmodifier = Modifier.fillMaxWidth()\n)\n}\n}\n}\n</code></pre> <p>Here we define how each tip item looks. We use a <code>Card</code> component to display the tip details, including the bill amount and tip percentage, that we get from the <code>Tip</code> entity.</p> <p>The <code>TipTimeStartScreen</code> will need a corresponding ViewModel to fetch the list of saved tips from the database. Create a new ViewModel named <code>StartViewModel</code> on the <code>ui.viewmodels</code> package:</p> <pre><code>package com.example.tiptime.viewmodels\n\nimport android.app.Application\nimport androidx.lifecycle.AndroidViewModel\nimport androidx.lifecycle.viewModelScope\nimport com.example.tiptime.data.Tip\nimport com.example.tiptime.data.TipDatabase\nimport com.example.tiptime.data.TipRepository\nimport kotlinx.coroutines.flow.SharingStarted\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.map\nimport kotlinx.coroutines.flow.stateIn\n\n/**\n * ViewModel for the Start screen.\n */\nclass StartViewModel(application: Application) : AndroidViewModel(application) {\n\nprivate val tipRepository: TipRepository = TipRepository(\nTipDatabase.getDatabase(application).tipDao()\n)\n\nval uiState: StateFlow&lt;StartUiState&gt; = tipRepository.getAllTips()\n.map { StartUiState(it) }\n.stateIn(\nscope = viewModelScope,\nstarted = SharingStarted.WhileSubscribed(5000),\ninitialValue = StartUiState()\n)\n\ncompanion object {\n// Timeout for keeping the flow active while there are no subscribers.\nprivate const val TIMEOUT_MILLIS = 5_000L\n}\n}\n\n/**\n * The UI state for the Start screen.\n */\ndata class StartUiState(\nval itemList :List&lt;Tip&gt; = listOf()\n)\n</code></pre> <p>In the view model, we create an instance of the <code>TipRepository</code> to access the data layer. We define a <code>uiState</code> property that is a <code>StateFlow</code> of <code>StartUiState</code>, which contains the list of saved tips. The mapping function transforms the flow of tips from the repository into the UI state. The <code>stateIn</code> function is used to convert the flow into a state flow that can be observed by the UI.</p> <p>The companion object contains a constant for the timeout duration when there are no subscribers to the flow.</p> <p>In the same file we define the <code>StartUiState</code> data class, which holds the list of tips to be displayed in the UI.</p> <p>Now, it's time to modify the navigation to include the new screen. In your <code>TipTimeLayout.kt</code> file, update the navigation graph to include the changes:</p> <pre><code>//TipTimeLayout.kt\n\nfun TipTimeLayout(\ntipTimeViewModel: TipTimeViewModel = viewModel(),\nstartViewModel: StartViewModel = viewModel(), // ADD THIS LINE\nnavController: NavHostController = rememberNavController()\n) {\n...\n\n\nNavHost(\nnavController = navController,\nstartDestination = Routes.Start.name,\nmodifier = Modifier.padding(innerPadding)\n) {\ncomposable( route = Routes.Start.name) {\nTipTimeStartScreen(\nstartViewModel = startViewModel,\nonItemClick = { navController.navigate(Routes.EditTip.name)},\nmodifier = Modifier\n.fillMaxSize()\n.padding(40.dp)\n)\n}\ncomposable( route = Routes.EditTip.name) {\nTipTimeEditScreen(\ntipTimeViewModel = tipTimeViewModel,\nonNextButtonClicked = {\ntipTimeViewModel.saveTipCalculation()\nnavController.navigate(Routes.TipResult.name)\n},\nmodifier = Modifier\n.fillMaxSize()\n.padding(40.dp)\n)\n}\n// Rest of the navigation graph\n}\n</code></pre> <p>Note how in the <code>onNextButtonClicked</code> lambda of the <code>TipTimeEditScreen</code>, we call the <code>saveTipCalculation</code> method before navigating to the <code>TipResult</code> screen.</p> <p>This should be enough. Check that everything is working fine by running the app. You should be able to save tip calculations and see them listed in the start screen.</p> <p>However, when you open a tip element, it does not show the details of the tip. We will solve it in the next point.</p>"},{"location":"U04%20Persistence%20with%20Room/U04.2%20Room%20guided%20practice/#9-edit-tips","title":"9. Edit tips","text":"<p>For editing tips, we need to modify the <code>TipTimeEditScreen</code> to accept a tip ID and load the corresponding tip details from the database.</p> <p>From the <code>TipTimeLayout.kt</code> we need to pass the tip ID when navigating to the <code>TipTimeEditScreen</code>. Then, we will load the tip details in the ViewModel based on the passed ID, with the repository method <code>getTipById</code>.</p> <p>First, modify the Routes enum to include a parameter for the tip ID and a string resource for the route:</p> <pre><code>//Routes.kt\n\nenum class Routes(@StringRes val title: Int, val route: String) {\nStart(title = R.string.app_name, route = \"Start\"),\nEditTip(title = R.string.edit_tip, route = \"EditTip\"),\nTipResult(title = R.string.tip_result, route = \"TipResult\");\n\ncompanion object {\nconst val TIP_ID_ARG = \"tipId\"\n}\n\n/**\n     * The route pattern that accepts a tip id argument, e.g. \"EditTip/{tipId}\"\n     */\nfun withArg(): String = \"$route/{$TIP_ID_ARG}\"\n\n/**\n     * Build a concrete route for the given id, e.g. \"EditTip/3\"\n     */\nfun createRouteFor(id: Int): String = \"$route/$id\"\n}\n</code></pre> <p>This code still maintains the string resource for the title, but now also includes a <code>route</code> property for each enum value. The <code>withArg</code> method constructs a route pattern that includes a placeholder for the tip ID, while the <code>createRouteFor</code> method generates a concrete route by substituting the placeholder with an actual tip ID.</p> <p>In the <code>TipTimeLayout</code> composable, modify the <code>currentScreen</code> variable to use the new route property:</p> <pre><code>//TipTimeLayout.kt\n\n// Resolve a route string for the current entry (may include concrete id like \"EditTip/3\")\nval currentRoute = backStackEntry?.destination?.route ?: Routes.Start.route\n\n// Map the route string to our Routes enum, handling both plain and \"withArg\" patterns\nval currentScreen = Routes.values().firstOrNull { r -&gt;\ncurrentRoute == r.route ||\ncurrentRoute.startsWith(r.route + \"/\") ||\ncurrentRoute == r.withArg()\n} ?: Routes.Start\n</code></pre> <p>This code modifies the way the current screen is determined by checking if the current route matches either the base route or starts with the base route followed by a slash (indicating a concrete ID).</p> <p>In the composable for the Start screen, modify the navigation to pass the tip ID when navigating to the EditTip screen:</p> <pre><code>//TipTimeLayout.kt\n\ncomposable(route = Routes.Start.route) {\nTipTimeStartScreen(\nstartViewModel = startViewModel,\n// Navigate to EditTip with the selected tip id using the helper\nonItemClick = { id -&gt; navController.navigate(Routes.EditTip.createRouteFor(id)) },\nmodifier = Modifier\n.fillMaxSize()\n.padding(40.dp)\n)\n}\n</code></pre> <p>Here, we use the <code>createRouteFor</code> method to generate the navigation route with the selected tip ID.</p> <p>In the composable for the <code>EditTip</code> screen, modify the route to accept the tip ID argument and retrieve it from the back stack entry. We also modify the onClick lambda to save/update the tip in the database:</p> <pre><code>//TipTimeLayout.kt\n\n// EditTip route now accepts a path parameter using the enum helper\ncomposable(\nroute = Routes.EditTip.withArg(),\narguments = listOf(navArgument(Routes.TIP_ID_ARG) { type = NavType.IntType })\n) { backStackEntry -&gt;\nval tipId = backStackEntry.arguments?.getInt(Routes.TIP_ID_ARG) ?: 0\nTipTimeEditScreen(\ntipTimeViewModel = tipTimeViewModel,\nonNextButtonClicked = {\ntipTimeViewModel.saveTipCalculation()\nnavController.navigate(Routes.TipResult.route)\n},\ntipId = tipId,\nmodifier = Modifier\n.fillMaxSize()\n.padding(40.dp)\n)\n}\n</code></pre> <p>Here, we define the route to accept an integer argument for the tip ID. We retrieve the tip ID from the back stack entry's arguments and pass it to the <code>TipTimeEditScreen</code> composable.</p> <p>In the <code>TipTimeEditScreen</code>, add a new argument for the tip ID and load the tip details in the ViewModel:</p> <pre><code>fun TipTimeEditScreen(\nonNextButtonClicked: () -&gt; Unit,\nmodifier: Modifier = Modifier,\ntipTimeViewModel: TipTimeViewModel = viewModel(),\ntipId: Int? = 0\n) {\n// Use LaunchedEffect to load the tip when the screen is first displayed\nLaunchedEffect(tipId) {\nif (tipId != null &amp;&amp; tipId != 0) { // Assuming 0 is not a valid ID\ntipTimeViewModel.loadTipById(tipId)\n} else {\ntipTimeViewModel.resetTip() // Optional: Clear fields for a new tip\n}\n}\n// Rest of the composable code\n</code></pre> <p>Here, we use <code>LaunchedEffect</code> to load the tip details when the screen is first displayed. If a valid tip ID is provided, we call the <code>loadTipById</code> method in the ViewModel to fetch the tip details. If the tip ID is 0 or null, we reset the fields for a new tip.</p> <p>LaunchedEffect</p> <p><code>LaunchedEffect</code> is a composable function in Jetpack Compose that allows you to run suspend functions or side effects in response to changes in the composition. It is typically used to perform actions that should occur when a specific key or set of keys change. LaunchedEffect</p> <p>Another modification is done in the Next button click lambda to call the <code>saveTipCalculation</code> method:</p> <pre><code>//TipTimeEditScreen.kt\n\n//Previous composables\nButton(\nonClick = onNextButtonClicked,\n) {\n// Change button text based on whether it's a new tip or an edit\nval buttonText = if (tipId != null &amp;&amp; tipId != 0) {\nstringResource(R.string.update)\n} else {\nstringResource(R.string.save)\n}\nText(buttonText)\n}\n</code></pre> <p>Finally, in the <code>TipTimeViewModel</code>, we need new methods to load a tip by its ID and reset or update the tip fields.</p> <p>First, add a new property to hold the currently loaded tip:</p> <pre><code>private var currentTipId: Int? = null\n</code></pre> <p>The <code>loadTipById</code> method fetches the tip from the repository and updates the UI state:</p> <pre><code>fun loadTipById(tipId: Int) {\ncurrentTipId = tipId\nviewModelScope.launch {\n// Fetch the tip from the repository\nval tip = tipRepository.getTipById(tipId).firstOrNull()\ntip?.let {\n// Update the UI state with the fetched tip data\n_uiState.update { currentState -&gt;\ncurrentState.copy(\nid = it.id,\namountInput = it.billAmount.toString(),\ntipInput = it.tipPercentage.toString(),\nroundUp = it.roundUp\n)\n}\n// Recalculate tip and total for the loaded values\ncalculateTip()\n}\n}\n}\n</code></pre> <p>let and scope functions</p> <p>The <code>let</code> function in Kotlin is a scope function that allows you to execute a block of code on an object and return the result of the block. It is often used for null-checking and chaining operations on an object. let function Scope functions</p> <p>The <code>saveTipCalculation</code> method is modified to handle both insert and update operations based on whether a tip is being edited or created, depending on the value of <code>currentTipId</code>:</p> <pre><code>fun saveTipCalculation() {\n// Launch a coroutine in the ViewModel's scope\nviewModelScope.launch {\nval tip = Tip(\nid = currentTipId ?: 0, // Use currentTipId if it exists, otherwise 0 for a new entry\nbillAmount = _uiState.value.amountInput.toDoubleOrNull() ?: 0.0,\ntipPercentage = _uiState.value.tipInput.toIntOrNull() ?: 15,\nroundUp = _uiState.value.roundUp\n)\n// Use the repository to insert the tip\nif (currentTipId == null || currentTipId == 0) {\ntipRepository.insertTip(tip)\n} else {\ntipRepository.updateTip(tip)\n}\n}\n}\n</code></pre> <p>Finally, the <code>resetTip</code> method clears the current tip ID and resets the UI state. It is called when creating a new tip and the tip id is 0 or null:</p> <pre><code>fun resetTip() {\ncurrentTipId = null\n_uiState.value = TipTimeState() // Reset to default state\n}\n</code></pre> <p>Check that everything is working fine by running the app. You should be able to update tips loaded from the list.</p>"},{"location":"U04%20Persistence%20with%20Room/U04.2%20Room%20guided%20practice/#10-adding-tips","title":"10. Adding tips","text":"<p>To add a new tip, we need a FAB button on the <code>TipTimeLayout</code> that navigates to the <code>EditTip</code> screen without passing an id with the value of 0:</p> <pre><code>//TipTimeLayout.kt\n\nScaffold(\ntopBar = {\n//TopBar content\n},\nfloatingActionButton = {\n// Add a FAB only on the Start screen\nif (currentScreen == Routes.Start) {\nandroidx.compose.material3.FloatingActionButton(\nonClick = { navController.navigate(Routes.EditTip.createRouteFor(0)) }\n) {\nIcon(\nimageVector = Icons.Default.Add,\ncontentDescription = stringResource(R.string.add_tip)\n)\n}\n}\n}\n</code></pre>"},{"location":"U04%20Persistence%20with%20Room/U04.2%20Room%20guided%20practice/#11-deleting-tips","title":"11. Deleting tips","text":"<p>For delete an existing tip, we need a button in the <code>TipTimeEditScreen</code> that calls a new method in the ViewModel to delete the current tip. This button should only be visible when editing an existing tip (i.e., when <code>tipId</code> is not null or 0).</p> <pre><code>//TipTimeEditScreen.kt\n\n// Add a delete button if editing an existing tip\nif (tipId != null &amp;&amp; tipId != 0) {\nSpacer(modifier = Modifier.height(16.dp))\nOutlinedButton(\nonClick = {\ntipTimeViewModel.deleteTip()\nbackNavitation()\n},\nmodifier = Modifier,\n) {\nText(stringResource(R.string.delete))\n}\n}\n</code></pre> <p>We are calling a the backNavigation lambda to return to the previous screen after deleting the tip, but we need to passit as argument from the TipTimeLayout:</p> <pre><code>//TipTimeLayout.kt\n\ncomposable(\nroute = Routes.EditTip.withArg(),\narguments = listOf(navArgument(Routes.TIP_ID_ARG) { type = NavType.IntType })\n) { backStackEntry -&gt;\nval tipId = backStackEntry.arguments?.getInt(Routes.TIP_ID_ARG) ?: 0\nTipTimeEditScreen(\ntipTimeViewModel = tipTimeViewModel,\nonNextButtonClicked = {\ntipTimeViewModel.saveTipCalculation()\nnavController.navigate(Routes.TipResult.route)\n},\nbackNavigation = { navController.navigateUp() }, //ADD THIS LINE\ntipId = tipId,\nmodifier = Modifier\n.fillMaxSize()\n.padding(40.dp)\n)\n}\n</code></pre> <p>And in the TipTimeEditScreen composable, add the new argument:</p> <pre><code>//TipTimeEditScreen.kt\n\nfun TipTimeEditScreen(\nonNextButtonClicked: () -&gt; Unit,\nbackNavigation: () -&gt; Unit, // ADD THIS LINE\n...\n</code></pre> <p>Finally, implement the <code>deleteTip</code> method in the <code>TipTimeViewModel</code>:</p> <pre><code>//TipTimeViewModel.kt\n\nfun deleteTip() {\nval tipId = currentTipId ?: return // If no current tip, do nothing\nval tip = Tip(\nid = tipId,\nbillAmount = _uiState.value.amountInput.toDoubleOrNull() ?: 0.0,\ntipPercentage = _uiState.value.tipInput.toIntOrNull() ?: 15,\nroundUp = _uiState.value.roundUp\n)\nviewModelScope.launch {\ntipRepository.deleteTip(tip)\n}\n}\n</code></pre> <p>Done! Check that everything is working fine by running the app. You should be able to delete existing tips.</p>"},{"location":"U04%20Persistence%20with%20Room/U04.2%20Room%20guided%20practice/#12-fixing-state-issues","title":"12. Fixing state issues","text":"<p>You can notice some sate issues when rotating the Edit Screen. To fix it, we need to save the current tip ID in the next files:</p> <pre><code>//TipTimeEditScreen.kt\n\n@Composable\nfun TipTimeEditScreen(\n// Existing parameters\n) {\n// Use LaunchedEffect to load the tip when the screen is first displayed\nLaunchedEffect(tipId) {\nif (tipId != null &amp;&amp; tipId != 0) { // Assuming 0 is not a valid ID\ntipTimeViewModel.loadOrKeepTip(tipId)  //CHANGE THIS\n} else {\n//tipTimeViewModel.resetTip() // DELETE THIS\n}\n}\n...\n</code></pre> <pre><code>//TipTimeLayout.kt\n\n...\n\nfloatingActionButton = {\nif (currentScreen == Routes.Start) {\nandroidx.compose.material3.FloatingActionButton(\nonClick = { tipTimeViewModel.resetTip() //ADD THIS\nnavController.navigate(Routes.EditTip.createRouteFor(0))\n}\n)\n\n...\n\ncomposable(route = Routes.TipResult.route) {\nTipTimeResultScreen(\ntipTimeViewModel = tipTimeViewModel,\nonBackButtonClicked = {\nnavController.navigate(Routes.Start.route) {popUpTo(0)}\ntipTimeViewModel.resetTip() //ADD THIS\n},\nmodifier = Modifier\n.fillMaxSize()\n.padding(10.dp)\n)\n}\n</code></pre> <pre><code>//TipTimeViewModel.kt\n\n//ADD THIS FUNCTION\nfun loadOrKeepTip(tipId: Int) {\nif (currentTipId == null || currentTipId == 0) { // Assuming 0 is not a valid ID\nloadTipById(tipId)\n}\n}\n</code></pre> <pre><code>//TipTimeViewModel.kt\n\n//MODIFY THIS FUNCTION\nfun deleteTip() {\nval tipId = currentTipId ?: return // If no current tip, do nothing\nval tip = Tip(\nid = tipId,\nbillAmount = _uiState.value.amountInput.toDoubleOrNull() ?: 0.0,\ntipPercentage = _uiState.value.tipInput.toIntOrNull() ?: 15,\nroundUp = _uiState.value.roundUp\n)\nviewModelScope.launch {\ntipRepository.deleteTip(tip)\nresetTip() //ADD THIS\n}\n}\n</code></pre> <p>Basically, we ensure that the tip ID is only reset when navigating to the Edit screen for a new tip or when returning to the Start screen. This prevents the tip ID from being lost during configuration changes like screen rotations.</p>"},{"location":"U04%20Persistence%20with%20Room/U04.2%20Room%20guided%20practice/#improvements","title":"Improvements","text":"<p>The basic functionality is in place, but still some possible improvements to the app could be:</p> <ul> <li>Show snackbars to inform the user about successful save, update, or delete operations.</li> <li>Improve navigation.</li> <li>Disable the save/update button when the input fields are blank or invalid.</li> <li>Add confirmation dialog before deleting a tip.</li> </ul>"},{"location":"U04%20Persistence%20with%20Room/U04.2%20Room%20guided%20practice/#references","title":"References","text":"<p>In the codelab you can see more details about Room and how to use it in Android apps: Use Room for data persistence</p>"},{"location":"U04%20Persistence%20with%20Room/U04.2%20Room%20guided%20practice/#source-code","title":"Source code","text":"<p>GitHub repository</p>"},{"location":"U04%20Persistence%20with%20Room/U04.3%20Relationships/","title":"Unit 4.3. Relationships with Room","text":""},{"location":"U04%20Persistence%20with%20Room/U04.3%20Relationships/#types-of-relationships","title":"Types of relationships","text":"<p>There are 4 types of relationships in Room:</p> <ul> <li>One-to-One: A single entity is related to a single instance of another entity.</li> <li>One-to-Many: A single entity is related to multiple instances of another entity.</li> <li>Many-to-Many: Multiple instances of one entity are related to multiple instances of another entity.</li> <li>Nested relationships: Entities can contain other entities as fields, creating a hierarchy.</li> </ul>"},{"location":"U04%20Persistence%20with%20Room/U04.3%20Relationships/#implementing-relationships","title":"Implementing relationships","text":"<p>In Room, there are 2 main ways to implement relationships:</p> <p>Using an intermediate data class to represent the relationship. This class contains fields for both entities involved in the relationship:</p> <pre><code>@Dao\ninterface UserBookDao {\n@Query(\n\"SELECT user.name AS userName, book.name AS bookName \" +\n\"FROM user, book \" +\n\"WHERE user.id = book.user_id\"\n)\nfun loadUserAndBookNames(): Flow&lt;List&lt;UserBook&gt;&gt;\n}\n\ndata class UserBook(val userName: String?, val bookName: String?)\n</code></pre> <p>Using the multimap return types approach. You define a multimap return:</p> <pre><code>@Query(\n\"SELECT * FROM user\" +\n\"JOIN book ON user.id = book.user_id\"\n)\nfun loadUserAndBookNames(): Map&lt;User, List&lt;Book&gt;&gt;\n</code></pre> <p>In this case, Room will automatically create a map where each <code>User</code> is associated with a list of <code>Book</code> objects.</p>"},{"location":"U04%20Persistence%20with%20Room/U04.3%20Relationships/#one-to-one-relationship","title":"One-to-one relationship","text":"<p>In a one-to-one relationship, each instance of an entity is associated with a single instance of another entity.</p> <pre><code>@Entity\ndata class User(\n@PrimaryKey val id: Int,\nval userName: String\n)\n\n@Entity\ndata class Book(\n@PrimaryKey val bookId: Int,\nval bookName: String,\nval userId: Int\n)\n</code></pre> <p>To query the one-to-one relationship, you can create a data class that combines both entities:</p> <pre><code>data class UserWithBook(\n@Embedded val user: User,\n@Relation(\nparentColumn = \"id\",\nentityColumn = \"userId\"\n)\nval book: Book\n)\n</code></pre> <p>Finally, you can create a DAO method to retrieve the data:</p> <pre><code>@Transaction\n@Query(\"SELECT * FROM User\")\nfun getUsersWithBooks(): List&lt;UserWithBook&gt;\n</code></pre> <p>Transaction annotation</p> <p>The <code>@Transaction</code> annotation ensures that the query is executed in a single transaction, which is important for maintaining data integrity.</p>"},{"location":"U04%20Persistence%20with%20Room/U04.3%20Relationships/#one-to-many-relationship","title":"One-to-many relationship","text":"<p>In a one-to-many relationship, a single instance of an entity is associated with multiple instances of another entity.</p> <pre><code>@Entity\ndata class User(\n@PrimaryKey val id: Int,\nval userName: String\n)\n\n@Entity\ndata class Book(\n@PrimaryKey val bookId: Int,\nval bookName: String,\nval userId: Int\n)\n\ndata class UserWithBooks(\n@Embedded val user: User,\n@Relation(\nparentColumn = \"id\",\nentityColumn = \"userId\"\n)\nval books: List&lt;Book&gt;\n)\n</code></pre> <p>To query the one-to-many relationship, you can create a DAO method:</p> <pre><code>@Transaction\n@Query(\"SELECT * FROM User\")\nfun getUsersWithBooks(): List&lt;UserWithBooks&gt;\n</code></pre>"},{"location":"U04%20Persistence%20with%20Room/U04.3%20Relationships/#many-to-many-relationship","title":"Many-to-many relationship","text":"<p>In a many-to-many relationship, multiple instances of one entity are associated with multiple instances of another entity. This is typically implemented using an associative entity.</p> <pre><code>@Entity\ndata class Student(\n@PrimaryKey val studentId: Int,\nval studentName: String\n)\n\n@Entity\ndata class Course(\n@PrimaryKey val courseId: Int,\nval courseName: String\n)\n\n@Entity(primaryKeys = [\"studentId\", \"courseId\"])\ndata class StudentCourseCrossRef(\nval studentId: Int,\nval courseId: Int\n)\n</code></pre> <p>Then, you need to create data classes to represent the relationships:</p> <pre><code>data class StudentWithCourses(\n@Embedded val student: Student,\n@Relation(\nparentColumn = \"studentId\",\nentityColumn = \"courseId\",\nassociateBy = Junction(StudentCourseCrossRef::class)\n)\nval courses: List&lt;Course&gt;\n)\n\ndata class CourseWithStudents(\n@Embedded val course: Course,\n@Relation(\nparentColumn = \"courseId\",\nentityColumn = \"studentId\",\nassociateBy = Junction(StudentCourseCrossRef::class)\n)\nval students: List&lt;Student&gt;\n)\n</code></pre> <p>Finally, you can create DAO methods to retrieve the data:</p> <pre><code>@Transaction\n@Query(\"SELECT * FROM Student\")\nfun getStudentsWithCourses(): List&lt;StudentWithCourses&gt;\n\n@Transaction\n@Query(\"SELECT * FROM Course\")\nfun getCoursesWithStudents(): List&lt;CourseWithStudents&gt;\n</code></pre>"},{"location":"U04%20Persistence%20with%20Room/U04.3%20Relationships/#transactions","title":"Transactions","text":"<p>When performing multiple related database operations, it's important to ensure that they are executed atomically. Room provides the <code>@Transaction</code> annotation to handle this.</p> <pre><code>@Dao\ninterface UserDao {\n@Transaction\nsuspend fun insertUserAndBooks(user: User, books: List&lt;Book&gt;) {\ninsertUser(user)\nbooks.forEach { insertBook(it) }\n}\n\n@Insert\nsuspend fun insertUser(user: User)\n\n@Insert\nsuspend fun insertBook(book: Book)\n}\n</code></pre> <p>In this code snippet, the <code>insertUserAndBooks</code> method is annotated with <code>@Transaction</code>, ensuring that both the user and their books are inserted atomically.</p> <p>When you call a transaction inside a try-catch block, if any operation fails, the entire transaction is rolled back, maintaining data integrity:</p> <pre><code>try {\nuserDao.insertUserAndBooks(user, books)\n} catch (e: Exception) {\n// Handle the error\n}\n</code></pre>"},{"location":"U04%20Persistence%20with%20Room/U04.3%20Relationships/#references","title":"References","text":"<ul> <li>Room Relationships</li> </ul>"},{"location":"U04%20Persistence%20with%20Room/U04.4%20More/","title":"Unit 4.4. More about Android development","text":"<p>At this point, you can develop a large variety of Android applications. However, there are many more topics and advanced features in Android development that you can explore to enhance your skills further.</p> <p>Here you have some links to additional resources and topics you might find interesting:</p>"},{"location":"U04%20Persistence%20with%20Room/U04.4%20More/#ui","title":"UI","text":"<ul> <li>Change the App icon</li> <li>Simple animations with Jetpack Compose</li> <li>Adaptative layouts</li> <li>Grid layouts</li> </ul>"},{"location":"U04%20Persistence%20with%20Room/U04.4%20More/#preferences-and-storage","title":"Preferences and storage","text":"<ul> <li>Permissions</li> <li>DataStore: Preferences</li> <li>Shared Storage</li> </ul>"},{"location":"U04%20Persistence%20with%20Room/U04.4%20More/#connectivity","title":"Connectivity","text":"<ul> <li>Connecting to the internet and loading data</li> <li>Using Google Maps</li> </ul>"},{"location":"U04%20Persistence%20with%20Room/U04.4%20More/#sensors-and-hardware","title":"Sensors and hardware","text":"<ul> <li>Sensors</li> <li>Camera</li> <li>User location</li> </ul>"},{"location":"U04%20Persistence%20with%20Room/U04.4%20More/#services-and-background-tasks","title":"Services and background tasks","text":"<ul> <li>WorkManager</li> <li>Services</li> </ul>"},{"location":"U04%20Persistence%20with%20Room/U04.4%20More/#publishing-your-app","title":"Publishing your app","text":"<ul> <li>Google Play Console</li> </ul>"},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.1%20Introduction%20to%20Flutter/","title":"Unit 5.1. Introduction to Flutter","text":"<p>Flutter is an open-source UI software development kit created by Google. It is used to develop cross-platform applications for Android, iOS, Linux, macOS, Windows and the web from a single codebase. Flutter was first announced in 2015 and released in May 2017.</p> <p></p>"},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.1%20Introduction%20to%20Flutter/#key-features-of-flutter","title":"Key Features of Flutter","text":"<ul> <li>Cross-Platform Development: Write once, run anywhere. Flutter allows developers to create applications that work on multiple platforms without needing to rewrite code for each one.</li> <li>Hot Reload: Flutter's hot reload feature allows developers to see changes in real-time without restarting the application, significantly speeding up the development process.</li> <li>Rich Widget Library: Flutter provides a comprehensive set of pre-designed widgets that follow both Material Design (for Android) and Cupertino (for iOS) guidelines, enabling developers to create visually appealing UIs.</li> <li>High Performance: Flutter applications are compiled to native code, which ensures high performance and smooth animations.</li> <li>Customizable UI: Flutter's widget-based architecture allows for extensive customization of UI components, enabling developers to create unique designs.</li> <li>Strong Community and Ecosystem: Flutter has a growing community and a rich ecosystem of packages and plugins that extend its functionality.</li> </ul>"},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.1%20Introduction%20to%20Flutter/#the-dart-programming-language","title":"The Dart Programming Language","text":"<p>Flutter uses Dart as its programming language. Dart is an object-oriented, class-based language with a syntax similar to JavaScript and Java.</p> <p></p> <p>It is designed for building high-performance applications and offers features such as:</p> <ul> <li>Ahead-of-Time (AOT) Compilation: Dart can be compiled to native code (machine code), which improves the performance of Flutter applications.</li> <li>Just-in-Time (JIT) Compilation: During development, Dart supports JIT compilation, allowing for features like hot reload.</li> <li>Asynchronous Programming: Dart has built-in support for asynchronous programming using <code>async</code> and <code>await</code>, making it easier to handle tasks like network requests and file I/O.</li> </ul> <p>The Dart language documentation can be found at: https://dart.dev/guides</p>"},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.1%20Introduction%20to%20Flutter/#the-flutter-widgets","title":"The Flutter Widgets","text":"<p>In Flutter, everything is a widget. Widgets are the building blocks of a Flutter application's user interface. They describe what their view should look like given their current configuration and state. There are two main types of widgets:</p> <ul> <li>Stateless Widgets: These widgets do not maintain any state. They are immutable and are rebuilt whenever their configuration changes. Examples include <code>Text</code>, <code>Icon</code>, and <code>RaisedButton</code>.</li> <li>Stateful Widgets: These widgets maintain state that can change over time. They are mutable and can rebuild themselves when their state changes. Examples include <code>Checkbox</code>, <code>TextField</code>, and <code>Slider</code>.</li> </ul> <p>You can learn more about Flutter widgets at: https://flutter.dev/docs/development/ui/widgets</p> <p>In the next table you can see the correspondence between the most common Jetpack Compose composables and their Flutter widget equivalents:</p> Jetpack Compose Composable Flutter Widget Text Text Button ElevatedButton Column Column Row Row Box Container Image Image Scaffold Scaffold TextField TextField LazyColumn ListView Card Card Icon Icon FloatingActionButton FloatingActionButton Modifier BoxDecoration / EdgeInsets / etc. Spacer SizedBox TopAppBar AppBar Snackbar SnackBar"},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.1%20Introduction%20to%20Flutter/#the-widgets-tree","title":"The widgets tree","text":"<p>In Flutter, the user interface is built using a hierarchical structure of widgets, known as the widget tree. Each widget can have child widgets, which in turn can have their own children, forming a tree-like structure. The root of the tree is typically a <code>MaterialApp</code> or <code>CupertinoApp</code> widget, which provides the overall structure and theme for the application.</p> <p>The widget tree is essential for understanding how Flutter builds and renders the UI. When a widget's state changes, Flutter efficiently rebuilds only the affected parts of the widget tree, ensuring optimal performance. </p> <p>For instance, a simple Flutter app might have a widget tree that looks like this:</p> <p></p> <p>Material and Cupertino</p> <p>Flutter provides two sets of design languages: Material Design (used for Android) and Cupertino (used for iOS).</p> <p>The Material design language was created for any platform, not just Android. When you write a Material app in Flutter, it has the Material look and feel on all devices, even iOS. If you want your app to look like a standard iOS-styled app, then you would use the Cupertino library.</p> <p>You can technically run a Cupertino app on either Android or iOS, but (due to licensing issues) Cupertino won't have the correct fonts on Android. For this reason, use an iOS-specific device when writing a Cupertino app.</p>"},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.1%20Introduction%20to%20Flutter/#starting-with-flutter","title":"Starting with Flutter","text":"<p>To start developing with Flutter, you need to set up your development environment. Follow the steps form the official Flutter installation guide</p> <p>Task</p> <ul> <li>Create a new Flutter App project using Android Studio (don't forget to install the Flutter and Dart plugins).</li> <li>Explore the default project structure and identify the main files and directories.</li> <li>Run the default Flutter app on an emulator or physical device to see it in action.</li> <li>Add the plugin Flutter Snipets by George Herbert and try some of the snippets listed in https://github.com/georgeherby/flutter-snippets/blob/master/README.md</li> </ul> <p>The most important files and directories in a Flutter project are:</p> <ul> <li><code>lib/main.dart</code>: The main entry point of the application where the app's execution starts.</li> <li><code>pubspec.yaml</code>: The configuration file for the project, where you can specify dependencies, assets, and other settings.</li> <li><code>analysis_options.yaml</code>: Configuration file for static analysis options.</li> <li><code>android/</code>, <code>ios/</code>, <code>linux/</code>, <code>windows/</code>, <code>web/</code>: Directories containing platform-specific code for each platform, respectively.</li> <li><code>test/</code>: Directory for writing unit and widget tests for the application.</li> </ul>"},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.1%20Introduction%20to%20Flutter/#installing-packages","title":"Installing packages","text":"<p>Flutter uses a package manager called pub to manage dependencies. You can add packages to your project by specifying them in the <code>pubspec.yaml</code> file under the <code>dependencies</code> section. After adding a package, run <code>flutter pub get</code> to install it.</p> <p>Otherwise, you can use the command line to add packages. For example, to add the <code>http</code> package, you would run:</p> <pre><code>flutter pub add http\nflutter pub get\n</code></pre> <p>If we want to add a package only for the developer environment (for example, testing packages), we can add it under the <code>dev_dependencies</code> section:</p> <pre><code>flutter pub add dev:flutter_test\nflutter pub get\n</code></pre> <p>We can specify a particular version of a package by appending the version number:</p> <pre><code>flutter pub add http: ^0.13.0\nflutter pub get\n</code></pre> <p>Here, <code>^0.13.0</code> indicates that we want to use version 0.13.0 or any compatible newer version.</p> <p>Other useful commands are:</p> <ul> <li><code>flutter pub upgrade</code>: Upgrades all the dependencies to the latest versions.</li> <li><code>flutter pub remove &lt;package_name&gt;</code>: Removes a package from the dependencies.</li> <li><code>flutter pub deps</code>: Lists all the dependencies in the project along with their versions.</li> </ul> <p>For search and explore available packages, you can visit the pub.dev website.</p> <p>Task</p> <ul> <li>Do the Codelab Write your first Flutter app</li> <li>Refactor the default Flutter app to separate the app's parts in screens, states and components folders.</li> </ul>"},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.1%20Introduction%20to%20Flutter/#flutter-documentation-and-resources","title":"Flutter Documentation and Resources","text":"<p>Some useful links to learn more about Flutter:</p> <ul> <li>Official Flutter Documentation: https://flutter.dev/docs</li> <li>Flutter learning resources: https://flutter.dev/learn</li> <li>Flutter widget catalog: https://flutter.dev/docs/development/ui/widgets/catalog</li> <li>Flutter YouTube Channel: https://www.youtube.com/flutterdev</li> </ul>"},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.2%20Flutter%20Architecture/","title":"Unit 5.2. Flutter Architecture","text":"<p>In this section, we will explore the architecture of basic Flutter applications, including the Provider state management approach.</p> <p>First of all, we need to review the difference between Stateless and Stateful widgets in Flutter.</p>"},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.2%20Flutter%20Architecture/#flutter-widgets-and-state-management","title":"Flutter widgets and state management","text":"<p>As you can remember from the previous section, there are 2 types of Flutter Widgets, Stateless and Stateful widgets.</p>"},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.2%20Flutter%20Architecture/#stateless-widgets","title":"Stateless Widgets","text":"<p>Stateless widgets are immutable, meaning that their properties cannot change - all values are final. A stateless widget is useful when the part of the user interface you are describing does not depend on anything other than the configuration information in the object itself and the <code>BuildContext</code> in which the widget is inflated.</p> <p>Let's recall the structure of a stateless widget:</p> <pre><code>class myWidget extends StatelessWidget {\nconst myWidget({super.key});\n\n@override\nWidget build(BuildContext context) {\nreturn const Placeholder();\n}\n}\n</code></pre> <p>As the most notable points, we see that it is a class that descends from the <code>StatelessWidget</code> class, has a constructor, and overrides the <code>build</code> method, which defines the appearance of the widget.</p> <p>The lifecycle of this type of widget can be represented as follows:</p> <p></p> <p>The widget's lifecycle begins with its constructor, to which arguments can be provided. Once created, and when it is inserted into the widget tree, the <code>build()</code> method, inherited from <code>StatelessWidget</code>, is invoked, and we will override it to establish its design.</p> <p>Once created, it is not destroyed, but is redrawn by invoking the <code>build()</code> method again whenever necessary, generally when a parent node in the widget tree needs to be redrawn.</p>"},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.2%20Flutter%20Architecture/#stateful-widgets","title":"Stateful Widgets","text":"<p>The structure of a stateful widget is as follows:</p> <pre><code>class myWidget extends StatefulWidget {\nconst myWidget({super.key});\n\n@override\nState&lt;myWidget&gt; createState() =&gt; _myWidgetState();\n}\n\nclass _myWidgetState extends State&lt;myWidget&gt; {\n@override\nWidget build(BuildContext context) {\nreturn const Placeholder();\n}\n}\n</code></pre> <p>We see that it is a Stateful widget because it descends from the <code>StatefulWidget</code> class, which indicates that it contains a mutable state. The constructor, like stateless widgets, in order to be referenced within the widget tree, will also have a key property.</p> <p>This class overrides the <code>createState()</code> method of the <code>StatefulWidget</code> class. This method is invoked by the framework when the widget is inserted into the widget tree for the first time, creating an instance of the state <code>_myWidgetState</code>. With this, every time the widget is redrawn, the framework will reuse this instance so that the state is not lost.</p> <p>We could therefore represent the lifecycle of a stateful widget very similarly to a stateless widget:</p> <p></p> <p>The state of the widget, on the other hand, is defined as a class descending from <code>State</code>, and it is here where we override the <code>build</code> method to construct the widget.</p> <p>This state, as we have commented, is mutable, and therefore has a more complex lifecycle. Let's look at this lifecycle and its relationship with the lifecycle of the widget it is associated with:</p> <p></p> <p>Let's contrast both lifecycles:</p> <p>Lifecycle of the Stateful Widget</p> <ol> <li>The lifecycle of the stateful widget begins by invoking its constructor.</li> <li>The <code>createState</code> method is invoked to create the associated state, so the state now begins its own lifecycle.</li> </ol> <p>Lifecycle of the State</p> <ol> <li>The lifecycle of the state begins with the invocation of its constructor via the <code>createState</code> method of the associated widget. Since the widget is not yet in the tree, we should not perform initializations here that depend on the context (Remember that the build context is determined by the widget's position in the tree).</li> <li>The <code>initState</code> method is launched, where operations for initializing data are generally carried out, or this data is obtained from external sources, such as a database or the network. When we override this method, we must invoke the constructor of its superclass, so that it performs initialization tasks. This method will be executed only once.</li> <li>The <code>didChangeDependencies</code> method is invoked once, immediately after <code>initState</code>. This method will be launched again only when some initialization involving a widget of type <code>InheritedWidget</code> needs to be done. At this point, Flutter marks this widget with the flag <code>dirty=true</code>, to indicate that it needs to be rebuilt.</li> <li>If a rebuild of the widget is needed (<code>dirty=true</code>), the <code>build()</code> method is invoked to determine the widgets that our widget will have to render. After this, the state is marked as clean, with <code>dirty=false</code>.</li> </ol> <p>At this point, we already have the widget inserted into the tree and rendered according to its state, so the widget is considered clean. From this moment on, several things can happen that set this flag back to <code>dirty</code> and imply a rebuild of it:</p> <ul> <li>5a.  If an event occurs (like a button tap) that modifies the state, the <code>setState()</code> method is invoked, which marks the state as <code>dirty=true</code> again, so that it is rebuilt in the <code>build</code> method, providing it with the updated state.</li> <li>5b.  If a parent widget requests that its descendants be rebuilt and this involves the widget in question, the <code>didUpdateWidget</code> method is invoked, providing it with the previous widget as an argument and marking the state as dirty, so that it is rebuilt again.</li> <li>5c.  If the widget depends on an <code>InheritedWidget</code> and this inherited widget changes, the <code>didChangeDependencies</code> method is invoked, also rebuilding the widget. Inherited widgets are a third type of widget that allows a descendant widget to directly access its state, without needing to go up the widget tree to reach it.</li> <li>6.  If the widget will no longer be used, <code>dispose()</code> is invoked to destroy it. In this method, animations should be stopped, connections closed, etc.</li> </ul>"},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.2%20Flutter%20Architecture/#navigation","title":"Navigation","text":"<p>Flutter provides a complete system for navigating between screens and handling deep links. Small applications without complex deep linking can use <code>Navigator</code>, while apps with specific deep linking and navigation requirements should also use the <code>Router</code> to correctly handle deep links on Android and iOS, and to stay in sync with the address bar when the app is running on the web. </p> <p>Deep Links</p> <p>Deep links are links that not only open an app, but also take the user to a specific location \"deep\" inside the app. For example, a deep link could take the user directly to a specific product page in a shopping app, rather than just opening the app's home screen.</p>"},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.2%20Flutter%20Architecture/#simple-navigation","title":"Simple Navigation","text":"<p>Navigation between different screens in a Flutter application is typically managed using the <code>Navigator</code> class, which maintains a stack of routes (screens).</p> <p>Terminology</p> <p>In Flutter, screens and pages are called routes. </p> <p>The Navigator widget displays screens as a stack using the correct transition animations for the target platform. To navigate to a new screen, access the <code>Navigator</code> through the route's <code>BuildContext</code> and call imperative methods such as <code>push()</code> or <code>pop()</code>:</p> <pre><code>ElevatedButton(\nonPressed: () {\nNavigator.push(\ncontext,\nMaterialPageRoute(builder: (context) =&gt; SecondScreen()),\n);\n},\nchild: Text('Go to Second Screen'),\n);\n</code></pre> <p>The Navigator class also provides methods for more complex navigation scenarios, such as replacing the current route, removing routes from the stack, and more:</p> <ul> <li><code>pop()</code>: Removes the top route from the stack, returning to the previous screen.</li> <li><code>pushReplacement()</code>: Replaces the current route with a new one.</li> <li><code>popUntil()</code>: Pops routes until a specified condition is met.</li> <li><code>pushAndRemoveUntil()</code>: Pushes a new route and removes routes until a specified condition is met.</li> <li><code>pushReplacement()</code>: Replaces the current route on the top of the stack with a new one.</li> <li><code>replace()</code>: Replaces a route on the stack with a new one.</li> <li><code>replaceRouteBelow()</code>: Replaces a route below another route in the stack.</li> </ul> <p>Some examples:</p> <pre><code>// Pop the current route off the stack\nNavigator.pop(context);\n\n// Replace the current route with a new one\nNavigator.pushReplacement(\ncontext,\nMaterialPageRoute(builder: (context) =&gt; NewScreen()),\n);\n\n// Pop routes until a specific condition is met\nNavigator.popUntil(context, ModalRoute.withName('/home'));\n\n// Replace a route with a new one\nRoute oldRoute = ...;\nRoute newRoute = ...;\n\nNavigator.replace(\ncontext,\noldRoute: oldRoute,\nnewRoute: newRoute,\n);\n</code></pre> <p>In the next example, we can see a simple Flutter application with two screens and navigation between them using the <code>Navigator</code> class:</p> <pre><code>import 'package:flutter/material.dart';\n\nvoid main() {\nrunApp( MyApp());\n}\n\nclass MyApp extends StatelessWidget {\nconst MyApp({super.key});\n\n@override\nWidget build(BuildContext context) {\nreturn  MaterialApp(\ntitle: 'Sample',\ntheme: ThemeData(\ncolorScheme: ColorScheme.fromSeed(seedColor: Colors.lightGreen),\n),\nhome: FirstRoute(),\n);\n}\n}\n\nclass FirstRoute extends StatelessWidget {\nconst FirstRoute({super.key});\n\n@override\nWidget build(BuildContext context) {\nreturn Scaffold(\nappBar: AppBar(title: const Text('First Route')),\nbody: Center(\nchild: ElevatedButton(\nchild: const Text('Open route'),\nonPressed: () {\n// Navigate to second route when tapped.\n},\n),\n),\n);\n}\n}\n\nclass SecondRoute extends StatelessWidget {\nconst SecondRoute({super.key});\n\n@override\nWidget build(BuildContext context) {\nreturn Scaffold(\nappBar: AppBar(title: const Text('Second Route')),\nbody: Center(\nchild: ElevatedButton(\nonPressed: () {\n// Navigate back to first route when tapped.\n},\nchild: const Text('Go back!'),\n),\n),\n);\n}\n}\n</code></pre> <p>To navigate from the first route to the second route, we can use the <code>Navigator.push</code> method in the <code>onPressed</code> callback of the button in the <code>FirstRoute</code> class:</p> <pre><code>// Within the `FirstRoute` widget:\nonPressed: () {\nNavigator.push(\ncontext,\nMaterialPageRoute(\nbuilder: (context) =&gt; const SecondRoute(),\n),\n);\n}\n</code></pre> <p>To return to the first route from the second route, we can use the <code>Navigator.pop</code> method in the <code>onPressed</code> callback of the button in the <code>SecondRoute</code> class:</p> <pre><code>// Within the SecondRoute widget\nonPressed: () {\nNavigator.pop(context);\n}\n</code></pre>"},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.2%20Flutter%20Architecture/#design-patterns","title":"Design patterns","text":"<p>Flutter applications can be structured using various design patterns to manage complexity and improve maintainability. Some common design patterns used in Flutter development include:</p> <ul> <li>Provider Pattern: This pattern uses the <code>provider</code> package to manage state and dependencies in a Flutter application. It allows widgets to access shared data and services without tight coupling.</li> <li>BLoC (Business Logic Component) Pattern: This pattern separates business logic from the UI by using streams to manage state. It promotes a reactive programming model and helps in creating testable and maintainable code.   More info about the BLoC pattern can be found here.   </li> <li>MVVM (Model-View-ViewModel) Pattern: This pattern separates the UI (View) from the business logic (ViewModel) and data (Model). It allows for better separation of concerns and easier testing. You can see an example of the MVVM pattern applied to Flutter here. </li> </ul>"},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.2%20Flutter%20Architecture/#the-provider-pattern","title":"The Provider Pattern","text":"<p>The Provider Pattern is a widely used design pattern in Flutter for state management and dependency injection. It leverages the <code>provider</code> package to make data and services available to widgets throughout the widget tree without tight coupling.</p> <p>Info</p> <p>Provider is based on the <code>InheritedWidget</code> mechanism, which allows data to be efficiently propagated down the widget tree. It simplifies the process of sharing state and dependencies between widgets, making it easier to manage complex applications. </p> <p>The key concepts of the Provider Pattern include:</p> <ul> <li>Providers: These are classes that extend <code>ChangeNotifier</code> or other provider types (like <code>FutureProvider</code>, <code>StreamProvider</code>, etc.) to hold and manage state or services. They notify listeners when the state changes.</li> <li>Consumers: Widgets that listen to changes in the provider and rebuild themselves when the provider notifies them of changes. The <code>Consumer</code> widget or the <code>Provider.of&lt;T&gt;(context)</code> method can be used to access the provider's data.</li> <li>ChangeNotifierProvider: A specific type of provider that listens to a <code>ChangeNotifier</code> and rebuilds dependent widgets when notified of changes.</li> <li>MultiProvider: A widget that allows multiple providers to be created and made available to the widget tree.</li> </ul> <p>```mermaid graph TD     A[MyApp     ChangeNotifierProvider] --&gt; B[Widget1 Consumer]     A --&gt; C[Widget2     Provider.of]     C --- D([Provider      ChangeNotifier])     D -.-&gt; A</p>"}]}