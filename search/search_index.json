{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Multimedia and mobile device programming - 2DAM","text":""},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/","title":"Unit 01. Introduction to Mobile Development","text":""},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#1-mobile-devices","title":"1. Mobile Devices","text":"<p>We live in a hyper-connected society where we are permanently online thanks to mobile devices. These devices have evolved from being simple communication tools to becoming authentic personal assistants that help us in our daily lives.</p> <p>The evolution of mobile devices has been spectacular, from the first mobile phones that only allowed voice calls and SMS to the current smartphones, which are authentic pocket computers with which we can surf the internet, play multimedia content, play video games, take high-quality photos and videos, geolocate ourselves, etc.</p> <p>This evolution has been possible thanks to the development of hardware (processors, memory, screens, batteries, sensors, etc.) and software (operating systems and applications).</p> <p>IBM Simon</p> <p>The first true smartphone was the IBM Simon, manufactured in 1992 and distributed in the United States between 1994 and 1995.</p> <p></p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#11-types-of-mobile-devices","title":"1.1 Types of Mobile Devices","text":"<p>There are different types of mobile devices, the most common being:</p> <ul> <li> <p>Mobile Phones / Smartphones: They are the most common and popular. They have a touch screen and an operating system (Android, iOS) that allows the installation of applications (apps) that expand their functionalities.</p> </li> <li> <p>Tablets: They are devices with a screen size larger than that of a smartphone but smaller than that of a laptop. They are ideal for consuming multimedia content (videos, books, magazines, internet browsing) and are widely used in the educational field.</p> </li> <li> <p>Wearables: They are devices that can be worn on the body. The most common are smartwatches and smartbands (or activity bands). They are usually companions to the smartphone and are used to monitor physical activity, receive notifications, control music playback, etc.</p> </li> <li> <p>Cars (Smart/Connected Cars): Modern vehicles are now mobile computing platforms with internet access, operating systems, and app support, enabling connectivity with phones, other cars, and infrastructure.</p> </li> <li> <p>ChromeOS Devices (Chromebooks): These are lightweight, portable laptops and tablets that primarily rely on web and cloud-based applications, with added support for Android and Linux software.</p> </li> <li> <p>TVs (Smart TVs): Traditional televisions enhanced with integrated operating systems and internet connectivity, allowing users to stream content, browse the web, and interact with other smart devices.</p> </li> <li> <p>XR (Extended Reality): An umbrella term for immersive technologies, including:</p> <ul> <li>VR (Virtual Reality): Fully digital, immersive experiences using headsets.</li> <li>AR (Augmented Reality): Digital overlays on the real world, viewed via smartphones or glasses.</li> <li>MR (Mixed Reality): Advanced AR where digital and physical objects interact in real time.</li> </ul> </li> <li> <p>E-book readers: Devices designed specifically for reading digital books. They use electronic ink technology (e-ink), which mimics the appearance of paper and is much less tiring for the eyes than a conventional screen. Their autonomy is very high.</p> </li> </ul> <p></p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#12-characteristics-of-mobile-devices","title":"1.2 Characteristics of Mobile Devices","text":"<p>The main characteristics that define a mobile device are:</p> <ul> <li>Mobility: Its small size and weight, together with its wireless connectivity, allow it to be used anywhere.</li> <li>Wireless Connectivity: They can connect to the internet and other devices without cables, mainly through Wi-Fi and mobile data networks (3G, 4G, 5G). They also usually have other types of wireless connectivity such as Bluetooth, NFC, or GPS.</li> <li>Touch Screen: They are the main input and output element. Interaction is done through gestures (tap, double-tap, drag, pinch, etc.).</li> <li>Sensors: They incorporate numerous sensors that allow them to interact with the environment:<ul> <li>Accelerometer: Measures acceleration and tilt.</li> <li>Gyroscope: Measures orientation and rotation.</li> <li>Magnetometer: Digital compass that detects magnetic north.</li> <li>GPS: Determines the geographic location.</li> <li>Light Sensor: Adjusts screen brightness automatically.</li> <li>Proximity Sensor: Detects if the device is close to an object (e.g., turns off the screen during a call).</li> <li>Fingerprint Sensor / Face Recognition: For device unlocking and authentication.</li> </ul> </li> <li>Autonomy: They have a battery that allows them to operate for a certain time without being connected to the electrical grid. Autonomy is a key factor.</li> <li>Applications (Apps): Their functionality is extended by installing applications downloaded from official stores (Google Play, App Store) or other sources.</li> </ul>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#13-hardware-of-a-mobile-device","title":"1.3 Hardware of a Mobile Device","text":""},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#the-processor-and-the-soc","title":"The Processor and the SoC","text":"<p>A mobile device contains essentially the same hardware as a computer, but with a different architecture, as they are constrained by the device's smaller size. Therefore, when we talk about the processor in a mobile device, we must talk about the SoC or System on a Chip, an integrated circuit that combines different parts of the system, such as the CPU itself, the GPU (graphics processor), RAM, ROM, and USB or Wi-Fi controllers.</p> <p>It is worth highlighting the importance of the British company ARM Holdings in the world of mobile processors. It is the creator of the architecture of the same name, ARM (Advanced RISC Machines), a 32- and 64-bit RISC (Reduced Instruction Set Computer) architecture that is present in the majority of mobile devices.</p> <p></p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#ram-memory","title":"RAM Memory","text":"<p>The type of RAM memory found inside the SoC is dynamic (DRAM), which requires periodic refreshing and is very fast. To reduce energy consumption and minimize heating, this RAM is placed close to the CPU and GPU. This RAM is shared by both units.</p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#screens-on-mobile-devices","title":"Screens on Mobile Devices","text":"<p>One of the defining characteristics of smartphones is the screen, through which most of the interaction with the device takes place.</p> <p>There are primarily two types of technologies, with different variations and generations:</p> <ul> <li> <p>LCD or Inorganic: Liquid Crystal Display, which lets light pass through based on its polarity, just like computer monitors. For this, they have a backlight panel located behind the display, which can be made of fluorescent lights or LEDs. Within this type, we find TFT, LED, IPS, PLS, or Apple's Retina displays.</p> </li> <li> <p>OLED or Organic: These use organic materials that emit light by themselves when electricity is applied, meaning they do not need a backlight panel and can turn individual pixels on or off independently. These are thinner screens than LCDs, as they have fewer layers, with lower consumption, higher contrast, and greater brightness. Furthermore, this manufacturing technology allows panels to be flexible, leading to mobile phones with foldable or rollable screens. Within this family, we find AMOLED, Super AMOLED, or Dynamic AMOLED screens.</p> </li> </ul> <p></p> <p>Apart from the screen manufacturing technology, it is important to know some other characteristics about them.</p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#resolution-and-density","title":"Resolution and Density","text":"<p>The screen resolution refers to the number of pixels displayed on it and is determined by the number of pixels in the horizontal and vertical directions.</p> <p>From the resolution, we can determine the aspect ratio and the density of pixels per inch (ppi). This density is a measure that relates the size of the screen to its resolution. Two screens of different sizes with the same resolution will have different densities, and therefore, different image quality. Ideally, this density should be greater than 300 or 400 ppi.</p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#aspect-ratio","title":"Aspect Ratio","text":"<p>This is the relationship between the width and height of the screen. Traditionally, this ratio has followed the widescreen 16:9 format (for every 16 pixels in width, there are 9 in height). For example, the 1920x1080 format fulfills this proportion.</p> <p>However, a few years ago, the 18:9 (and even 19:9) ratio began to become popular, aimed at larger panels with almost no bezels. This ratio allows a device to be less wide than another with the same diagonal in a 16:9 format, thereby improving its ergonomics.</p> <p></p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#cameras","title":"Cameras","text":"<p>One of the components that is most often demanded in a mobile device is the photographic camera or cameras. These are mainly composed of:</p> <ul> <li>An optical block, which is relatively limited, although some devices allow for the connection of an external lens, and</li> <li>A sensor, composed of an array of photoreceptors, which translate light signals into electrical ones, thus obtaining the value for each point in the image.</li> </ul> <p>Over time, mobile devices have incorporated more cameras, besides the front and rear ones, so that currently we can find three, four, or even five cameras (telephoto, wide-angle, monochromatic, or even infrared).</p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#sensors","title":"Sensors","text":"<p>Mobile devices can incorporate a wide variety of sensors, with which we can obtain very diverse information from our environment. Among the sensors we can find in a mobile device, the following stand out:</p> <ul> <li> <p>GPS (Global Positioning System): Provides location services by using a continuous signal to GPS satellites, allowing it to show where on the planet we are. This device opens up a whole range of possibilities such as LBS or Location-Based Services.</p> </li> <li> <p>Accelerometer and Gyroscope: The gyroscope measures the device's movements thanks to angular acceleration, even allowing the detection of small rotations, making it very suitable for, for example, augmented reality applications. On the other hand, the accelerometer is less precise and allows detection of the device's position relative to the three axes: x, y, and z. With this, we can determine, for example, if the device is in a horizontal or vertical position, as well as detect turns, vibrations, tilt, or collisions.</p> </li> <li> <p>Light Sensor: Allows the detection of ambient light, so the device can adjust the screen brightness to adapt to different lighting conditions.</p> </li> <li> <p>Proximity Sensor: Allows the detection of the distance from the device to other objects through an infrared LED, and enables, for example, the screen to turn off when we bring it close to our face during a call.</p> </li> </ul> <p>In addition to these, we can find many others, such as biometric sensors (fingerprint or iris readers), magnetometer, barometer, capacitive sensors, infrared sensor, heart rate sensor, color spectrum sensor, or pedometer.</p> <p></p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#14-operating-systems-os","title":"1.4 Operating Systems (OS)","text":"<p>The OS is the most important software that manages the device's hardware and allows applications to run. The most common are:</p> <ul> <li> <p>Android: Developed by Google. It is the most used OS in the world. It is an open-source system, which allows manufacturers to adapt it to their devices.</p> </li> <li> <p>iOS: Developed by Apple. It is exclusively used on the company's devices (iPhone, iPad). It is a closed-source system, known for its security, performance, and integration with the Apple ecosystem.</p> </li> <li>Others: HarmonyOS (Huawei), etc.</li> </ul> <p></p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#15-applications-apps","title":"1.5 Applications (Apps)","text":"<p>Applications are programs designed to perform specific tasks on mobile devices. There are applications for almost everything: social networks, messaging, email, photography, music, video, maps, banking, news, games, etc.</p> <p>They are mainly downloaded from official stores:</p> <ul> <li> <p>Google Play Store (for Android).</p> </li> <li> <p>App Store (for iOS).</p> </li> </ul> <p>Mobile devices have countless uses, among which we can highlight:</p> <ul> <li>Communication: Calls, video calls, instant messaging (WhatsApp, Telegram), email, social networks (Instagram, TikTok, X - Twitter).</li> <li>Information: Internet browsing, reading news, consulting Wikipedia.</li> <li>Entertainment: Listening to music (Spotify), watching videos (YouTube, Netflix), playing games.</li> <li>Photography and Video: Taking photos, recording videos, editing them, and sharing them.</li> <li>Navigation and Maps: Geolocation, GPS navigation (Google Maps), searching for nearby places.</li> <li>E-commerce: Online shopping, banking applications, payment with the mobile phone (NFC).</li> <li>Productivity: Calendar, notes, document editing, task management.</li> <li>Health and Sports: Monitoring physical activity, counting steps, measuring heart rate.</li> </ul>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#16-technologies-for-mobile-application-development","title":"1.6 Technologies for Mobile Application Development","text":"<p>Developing an application that runs natively on a specific operating system requires using its native technologies. However, to minimize the need for platform-specific development, several technologies exist that aim to enable cross-platform development in the broadest sense. These range from responsive web applications to compiled applications, including hybrid or progressive web applications (PWAs), each with its own advantages and disadvantages.</p> <p>Let's look at each of them, categorized by their distance from or closeness to native code.</p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#webapps-or-responsive-web-applications","title":"WebApps or Responsive Web Applications","text":"<p>These are applications based on web technologies: HTML, CSS, and JavaScript. They require only a web browser to run. Being \"responsive\" means their interface adapts to any device. For this type of application, no native code development is necessary, and they are entirely cross-platform because they run on the operating system's own web browser. Therefore, we have a single codebase that runs on all platforms. The main disadvantage is that they do not offer as good a user experience as native apps and do not allow access to all of the system's components.</p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#hybrid-applications","title":"Hybrid Applications","text":"<p>These use the trio of HTML, CSS, and JavaScript to build a website that is loaded within a WebView component\u2014essentially a browser without the navigation bar or other options\u2014giving it the appearance of a native application. This type of application can access some device features, like location or the accelerometer, through this component. Currently, the most popular framework for developing hybrid applications is Ionic, which allows development using other web frameworks like React, Angular, or Vue. </p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#progressive-web-applications-pwas","title":"Progressive Web Applications (PWAs)","text":"<p>Closer to native applications are Progressive Web Applications (PWAs), which are revolutionizing the current landscape. These applications incrementally enhance their functionalities based on the mobile device they run on, to leverage more potential. They can access hardware, work offline or with poor connectivity, and offer system notifications. There are numerous frameworks for PWA development, including React PWA Library, Angular PWA Framework, Vue PWA Framework, Ionic PWA Framework, Svelte, PWA Builder, and Polymer.</p> <p></p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#compiled-applications","title":"Compiled Applications","text":"<p>These are technologies that aim to use a single programming language to generate mobile applications into the native code of each platform. Some of the most widely used technologies in this category are:</p> <ul> <li> <p>React Native and NativeScript: They use JavaScript as their base programming language. However, instead of building interfaces with HTML, they use the framework's own components, which are compiled to native code, making the use of a WebView as an intermediary unnecessary.</p> </li> <li> <p>Flutter: Developed and maintained by Google, Flutter allows for cross-platform application development using the Dart language, which compiles to native code that runs entirely on the device. Flutter's way of working involves designing user interfaces using widgets, integrated directly into the code. Flutter comes with a set of predefined widgets, such as buttons, navigation bars, etc.</p> </li> <li> <p>Kotlin Multiplatform and Compose Multiplatform: With Kotlin Multiplatform, we can share code between various platforms (Android, iOS, web, etc.) using Kotlin as the programming language. This means we can write an application's logic once and reuse it on different platforms, reducing development time and effort. With Compose Multiplatform, a technology based on Jetpack Compose, we can create shared user interfaces for Android, iOS, desktop, and web using Kotlin. This facilitates the creation of consistent and reusable user interfaces across various platforms.</p> </li> </ul> <p>The Most Popular Development SDKs</p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#programming-for-ios","title":"Programming for iOS","text":"<p>To program for iOS (iPhone, iPad, Apple Watch, etc.), you\u2019ll need a mix of hardware, software, and knowledge. Here\u2019s a clear breakdown:</p> <p>Hardware</p> <ul> <li>Mac computer (MacBook, iMac, Mac Mini, etc.)   iOS development officially requires macOS.</li> <li>iOS device (optional but recommended)   You can test apps in the simulator, but real device testing is important.</li> </ul> <p>Software</p> <ol> <li> <p>Xcode (free, from the Mac App Store)</p> </li> <li> <p>Apple\u2019s official IDE (Integrated Development Environment).</p> </li> <li> <p>Includes editor, compiler, debugger, Interface Builder (UI designer), and the iOS Simulator.</p> </li> <li> <p>iOS SDK (comes with Xcode)</p> </li> <li> <p>Provides APIs, frameworks (UIKit, SwiftUI, Core Data, ARKit, etc.), and tools needed for building iOS apps.</p> </li> <li> <p>Apple Developer Account (optional at first, required for publishing)</p> </li> <li> <p>Free: lets you learn, run apps on simulator.</p> </li> <li>Paid (\\$99/year): required to publish to the App Store and to install apps on your physical iPhone.</li> </ol> <p>Programming Languages</p> <ul> <li>Swift Apple\u2019s modern language, recommended for all new projects.</li> <li>Objective-C older language, still used in legacy apps and some libraries.</li> </ul>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#17-trends-and-future","title":"1.7 Trends and Future","text":"<p>The future of mobile devices points towards:</p> <ul> <li>5G Connectivity: Much higher speed and lower latency, enabling new applications.</li> <li>Folding screens and new formats.</li> <li>Augmented Reality (AR) and Virtual Reality (VR): More integrated into mobile devices.</li> <li>Artificial Intelligence (AI): Integrated into the device to improve photography, battery management, and personalize the user experience.</li> <li>More and better sensors.</li> <li>Greater integration with other devices (Internet of Things - IoT): Controlling the home, the car, etc., from the smartphone.</li> </ul>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#2-introduction-to-android-development","title":"2. Introduction to Android development","text":"<p>As we saw previously, there are different technologies for mobile application development.</p> <p>In the next units, we will focus on native applications for the Android operating system, maintained by Google and based on the Linux kernel.</p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#21-origins-of-android","title":"2.1 Origins of Android","text":"<p>The origins of Android lie with the Palo Alto (California) company Android Inc., founded in 2003 by Andy Rubin. This company began by developing an operating system for digital cameras, but due to the sector's low profitability, they decided to pivot to mobile devices, a market then dominated by Symbian and Windows Mobile. In 2005, Google acquired Android Inc., and two years later, alongside the creation of the Open Handset Alliance\u2014a consortium of various technology companies aimed at developing open standards for mobile devices\u2014the first version of Android, Apple Pie, was announced. This version began to be incorporated into devices in 2008, and two years later, it captured nearly half of the market share.</p> <p></p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#22-the-android-operating-system","title":"2.2 The Android Operating System","text":"<p>Android is the most widely used operating system for mobile devices today. As we know, it is an operating system for touch-screen devices based on the Linux kernel and other open software standards.</p> <p>Android is developed as open source software, meaning both its source code and its issue tracker are accessible. The Android Open Source Project (https://source.android.com/) contains the Android source code, released under the Apache license.</p> <p>In June 2025, the latest version of Android, Android 16, was launched. Since its first version, it has continuously incorporated updates and new functionalities into the system. Furthermore, the ease it provides for application development has resulted in a large community of developers, whose work has produced over three million apps on the Google Play Store, the official Android application repository.</p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#23-characteristics","title":"2.3 Characteristics","text":"<p>Some of the most relevant characteristics of Android are:</p> <ul> <li>Adaptable to a wide variety of screen sizes and resolutions, with support for 2D and 3D graphics libraries based on OpenGL.</li> <li>Natively supports multi-touch screens.</li> <li>Offers local storage through a lightweight database, SQLite.</li> <li>Supports a wide range of connectivity technologies.</li> <li>Includes a web browser based on the WebKit rendering engine and the V8 JavaScript engine from Google Chrome.</li> <li>Native applications are programmed with Java or Kotlin and are compiled for the ART (Android Runtime) virtual machine.</li> <li>Incorporates support for a wide variety of multimedia formats and streaming.</li> <li>Supports a vast array of hardware devices and sensors.</li> <li>Features a very extensive catalog of applications through the Google Play service.</li> </ul>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#24-android-versions","title":"2.4 Android Versions","text":"<p>Android has undergone a significant transformation since its first versions. As a summary, we will look at some characteristics of the most relevant updates.</p> <p>The system began its journey in 2008 with versions 1.0 and 1.1, which included apps like Gmail, Maps, Calendar, and YouTube. It was in version 1.5, Cupcake, that a version name was introduced, and a large number of interface improvements were included, such as the on-screen keyboard, which allowed devices to eliminate physical keyboards. Subsequently, with version 1.6, Donut, the system began to adapt to different screen sizes and resolutions.</p> <p>Versions 2.0 and 2.2 (Eclair and Froyo) introduced aspects like voice-guided navigation, real-time traffic information, and the bottom dock. Version 3.0, Honeycomb, was launched specifically for larger devices, like tablets, and in version 4.0, Ice Cream Sandwich, in 2011, this new interface, Holo, was unified for tablets and smartphones, thus entering the era of modern design.</p> <p>But the biggest change was yet to come with versions 5.0 and 5.1, Lollipop, in 2014. Google reinvented Android in what is perhaps the most important update to the system, introducing the Material Design standard\u2014a set of design specifications affecting the operating system, the web, and apps. With Material, flat color designs were introduced to give weight and depth to different interface elements using shadows, layers, or animations.</p> <p>Subsequent versions included some interface improvements, such as split-screen mode in Android 7.0/7.1 (Nougat) and the picture-in-picture floating window in Android 8/8.1 (Oreo). With Android 10, the dessert-based version code names were abandoned, and some aspects of the interface were reinvented regarding gestures and the navigation system.</p> <p>In Android 11, in 2020, substantial changes to privacy arrived, allowing users to grant apps temporary permissions to access location, camera, or microphone only when required, instead of permanently during installation.</p> <p>And in 2021, Android 12 arrived, representing the biggest update since Android 5.0, with the introduction of Material You, which allows for system design personalization to automatically adjust to the user's settings. This means, for example, that the theme's color palette adapts to the user's chosen wallpaper. Additionally, under the hood, it offers a simpler and more granular way to control how apps access our data through the new privacy dashboard.</p> <p>In August 2022, Android 13 (Tiramisu) appeared, evolving Material You and presenting improvements in security, audio, and integration with other Google products. Android 14 (Upside Down Cake), in October 2023, incorporated improvements in customization, privacy, and accessibility.</p> <p>In September 2024, the launch of Android 15 is expected, bringed improvements to the user interface, security, and performance.</p> <p>The last release is Android 16, in June 2025. Android 16's major updates include a new \"Material 3 Expressive\" UI with advanced animations and blur effects, a desktop mode for tablets, and an expanded Linux terminal to run full desktop applications. It also enhances privacy with features like Notification Cooldown and introduces improved media sharing via Bluetooth LE Audio.</p> <p></p> <p>Android versions</p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#25-android-architecture","title":"2.5 Android Architecture","text":"<p>The Android architecture is composed of a stack of layers, based on the Linux kernel, and is adapted to a wide variety of devices. The different components of the system are shown in the following figure:</p> <p></p> <p>Original at: https://developer.android.com/guide/platform</p> <p>We can see the following components:</p> <ul> <li> <p>System Applications: These form the base system and include the email client, calendar, SMS application, Maps, camera app, browser, contacts app, dialer, among others.</p> </li> <li> <p>Application Framework (Java API Framework): Offers applications access to all Android functions, as well as the ability to publish and securely offer their functionalities to others. All this is designed to simplify the reuse of system components and modular services. Among these services we can find:</p> <ul> <li>An enriched view system for building the user interface,</li> <li>A resource manager, to access application resources such as translations, images, or layout files,</li> <li>A notification manager, to display alerts in the status bar,</li> <li>An activity manager, to manage the application lifecycle and handle navigation,</li> <li>Content providers, so that applications can access data provided by other applications.</li> </ul> </li> <li> <p>C/C++ Libraries: These are libraries used by some system components, offered to developers through the Application Framework. Some of these libraries include the standard C library, 3D graphics libraries, multimedia libraries, or the SQLite database.</p> </li> <li> <p>Android Runtime: Includes the ART virtual machine itself and the core Java libraries. Apps run their own processes as instances of the ART virtual machine, following the process virtualization paradigm (similar to the JVM for PC). The executables for this virtual machine are in DEX format, a bytecode specifically designed for Android and optimized to occupy minimal memory space.</p> </li> <li> <p>Hardware Abstraction Layer (HAL): Consists of a series of library modules for the different hardware components of the device, such as the camera or sensors, and offers an interface to the upper layers to facilitate access to them.</p> </li> <li> <p>Linux Kernel: This is the foundation of the Android platform, providing it with basic system functionalities such as process management, memory management, networking, drivers, and security.</p> </li> </ul>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#26-apps-for-android","title":"2.6 Apps for Android","text":"<p>Android applications are natively programmed in Kotlin or Java and are compiled by the Android SDK, along with data and resource files (interfaces, images, etc.), to generate an <code>.apk</code> file. This file contains the application itself and the information Android needs for its installation.</p> <p>Android implements the principle of least privilege in applications, which provides a certain level of security. This principle is based on:</p> <ul> <li>Android is a multi-user operating system, as it is based on Linux. The peculiarity is that for Android, each application is a different user.</li> <li>Each app has a user ID known only to the system, which establishes the necessary permissions for it to access its resources.</li> <li>Each process has its own virtual machine, so its code runs independently. In principle, each app will have its own process.</li> </ul> <p>With this, each application only has access to the components it needs. However, an application can share data with other applications and access system services, either by having two applications share the same user ID or by requesting user permission to access device data and resources (camera, microphone, Bluetooth connection, SD card, contacts, etc.).</p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#27-api-levels-compatibility-libraries-and-jetpack","title":"2.7 API Levels, Compatibility Libraries, and Jetpack","text":"<p>We have seen how different versions of Android introduce substantial changes in terms of operation and features. For developers, more than the version, we are interested in the API levels. These levels determine the compatibility of applications with Android versions. With each new version of the system, one or more API levels are introduced, which determine which device functionalities will be available to us.</p> <p>Info</p> <p>Android 16 is API level 36.</p> <p>When we start developing an Android application, we must consider which API functionalities we will need and establish the minimum level that our application will require. For example, if we develop an application that we want to follow Material Design standards, we must use a minimum API level 21, which was introduced in Android 5.0. Or if we desire functionalities present in Android 11 or 12, we must use API levels 30 and 31, respectively.</p> <p>To provide new functionalities or use equivalent functionalities in earlier versions of Android, Google launched a compatibility layer through Support Libraries. Currently, these libraries are integrated into Android Jetpack, a set of libraries that allows developers to focus on application logic and follow recommended practices, reducing boilerplate code and producing consistent code across different system versions.</p> <p>Jetpack Compose</p> <p>Traditionally, the design of native user interfaces has used XML files, which must be injected and manipulated from the source code.</p> <p>With Jetpack Compose, a more modern toolkit for interface development is introduced, following a declarative model. This means we describe the state of the interface, and Compose takes care of the rest, simplifying the code and making it more maintainable and reusable.</p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#3-android-studio","title":"3. Android Studio","text":"<p>Android Studio is the official IDE for Android development, based on JetBrains' IntelliJ IDE. Until 2014, Eclipse with the Android Development Tools (ADT) plugin was used.</p> <p>The main characteristics of Android Studio are:</p> <ul> <li>It is a cross-platform IDE (Windows, Linux, macOS)</li> <li>It is distributed under the Apache 2.0 license (free),</li> <li>It uses Gradle for building packages,</li> <li>It includes a series of templates for common application layouts,</li> <li>It allows Android-specific code refactoring,</li> <li>It offers support for development on different devices: smartphones, tablets, televisions, or wearables,</li> <li>It incorporates the Device Manager component, which allows creating and managing virtual Android devices to run, debug applications, or analyze performance, as well as linking physical devices to our development environment,</li> <li>It includes support for Google Cloud Platform, enabling integration with various Google services.</li> </ul>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#31-device-manager","title":"3.1 Device Manager","text":"<p>The built-in Device Manager in Android Studio allows us to create and manage virtual Android devices, as well as link physical devices to our development environment.</p> <p>We must keep in mind that the architecture and system for which we develop our applications are different from those of our development machine, not to mention that we can also create applications for a wide range of devices.</p> <p>For testing and debugging applications, we can either directly connect a device to the machine and enable developer mode, or use virtualized devices. The advantage of virtualization is that we can test our applications with a wide range of devices and different configurations. The disadvantage is that we will have to create a virtual machine for each device we want to test, with the associated consumption of storage space and memory.</p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#32-android-studio-installation","title":"3.2 Android Studio installation","text":"<p>The best way of install Android Studio i to download the installer and follow the installation instructions. Once installed, Android Studio automatically checks for updates.</p> <p>But before start the installation, read carefully the system requirements.</p> <p>Download Android Studio</p> <p>Installation guide (with system requirements)</p> <p>Download and install Android Studio (Codelab)</p> <p>Task</p> <p>Install Android Studio</p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#33-genymotion-emulator-installation","title":"3.3 Genymotion emulator installation","text":"<p>Genymotion is a third-party Android emulator and virtual device management platform. It is a powerful alternative to the emulator that comes bundled with Android Studio (which is now based on the Android Emulator Hypervisor Driver for faster performance).</p> <p>While Android Studio's Device Manager is the official tool for creating and running Android Virtual Devices (AVDs), Genymotion is often favored by developers for its significantly faster performance, advanced features, and ease of use for specific testing scenarios.</p> <p>Additionally, Genymotion offers a cloud service that allows you to run emulators on remote servers. This is ideal for continuous integration/continuous deployment (CI/CD) pipelines, automated testing on a large scale, or accessing a powerful emulator from a less powerful local machine.</p> <p>As a drawback, if you use the free license of Genymotion, you won't have access to the latest Android version and to the pro widgets.</p> <p>Genymotion download</p> <p>Requirements and installation guides</p> <p>Task</p> <p>Install Genymotion Desktop and create and launch an Android Virtual Device with the latest API allowed.</p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#34-yout-first-android-app","title":"3.4 Yout first Android app","text":"<p>Once you have Android Studio installed, it's time to create your first Android app. The purpose of this section is to practice the basic use of IDE and emulators.</p> <p>Task</p> <ol> <li>Follow the guide at Create your first Android app codcelab</li> <li>Run the app on the Android Emulator. You can follow this codelab</li> <li>Close the Android emulator and start the Genymotion virtual device. Run your app on the Genymotion device.</li> <li>Connect your Android device and run the app on it. You can follow this codelab</li> </ol>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#35-structure-of-an-android-project","title":"3.5 Structure of an Android project","text":"<p>Android Studio uses Gradle as the project build tool. Android projects are organized into modules, where each module will be a different application. This allows us to have multiple versions of our application for different types of devices (tablets, wearables, etc.) under the same project.</p> <p>Below, we see the structure generated in an Android project, from both the Project Files view in the side tool window and the Android view.</p> <p></p> <p>In the project files view, we can see the typical file structure of a Gradle project, with general application files in the root folder, as well as the specific folder for the application module (<code>app</code>). However, the Android view presents a more compact and simplified view of this information, organized into several main logical folders: <code>app</code> (which contains <code>manifests</code>, <code>kotlin+java</code>, and <code>res</code>), plus the <code>Gradle Scripts</code> folder.</p> <p>Let's see some of the most important elements of this organization:</p> <ul> <li>The Gradle build scripts, in Kotlin DSL format (<code>build.gradle.kts</code>). This includes both the general script located in the root (with information common to all modules) and the one specific to the application module (<code>app/build.gradle.kts</code>). In the Android view, both scripts are shown under <code>Gradle Scripts</code>, indicating whether it's the script for the project or the module.</li> <li>Inside the module folder (<code>app</code>) we find the <code>src</code> folder, which contains the application's source code (<code>app/src/main</code>). In the Android view, this is located in the <code>kotlin+java</code> folder and is displayed in package name format instead of showing the directory structure.</li> <li>The <code>app/src/main/res</code> folder, which will contain the application's resources (images, layouts, text strings, etc.). If we look at the detail, this folder contains many subfolders for the different types of resources. In the Android view, this content is displayed in a more compact and organized way, according to the resource type.</li> <li>The application descriptor file: <code>app/AndroidManifest.xml</code>, with information associated with it. As we will see, this is one of the most important files in our project, as it defines aspects such as the application name, package, icon, and its different components.</li> </ul>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#gradle-scripts","title":"Gradle Scripts","text":""},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#general-build-script","title":"General Build Script","text":"<p>As mentioned, an Android project defines a general configuration script <code>build.gradle.kts</code> for the project, located in the root folder, and another located in the <code>app</code> folder, which refers to the application module itself.</p> <p>The content of the general build script will have the following structure:</p> <pre><code>plugins {\nalias(libs.plugins.android.application) apply false\nalias(libs.plugins.kotlin.android) apply false\nalias(libs.plugins.kotlin.compose) apply false\n}\n</code></pre> <p>It contains aliases to the plugins it uses, defined in the version catalog file <code>libs.versions.toml</code>.</p> <p>In previous versions, plugins were specified in this same file, but now this catalog is used to manage the versions of plugins and dependencies, to facilitate maintenance and version updates, since all are defined in the same place.</p> <p>This file, located in the <code>gradle</code> folder, contains, among other things:</p> <pre><code>[versions]\nagp = \"8.13.0\"\nkotlin = \"2.0.21\"\n...\n\n[libraries]\n...\n\n[plugins]\nandroid-application = { id = \"com.android.application\", version.ref = \"agp\" }\nkotlin-android = { id = \"org.jetbrains.kotlin.android\", version.ref = \"kotlin\" }\nkotlin-compose = { id = \"org.jetbrains.kotlin.plugin.compose\", version.ref = \"kotlin\" }\n</code></pre> <p>This means it uses the plugins <code>com.android.application</code> (it's an Android application), <code>kotlin-android</code> (it's a Kotlin application) and <code>kotlin-compose</code>, with versions <code>8.13.0</code> for the first and <code>2.0.21</code> for the second.</p> <p>The utility of these plugins is to correctly configure the project build process, ensuring that the Kotlin code is compiled properly and packaged correctly for Android.</p> <p>Although by default plugins are loaded immediately, we can use the <code>apply false</code> syntax to load them later in the configuration files of each module.</p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#module-scripts","title":"Module Scripts","text":"<p>The build file most important is the <code>build.gradle.kts</code> of the application module itself. The main blocks that compose it are the following:</p> <pre><code>plugins {\nalias(libs.plugins.android.application)\nalias(libs.plugins.kotlin.android)\nalias(libs.plugins.kotlin.compose)\n}\n</code></pre> <p>This is where the plugins that the module will depend on are specified; specifically those defined in the general build file.</p> <pre><code>android {\nnamespace = \"com.example.helloandroid\"\ncompileSdk = 36\n\ndefaultConfig {\napplicationId = \"com.example.helloandroid\"\nminSdk = 24\ntargetSdk = 36\nversionCode = 1\nversionName = \"1.0\"\n\ntestInstrumentationRunner = \"androidx.test.runner.AndroidJUnitRunner\"\n}\n\nbuildTypes {\nrelease {\nisMinifyEnabled = false\nproguardFiles(\ngetDefaultProguardFile(\"proguard-android-optimize.txt\"),\n\"proguard-rules.pro\"\n)\n}\n}\ncompileOptions {\nsourceCompatibility = JavaVersion.VERSION_11\ntargetCompatibility = JavaVersion.VERSION_11\n}\nkotlinOptions {\njvmTarget = \"11\"\n}\nbuildFeatures {\ncompose = true\n}\n}\n</code></pre> <p>This <code>android</code> block is where some of the most important aspects of the application are configured. It contains the namespace of our application (<code>namespace</code>) and the SDK version it was developed with (<code>compileSdk</code>).</p> <p>Furthermore, it includes several sub-blocks, such as:</p> <ul> <li><code>defaultConfig</code>: Specifies the default configuration, with parameters such as the application ID (<code>applicationId</code>), the minimum SDK version the application will work with (<code>minSdk</code>), or the version it was developed for (<code>targetSdk</code>), among others.</li> <li><code>buildTypes</code>: Where parameters for the different builds can be specified. When creating a module, two builds are created by default: <code>release</code> and <code>debug</code>. Here we specify options like code optimization with Proguard, etc.</li> <li><code>compileOptions</code>, where the Java version to be used to compile the project (<code>sourceCompatibility</code>) and the Java version the compilation will target (<code>targetCompatibility</code>) are specified. In this case, the value <code>JavaVersion.VERSION_1_8</code> refers to Java version 8.</li> <li><code>kotlinOptions</code> specifies some options for Kotlin; in this case <code>jvmTarget</code>, which indicates the Java version that will be used for the Kotlin code.</li> </ul> <p>And finally, we have the following project dependencies block:</p> <pre><code>dependencies {\nimplementation(libs.androidx.core.ktx)\nimplementation(libs.androidx.lifecycle.runtime.ktx)\nimplementation(libs.androidx.activity.compose)\nimplementation(platform(libs.androidx.compose.bom))\nimplementation(libs.androidx.compose.ui)\nimplementation(libs.androidx.compose.ui.graphics)\nimplementation(libs.androidx.compose.ui.tooling.preview)\nimplementation(libs.androidx.compose.material3)\ntestImplementation(libs.junit)\nandroidTestImplementation(libs.androidx.junit)\nandroidTestImplementation(libs.androidx.espresso.core)\nandroidTestImplementation(platform(libs.androidx.compose.bom))\nandroidTestImplementation(libs.androidx.compose.ui.test.junit4)\ndebugImplementation(libs.androidx.compose.ui.tooling)\ndebugImplementation(libs.androidx.compose.ui.test.manifest)\n}\n</code></pre> <p>Among these dependencies, we highlight the Jetpack libraries (<code>libs.androidx.core.ktx</code>), as well as the Compose libraries (<code>libs.androidx.compose...</code>), among others. Note that we are also using aliases here, and the name and versions of the libraries are specified in the <code>gradle/libs.versions.toml</code> file.</p> <p>At this point, we we can see how, unlike other types of Gradle applications, the main class (<code>mainClass</code>) is not specified, and the <code>application</code> section doesn't even exist. As we will see next, the entry point will be specified in the Manifest file.</p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#the-androidmanifestxml-file-and-application-components","title":"The AndroidManifest.xml File and Application Components","text":"<p>The Manifest file is a file specific to each application that contains information about it. This information is used by the Android build tools, the system itself, and Google Play.</p> <p>Among the information we can find in it, we can highlight:</p> <ul> <li>The different components of the application and their properties: Activities (<code>&lt;activity&gt;</code>), Services (<code>&lt;service&gt;</code>), Broadcast Receivers (<code>&lt;receiver&gt;</code>), and Content Providers (<code>&lt;provider&gt;</code>). We will discuss these components later.</li> <li>The application's permissions to access protected system resources or other applications, as well as the permissions that other applications must possess to access this application's content.</li> <li>The different hardware and software features that our application will need, so that Google Play prevents its installation on devices that do not have these features.</li> </ul> <p>As an example, let's look at the <code>AndroidManifest.xml</code> of a typical \"Hello World\" application, like the one we created. The general structure of the file is as follows:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\nxmlns:tools=\"http://schemas.android.com/tools\"&gt;\n\n&lt;application&gt; ...\n    &lt;/application&gt;\n&lt;/manifest&gt;\n</code></pre> <p>As we can see, the root element <code>manifest</code> defines two namespaces:</p> <ul> <li><code>xmlns:android</code>, with which we can define Android-specific attributes (<code>android:</code>) in the document, which serve to define the application's behavior and its interaction with the system. Furthermore, it allows us to define information related to components (activities, services, etc.).</li> <li><code>xmlns:tools</code> allows us to use certain debugging and helper tools from the IDE, but it has no effect on the application's operation.</li> </ul> <p>In older versions of Android Studio, with Gradle prior to 7.3, the package name was also specified in the <code>manifest</code> tag, instead of in the project's Gradle build file. Therefore, in old projects, you might find it in this file.</p> <p>Let's now move on to the <code>application</code> element, which contains all the information about the application:</p> <pre><code>&lt;application\nandroid:allowBackup=\"true\"\nandroid:dataExtractionRules=\"@xml/data_extraction_rules\"\nandroid:fullBackupContent=\"@xml/backup_rules\"\nandroid:icon=\"@mipmap/ic_launcher\"\nandroid:label=\"@string/app_name\"\nandroid:roundIcon=\"@mipmap/ic_launcher_round\"\nandroid:supportsRtl=\"true\"\nandroid:theme=\"@style/Theme.HelloAndroid\"&gt;\n&lt;activity&gt; ... &lt;/activity&gt;\n&lt;/application&gt;\n</code></pre> <p>As we can see, several Android-specific attributes are defined here, such as the icon, label, or theme that defines the application's appearance. Many of these elements are referenced preceded by the <code>@</code> symbol, which indicates that they refer to application resources.</p> <p>Inside <code>application</code>, as mentioned, the different components of the application are defined. In this case, there is a single activity:</p> <pre><code>&lt;activity\nandroid:name=\".MainActivity\"\nandroid:exported=\"true\"\nandroid:label=\"@string/app_name\"\nandroid:theme=\"@style/Theme.HelloAndroid\"&gt;\n&lt;intent-filter&gt;\n&lt;action android:name=\"android.intent.action.MAIN\" /&gt;\n&lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;\n&lt;/intent-filter&gt;\n&lt;/activity&gt;\n</code></pre> <p>With this, we indicate that the application contains an activity named <code>.MainActivity</code> (actually <code>com.example.helloandroid.MainActivity</code>), and that this activity can receive messages from outside the application (<code>android:exported=\"true\"</code>), or in other words, that this activity will be an entry point to our application.</p> <p>Furthermore, an <code>intent-filter</code> element is defined, which specifies the actions this activity will react to. In this case, the action <code>android.intent.action.MAIN</code> is defined with the category <code>android.intent.category.LAUNCHER</code>. With <code>MAIN</code> we indicate that this is the entry point to the application, and by specifying the <code>LAUNCHER</code> category, we indicate that this activity should appear in the application launcher.</p> <p>Within this same <code>application</code> element, we will define the rest of the application's components. Any components not included will not be visible to the system.</p>"},{"location":"U01%20Introduction%20to%20Mobile%20Development/UD1/#application-resources","title":"Application Resources","text":"<p>The application's resources folder (<code>res</code>) contains, organized in subfolders, the different types of resources used by the application. When programming any application, it is convenient to keep resources external to the application to facilitate their independent maintenance.</p> <p>Although there are several physical folders for the different types of resources, the Android view presents us with a logical organization of all of them. Among these logical folders we can find:</p> <ul> <li><code>drawable/</code>: Contains graphic design elements that can be drawn on the device screen: not only images but also layer lists, states, or levels, among many others.</li> <li><code>mipmap/</code>: Contains the different application icons, in different densities (dpi).</li> <li><code>layout/</code>: For apps that use XML layouts, contains the layouts of different parts of the user interface, in XML format.</li> <li><code>values/</code>: Contains files in XML format with simple values, such as character strings, integer values, or colors.</li> <li><code>xml/</code>: XML files that can be read at runtime, with some special configurations.</li> </ul>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/","title":"The Kotlin language","text":"<p>Kotlin is a cross-platform, statically typed, general-purpose high-level programming language with type inference. Kotlin is designed to interoperate fully with Java, and the JVM version of Kotlin's standard library depends on the Java Class Library. </p> <p>Kotlin mainly targets the JVM, but also compiles to JavaScript or native code.Language development costs are borne by JetBrains, while the Kotlin Foundation protects the Kotlin trademark.</p> <p>The Android Kotlin compiler emits Java 8 bytecode by default (which runs in any later JVM), but allows targeting Java 9 up to 20, for optimizing. </p> <p>On 7 May 2019, Google announced that the Kotlin programming language had become its preferred language for Android app developers. Since the release of Android Studio 3.0 in October 2017, Kotlin has been included as an alternative to the standard Java compiler.</p> <p>References:</p> <ul> <li>Kotlin docs</li> <li>Kotlin for Android</li> <li>Kotlin playground</li> </ul>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#hello-world","title":"Hello world","text":"<p>Open the Kotlin Playground and write and execute this code:</p> <pre><code>fun main() {\nprintln(\"Hello, world!\")\n}\n</code></pre> <p><code>fun main()</code> is the entry point of the program. All Kotlin programs are required to have a main function, which is the specific place in your code where the program starts running. </p> <p><code>println</code> is a function that takes an argument as a String and outputs its content to the console.</p> <p>Tip</p> <p>You can also run Kotlin code in Android Studio creating a new file on an exisiting project and running that file.</p>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#variables","title":"Variables","text":"<p>To create a variable, use <code>var</code> or <code>val</code>, and assign a value to it with the equal sign (<code>=</code>):</p> <pre><code>var name = \"Mary\"\nval birthyear = 1974\n</code></pre> <p>The difference between <code>var</code> and <code>val</code> is that variables declared with the <code>var</code> keyword can be modified, while <code>val</code> variables cannot. <code>val</code> variables are immutable.</p> <p>Kotlin uses type inference, but you can specify the type when create a variable:</p> <pre><code>var name: String = \"Mary\"\nval birthyear: Int = 1974\n</code></pre> <p>The general rule for naming Kotlin variables are:</p> <ul> <li>Names can contain letters, digits, underscores, and dollar signs.</li> <li>Names should start with a letter, <code>$</code> and <code>_</code> </li> <li>Names are case sensitive (\"myVar\" and \"myvar\" are different variables)</li> <li>Names should start with a lowercase letter and it cannot contain whitespace</li> <li>Reserved words (like Kotlin keywords, such as var or String) cannot be used as names</li> </ul>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#types","title":"Types","text":"<p>In Kotlin, everything is an object in the sense that you can call member functions and properties on any variable.</p> <p>For integer numbers, there are four types with different sizes and value ranges:</p> <p></p> <p>When you initialize a variable with no explicit type specification, the compiler automatically infers the type with the smallest range enough to represent the value starting from Int. If it doesn't exceed the range of Int, the type is Int. If it does exceed that range, the type is Long. To specify the Long value explicitly, append the suffix L to the value. To use the Byte or Short type, specify it explicitly in the declaration. </p> <pre><code>val one = 1 // Int\nval threeBillion = 3000000000 // Long\nval oneLong = 1L // Long\nval oneByte: Byte = 1\n</code></pre> <p>Info</p> <p>In addition to signed integer types, Kotlin also provides unsigned integer types</p> <p>For real numbers, Kotlin provides floating-point types Float and Double that adhere to the IEEE 754 standard. Float reflects the IEEE 754 single precision, while Double reflects double precision.</p> <p></p> <p>For variables initialized with fractional numbers, the compiler infers the Double type.</p> <p>The String data type is used to store a sequence of characters (text). String values must be surrounded by double quotes:</p> <pre><code>val myText: String = \"Hello World\"\n</code></pre> <p>String literals may contain template expressions (pieces of code that are evaluated and whose results are concatenated into a string). When a template expression is processed, Kotlin automatically calls the <code>.toString()</code> function on the expression's result to convert it into a string. A template expression starts with a dollar sign ($) and consists of a variable name:</p> <pre><code>var name: String = \"Mary\"\nval age: Int = 34\nprintln(\"Hello $name!\")\nprintln(\"Yout age is $age\")\n</code></pre> <p>Template expressions can also hold an expression in curly braces:</p> <pre><code>val num1 = 3\nval num2 = 4\nprintln(\"$num1 + $num2 is ${num1 + num2}\")\n</code></pre> <p>The Boolean data type can only take the values <code>true</code> or <code>false</code>:</p> <pre><code>val isTrue: Boolean = true\nval isFalse: Boolean = false\n</code></pre> <p>The Char data type is used to store a single character. A <code>char</code> value must be surrounded by single quotes:</p> <pre><code>val letter = 'A'\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#type-conversion","title":"Type Conversion","text":"<p>In Kotlin, numeric type conversion is different from Java. For example, it is not possible to convert an Int type to a Long type with the following code:</p> <pre><code>val x: Int = 5\nval y: Long = x\nprintln(y) // Error: Type mismatch \n</code></pre> <p>To convert a numeric data type to another type, you must use one of the following functions: <code>toByte()</code>, <code>toShort()</code>, <code>toInt()</code>, <code>toLong()</code>, <code>toFloat()</code>, <code>toDouble()</code>, <code>toString()</code> or <code>toChar()</code>:</p> <pre><code>val x: Int = 5\nval y: Long = x.toLong()\nprintln(y)\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#nullable-types-and-elvis-operator","title":"Nullable types and Elvis operator","text":"<p>Kotlin is a safe language, and among other things, it prevents us from programming errors such as NullPointerException since it does not allow variable values to be null by default.</p> <p>If we want to specify that a variable can contain a null value, it is necessary to explicitly define it as nullable. To do this, when we define it, we add a question mark <code>?</code> to its type:</p> <pre><code>var name: String? = null //Nullable type\nvar age: Int = 50   //Non-nullable type\nage = null //Error\n</code></pre> <p>In addition, Kotlin also provides us with the <code>?:</code> operator, known as the Elvis operator, to specify an alternative value when the variable is null.</p> <pre><code>var name : String? = null\nprintln(name.length) // Error\nprintln(name?.length ?: -1) //prints -1\nname = Mary\nprintln(name?.length ?: -1) //prints 4\n</code></pre> <p>In this example we've used the <code>?.</code> safe call operator. It prevents to cause an exception when the variable is null and Kotlin can't call the member function (length in this case).</p>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#constants","title":"Constants","text":"<p>We can declare constants in Kotlin using the <code>const</code> keyword. Constants must be initialized with a value at the time of declaration, and their value cannot be changed later. Constants can only be of primitive types and String.</p> <pre><code>const val PI = 3.14159\nconst val APP_NAME = \"MyKotlinApp\"\n</code></pre> <p>Tip</p> <p>Use snake_case for naming constants: all uppercase letters with words separated by underscores.</p> <p>The difference between <code>val</code> and <code>const val</code> is that <code>val</code> can be assigned a value at runtime, while <code>const val</code> must be assigned a value at compile time. Additionally, <code>const val</code> can only be used for top-level or object-level properties, while <code>val</code> can be used in any scope.</p>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#operators","title":"Operators","text":""},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#arithmetic-operators","title":"Arithmetic Operators","text":"Operator Name Description Example + Addition Adds together two values x + y - Subtraction Subtracts one value from another x - y * Multiplication Multiplies two values x * y / Division Divides one value from another x / y % Modulus Returns the division remainder x % y ++ Increment Increases the value by 1 ++x -- Decrement Decreases the value by 1 --x"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#assignment-operators","title":"Assignment Operators","text":"Operator Example Same As = x = 5 x = 5 += x += 3 x = x + 3 -= x -= 3 x = x - 3 *= x *= 3 x = x * 3 /= x /= 3 x = x / 3 %= x %= 3 x = x % 3"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#comparison-operators","title":"Comparison Operators","text":"<p>Comparison operators are used to compare two values, and returns a Boolean value: either <code>true</code> or <code>false</code>.</p> Operator Name Example == Equal to x == y != Not equal x != y &gt; Greater than x &gt; y &lt; Less than x &lt; y &gt;= Greater than or equal to x &gt;= y &lt;= Less than or equal to x &lt;= y <p>The <code>===</code> operator (and its negated counterpart <code>!==</code>) checks for referencial equality. <code>a === b</code> evaluates to true if and only if <code>a</code> and <code>b</code> point to the same object:</p> <pre><code>fun main() {\nvar a = \"Hello\"\nvar b = a\nvar c = \"world\"\nvar d = \"world\"\n\nprintln(a === b)\n// true\nprintln(a === c)\n// false\nprintln(c === d)\n// true\n}\n</code></pre> <p>For values represented by primitive types at runtime (for example, <code>Int</code>), the <code>===</code> equality check is equivalent to the <code>==</code> check.</p>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#logical-operators","title":"Logical Operators","text":"Operator Name Description Example &amp;&amp; Logical and Returns true if both statements are true <code>x &lt; 5 &amp;&amp;  x &lt; 10</code> || Logical or Returns true if one of the statements is true <code>x &lt; 5 || x &lt; 4</code> ! Logical not Reverse the result, returns false if the result is true <code>!(x &lt; 5)</code>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#comments","title":"Comments","text":"<p>Kotlin has single-line comments and multi-line comments:</p> <pre><code>// This is a single-line comment\n\n/* This is\n  a multi-line\n  comment */\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#control-structures","title":"Control structures","text":""},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#if-else","title":"if - else","text":"<p>The structure is similar to other languages:</p> <pre><code>if (condition1) {\n// block of code to be executed if condition1 is true\n} else if (condition2) {\n// block of code to be executed if the condition1 is false and condition2 is true\n} else {\n// block of code to be executed if the condition1 is false and condition2 is false\n}\n</code></pre> <p>In Kotlin, <code>if-else</code> can return a value for each case that can be assigned to a variable:</p> <pre><code>val message = if (age &lt; 18) {\n\"You are under-age.\"\n} else {\n\"You are adult.\"\n}\n</code></pre> <p>Warning</p> <p>When using <code>if</code> as an expression, you must also include <code>else</code> (required).</p> <p>That can be shortened to:</p> <pre><code>val msg = if (age &lt; 18) \"You are under-age.\" else \"You are adult.\"\n</code></pre> <p>This is equivalent to the ternary operator of other languages.</p>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#when","title":"when","text":"<p>The <code>when</code> statement is similar to <code>switch-case</code> of C/Java:</p> <pre><code>when (trafficLightColor) {\n\"Red\" -&gt; println(\"Stop\")\n\"Yellow\" -&gt; println(\"Slow\")\n\"Green\" -&gt; println(\"Go\")\nelse -&gt; println(\"Invalid traffic-light color\")\n}\n</code></pre> <p>In the same way that if, when can return the result and can be assigned to a variable:</p> <pre><code>val msg = when (trafficLightColor) {\n\"Red\" -&gt; \"Stop\"\n\"Yellow\" -&gt; \"Slow\"\n\"Green\" -&gt; \"Go\"\nelse -&gt; \"Invalid traffic-light color\"\n}\n\nprintln(msg)\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#while-and-do-while","title":"while and do-while","text":"<p><code>while</code> and <code>do-while</code> loops are similar to C/Java:</p> <pre><code>while (condition) {\n// code block to be executed\n}\n</code></pre> <pre><code>do {\n// code block to be executed\n}\nwhile (condition);\n</code></pre> <p>In the same way, we have <code>break</code> and <code>continue</code> statements.</p>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#for","title":"for","text":"<p>Unlike Java and other programming languages, there is no traditional <code>for</code> loop in Kotlin.</p> <p>In Kotlin, the <code>for</code> loop is used to loop through arrays, ranges, and other things that contains a countable number of values.</p> <p>To loop through array elements, use the <code>for</code> loop together with the <code>in</code> operator:</p> <pre><code>val numbers = arrayOf(10, 14, 2, 15, 20)\nfor (x in numbers) {\nprintln(x)\n}\n</code></pre> <p>With the <code>for</code> loop, we can also iterate ranges:</p> <pre><code>for (x in 0..10) {\nprintln(x)\n} </code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#functions","title":"Functions","text":""},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#definition-and-invocation","title":"Definition and invocation","text":"<p>To declare a function in Kotlin we do:</p> <pre><code>fun funcName(param1 : Type1, param2 : Type2...) : ReturnType {\n// function body\nreturn\n}\n</code></pre> <p>Some examples:</p> <pre><code>fun simplefunction() {\nprintln(\"Simple function\")\n}\n\nfun functionWithParams(name: String): Unit\n{\nprintln(\"Hello $name\")\n}\n\nfun sum(x: Int, y: Int): Int {\nreturn (x + y)\n}\n\n//Function call\nprintln(sum(4, 5)) //prints 9\n</code></pre> <p>We look at some features of function declarations:</p> <ul> <li>They are declared using the keyword fun</li> <li>Names start with lower case and are expressed in camelCase</li> <li>Function parameters are specified after the name, in parentheses, and in the form parameter : Type. These types must necessarily be specified</li> <li>The return type of the function may be specified after the parenthesis with the argument list, followed by <code>:</code>.</li> <li>When the function does not return any significant value, its default return type is <code>Unit</code> , which would be the equivalent of <code>void</code> in Java or C.</li> </ul> <p>Warning</p> <p>Unlike in some languages, such as Java, where a function can change the value passed into a parameter, parameters in Kotlin are immutable. You cannot reassign the value of a parameter from within the function body.</p>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#named-parameters","title":"Named parameters","text":"<p>You can use named parameters when call a function:</p> <pre><code>fun hello(name: String, age: Int)\n{\nprintln(\"Hello $name, you are $age years old\")\n}\n\nhello(age = 16, name = \"Sean\") // Hello Sean, you are 16 years old\n</code></pre> <p>In this case, you can write the arguments in any order.</p>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#default-arguments","title":"Default arguments","text":"<p>Function parameters can also specify default arguments.</p> <pre><code>fun hello(name: String = \"Nonamed\", age: Int)\n{\nprintln(\"Hello $name, you are $age years old\")\n}\n\nhello(age = 16, name = \"Sean\") // Hello Sean, you are 16 years old\nhello(age = 16) // Hello Nonamed, you are 16 years old\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#single-expression-functions","title":"Single-expression functions","text":"<p>When the function body consists of a single expression, the curly braces can be omitted and the body specified after an = symbol:</p> <pre><code>fun double(x: Int): Int = x * 2\n</code></pre> <p>Explicitly declaring the return type is optional when this can be inferred by the compiler:</p> <pre><code>fun double(x: Int) = x * 2\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#lambda-expressions","title":"Lambda expressions","text":"<p>Lambda expressions provide a concise syntax to define a function without the <code>fun</code> keyword. You can store a lambda expression directly in a variable without a function reference on another function.</p> <p>Before the assignment operator (<code>=</code>), you add the <code>val</code> or <code>var</code> keyword followed by the name of the variable, which is what you use when you call the function. After the assignment operator (<code>=</code>) is the lambda expression, which consists of a pair of curly braces that form the function body:</p> <pre><code>fun main() {\nhello() // prints \"Hello world!\"\n}\n\nval hello = {\nprintln(\"Hello world!\")\n}\n</code></pre> <p>You can assign the lambda function to a variable and use it as a function too:</p> <pre><code>fun main() {\nval myHello = hello\nmyHello() // prints \"Hello world!\"\n}\n\nval hello = {\nprintln(\"Hello world!\")\n}\n</code></pre> <p>The full syntactic form of lambda expressions is as follows:</p> <pre><code>val sum: (Int, Int) -&gt; Int = { x: Int, y: Int -&gt; x + y }\n</code></pre> <ul> <li> <p>A lambda expression is always surrounded by curly braces.</p> </li> <li> <p>Parameter declarations in the full syntactic form go inside curly braces and have optional type annotations.</p> </li> <li> <p>The body goes after the <code>-&gt;</code>.</p> </li> <li> <p>If the inferred return type of the lambda is not Unit, the last (or possibly single) expression inside the lambda body is treated as the return value.</p> </li> </ul> <p>If you leave all the optional annotations out, what's left looks like this:</p> <pre><code>val sum = { x: Int, y: Int -&gt; x + y }\n</code></pre> <p>Another example of a lambda expression without arguments and return type:</p> <pre><code>val hello: () -&gt; Unit = { println(\"Hello world!\") }\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#trailing-lambdas","title":"Trailing lambdas","text":"<p>If the last parameter of a function is a function, then a lambda expression passed as the corresponding argument can be placed outside the parentheses:</p> <pre><code>val numbers = listOf(1, 2, 3)\nval sum = numbers.fold(0) { acc, i -&gt; acc + i }\nprintln(sum) // prints 6\n</code></pre> <p>Such syntax is also known as trailing lambda.</p> <p>If the lambda is the only argument in that call, the parentheses can be omitted entirely:</p> <pre><code>run { println(\"...\") }\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#it-for-single-parameter-functions","title":"<code>it</code> for single parameter functions","text":"<p>If the lambda has a single argument, we can use the keyword <code>it</code>, which represents that argument passed to the lambda function.</p> <p>The expression:</p> <pre><code>array.forEach { item -&gt; println(item * 4) }\n</code></pre> <p>can be shortened to:</p> <pre><code>array.forEach { println(it * 4) }\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#classes-and-objects","title":"Classes and objects","text":"<p>Kotlin is an object-oriented programming language, and everything in Kotlin is associated with classes and objects, along with their properties and methods.</p>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#defining-a-class","title":"Defining a class","text":"<p>To define a class in Kotlin, use the <code>class</code> keyword followed by the class name and curly braces. Class names should start with an uppercase letter and use camelCase.</p> <pre><code>class Car {\nvar color: String = \"Red\"\nvar model: String = \"Toyota\"\nvar year: Int = 2020\n\nfun start() {\nprintln(\"Car started\")\n}\n\nfun stop() {\nprintln(\"Car stopped\")\n}\n}\n</code></pre> <p>To create an instance of a class (an object), use the class name followed by parentheses:</p> <pre><code>val myCar = Car()\nmyCar.color = \"Blue\"\nmyCar.start() // prints \"Car started\"\n</code></pre> <p>As you can see, we access the properties and methods of the class using the dot (<code>.</code>) notation.</p> <p>You can define class properties using <code>val</code> or <code>var</code>. Properties defined with <code>val</code> are read-only and cannot be modified after initialization, while properties defined with <code>var</code> can be modified.</p>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#getter-and-setter-functions-in-properties","title":"Getter and setter functions in properties","text":"<p>Kotlin provides built-in getter and setter functions for class properties. </p> <pre><code>class Person {\nvar name: String = \"\"\nget() = field\nset(value) { field = value\n} }\n</code></pre> <p>You can customize these functions if needed.</p> <pre><code>class Person {\nvar name: String = \"John\"\nget() = field.uppercase() // Custom getter\nset(value) {\nfield = value.trim() } // Custom setter\n}\n</code></pre> <p>To access the property, you can use the dot notation:</p> <pre><code>val person = Person()\nprintln(person.name) // prints \"JOHN\"\nperson.name = \"  Alice  \"\nprintln(person.name) // prints \"ALICE\"\n</code></pre> <p>Remember that the properties defined with <code>val</code> cannot have a setter function, as they are read-only. And therefore, you cannot modify their value after initialization:</p> <pre><code>class Person {\nval id: Int = 0\nget() = field\n// set(value) { field = value } // Error: Val cannot have a setter\n}\n\nval person = Person()\nperson.id = 5 // Error: Val cannot be reassigned\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#constructors","title":"Constructors","text":"<p>The primary purpose of the constructor is to initialize the properties of the class when an object is created.</p> <p>A default constructor is provided by Kotlin if you don't define any constructors in your class. However, you can define your own constructors.</p> <pre><code>class Person(val id: Int, var name: String) {\nfun displayInfo() {\nprintln(\"ID: $id, Name: $name\")\n}\n} val person = Person(1, \"John\")\nperson.displayInfo() // prints \"ID: 1, Name: John\"\n</code></pre> <p>You can also define a secondary constructor using the <code>constructor</code> keyword:</p> <pre><code>class Person(val id: Int) {\nvar name: String = \"\"\n\nconstructor(id: Int, name: String) : this(id) {\nthis.name = name\n}\n\nfun displayInfo() {\nprintln(\"ID: $id, Name: $name\")\n}\n}\n\nfun main() {\nval person1 = Person(1)\nval person2 = Person(2, \"Alice\")\nperson1.displayInfo() // prints \"ID: 1, Name: \"\nperson2.displayInfo() // prints \"ID: 2, Name: Alice\"\n}\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#inheritance","title":"Inheritance","text":"<p>Kotlin supports inheritance, allowing you to create a new class based on an existing class. The new class (subclass) inherits properties and methods from the existing class (superclass).</p> <p>To enable inheritance, the superclass must be marked with the <code>open</code> keyword:</p> <pre><code>open class Animal {\nopen fun sound() {\nprintln(\"Animal makes a sound\")\n}\n}\n\nclass Dog : Animal() {\noverride fun sound() {\nprintln(\"Dog barks\")\n}\n}\n</code></pre> <p>In this example, the <code>Animal</code> class is the superclass, and the <code>Dog</code> class is the subclass that inherits from <code>Animal</code>. The <code>sound</code> method in the <code>Dog</code> class overrides the method in the <code>Animal</code> class.</p> <p>Note how we must call the constructor of the superclass using parentheses <code>()</code>. If the superclass has a primary constructor with parameters, you must provide the required arguments when calling it.</p> <pre><code>open class Animal(val name: String) {\nopen fun sound() {\nprintln(\"$name makes a sound\")\n}\n}\n\nclass Dog(name: String) : Animal(name) {\noverride fun sound() {\nprintln(\"$name barks\")\n}\n}\n\nfun main() {\nval dog = Dog(\"Buddy\")\ndog.sound() // prints \"Buddy barks\"\n}\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#overriding-methods-and-properties","title":"Overriding methods and properties","text":"<p>To override a method in a subclass, you must use the <code>override</code> keyword. The method in the superclass must be marked with the <code>open</code> keyword to allow it to be overridden.</p> <pre><code>open class Animal {\nopen fun sound() {\nprintln(\"Animal makes a sound\")\n}\n} class Cat : Animal() {\noverride fun sound() {\nprintln(\"Cat meows\")\n}\n}\n\nfun main() {    val cat = Cat()\ncat.sound() // prints \"Cat meows\"\n}\n</code></pre> <p>Similar to methods, you can also override properties in a subclass. The property in the superclass must be marked with the <code>open</code> keyword to allow it to be overridden.</p> <pre><code>open class Person {\nopen var name: String = \"John\"\n} class Student : Person() {\noverride var name: String = \"Alice\"\n}\n\nfun main() {\nval student = Student()\nprintln(student.name) // prints \"Alice\"\n}\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#calling-superclass-methods","title":"Calling superclass methods","text":"<p>You can call a method from the superclass using the <code>super</code> keyword:</p> <pre><code>open class Animal {\nopen fun sound() {\nprintln(\"Animal makes a sound\")\n}\n}\n\nclass Dog : Animal() {\noverride fun sound() {\nsuper.sound() // Call the superclass method\nprintln(\"Dog barks\")\n}\n}\n\nfun main() {\nval dog = Dog()\ndog.sound() // prints \"Animal makes a sound\" followed by \"Dog barks\"\n}   </code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#has-a-relationships","title":"HAS-A relationships","text":"<p>In addition to inheritance (IS-A relationship), Kotlin also supports composition (HAS-A relationship). This means that a class can contain references to other classes as properties.</p> <pre><code>class Engine(val horsePower: Int) {\nfun start() {\nprintln(\"Engine with $horsePower HP started\")\n}\n}\n\nclass Car(val model: String, val engine: Engine) {\nfun start() {\nengine.start()\nprintln(\"$model car started\")\n}\n} fun main() {\nval engine = Engine(150)\nval car = Car(\"Toyota\", engine)\ncar.start() // prints \"Engine with 150 HP started\" followed by \"Toyota car started\"\n}\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#visibility-modifiers","title":"Visibility modifiers","text":"<p>Kotlin provides several visibility modifiers to control the accessibility of classes, objects, interfaces, constructors, functions, properties, and their setters.</p> <ol> <li>Public: The default visibility modifier. The member is visible everywhere.</li> <li>Private: The member is visible only within the class or file where it is declared.</li> <li>Protected: The member is visible within the class and its subclasses.</li> <li>Internal: The member is visible within the same module.</li> </ol> <pre><code>class Example {\nprivate var privateVar: Int = 1\nprotected var protectedVar: Int = 2\ninternal var internalVar: Int = 3\npublic var publicVar: Int = 4\n} fun main() {\nval example = Example()\n\nprintln(example.publicVar) // Accessible\nprintln(example.privateVar) // Error: Not accessible\nprintln(example.protectedVar) // Error: Not accessible\nprintln(example.internalVar) // Accessible if in the same module\n}\n</code></pre> <p>Info</p> <p>A module is a collection of source files and build settings that let you divide your project into discrete units of functionality. Your project can have one or many modules. You can independently build, test, and debug each module.</p> <p>In an Android project, a module is typically an Android app or a library.</p> <p>A package is like a directory or a folder that groups related classes, whereas a module provides a container for your app's source code, resource files, and app-level settings. A module can contain multiple packages.</p> <p>You can also apply visibility modifiers to methods:</p> <pre><code>class Example {\nprivate fun privateMethod() {\nprintln(\"Private method\")\n}\n}\n\nfun main() {\nval example = Example()\nexample.privateMethod() // Error: Not accessible\n}\n</code></pre> <p>And to constructors:</p> <pre><code>class Example private constructor(val value: Int) {\ncompanion object {\nfun create(value: Int): Example {\nreturn Example(value)\n}\n}\n}\n\nfun main() {\nval example = Example.create(5) // Correct way to create an instance\nval example2 = Example(5) // Error: Constructor is private\n}\n</code></pre> <p>Info</p> <p>In this example we are using a companion object to provide a factory method for creating instances of the class, since the constructor is private.</p> <p>This table helps you determine the appropriate visibility modifiers based on where the property or methods of a class or constructor should be accessible:</p> Modifier Accessible in same class Accessible in subclass Accessible in same module Accessible outside module private \u2714 \ud835\uddeb \ud835\uddeb \ud835\uddeb protected \u2714 \u2714 \ud835\uddeb \ud835\uddeb internal \u2714 \u2714 \u2714 \ud835\uddeb public \u2714 \u2714 \u2714 \u2714"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#property-delegation","title":"Property delegation","text":"<p>Property delegation is a design pattern that allows you to delegate the responsibility of getting and setting a property to another object. In Kotlin, you can use the <code>by</code> keyword to delegate a property to another object.</p> <p>In Android development, we use delegates for example to use the remembered state in Jetpack Compose:</p> <pre><code>var name by rememberSaveable { mutableStateOf(\"John\") }\n</code></pre> <p>In order to use the <code>by</code> keyword, <code>rememberSaveable</code> and <code>mutableStateOf</code>, you need the next imports:</p> <pre><code>import androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.rememberSaveable\nimport androidx.compose.runtime.setValue\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#data-classes","title":"Data classes","text":"<p>A data class is a special type of class in Kotlin that is used to hold data. Data classes automatically generate useful methods such as <code>toString()</code>, <code>equals()</code>, <code>hashCode()</code>, and <code>copy()</code> based on the properties defined in the primary constructor.</p> <pre><code>data class User(val name: String, val age: Int)\n\nfun main() {\nval user1 = User(\"Alice\", 30)\nval user2 = User(\"Alice\", 30)\n\nprintln(user1) // User(name=Alice, age=30)\nprintln(user1 == user2) // true\nprintln(user1.copy(age = 31)) // User(name=Alice, age=31)\n}\n</code></pre> <p>A data class is equivalent to a Java class with only properties, getters, setters, <code>toString()</code>, <code>equals()</code>, and <code>hashCode()</code> methods.</p> <p>The <code>copy</code> function creates a new instance of the data class with the same property values as the original instance, but allows you to modify specific properties. In the example above, we created a new <code>User</code> instance with the same name as <code>user1</code>, but with a different age.</p>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#generic-classes","title":"Generic classes","text":"<p>Generics allow you to create classes, interfaces, and functions that can work with different data types while providing type safety. You can define a generic class by adding a type parameter in angle brackets (<code>&lt;&gt;</code>) after the class name.</p> <pre><code>class Box&lt;T&gt;(val value: T) {\nfun getVal(): T {\nreturn value\n}\n}   fun main() {\nval intBox = Box(123)\nval strBox = Box(\"Hello\")\n\nprintln(intBox.getVal()) // prints 123\nprintln(strBox.getVal()) // prints \"Hello\"\n}\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#enum-classes","title":"Enum classes","text":"<p>An enum class is a special type of class in Kotlin that represents a group of related constants. Each constant is an instance of the enum class.</p> <pre><code>enum class Direction {\nNORTH, SOUTH, EAST, WEST\n}   fun main() {\nval dir = Direction.NORTH\nprintln(dir) // prints \"NORTH\"\n}\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#singleton-objects","title":"Singleton objects","text":"<p>In Kotlin, you can create a singleton object using the <code>object</code> keyword. A singleton object is a class that has only one instance throughout the application.</p> <pre><code>object Database {\nfun connect() {\nprintln(\"Connected to the database\")\n}\n}   fun main() {\nDatabase.connect() // prints \"Connected to the database\"\n}\n</code></pre> <p>You can also create companion objects within a class. A companion object is an object that is associated with a class and can access its private members.</p> <pre><code>class MyClass {\ncompanion object {\nfun create(): MyClass {\nreturn MyClass()\n}\n}\n}   fun main() {\nval myClass = MyClass.create()\n} // creates an instance of MyClass\n</code></pre> <p>An example of companion object is the <code>Modifier</code> object in Jetpack Compose:</p> <pre><code>import androidx.compose.ui.Modifier\n\nval myModifier = Modifier.padding(16.dp).fillMaxWidth()\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#interfaces","title":"Interfaces","text":"<p>An interface is a contract that defines a set of methods and properties that a class must implement. In Kotlin, you can define an interface using the <code>interface</code> keyword.</p> <pre><code>interface Shape {\nfun area(): Double\nfun perimeter(): Double\n}\n\nclass Circle(private val radius: Double) : Shape {\noverride fun area(): Double {\nreturn Math.PI * radius * radius\n}\n\noverride fun perimeter(): Double {\nreturn 2 * Math.PI * radius\n}\n}\n\nfun main() {\nval circle = Circle(5.0)\nprintln(\"Area: ${circle.area()}\") // prints \"Area: 78.53981633974483\"\nprintln(\"Perimeter: ${circle.perimeter()}\") // prints \"Perimeter: 31.41592653589793\"\n}\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#collections","title":"Collections","text":"<p>Kotlin provides several collection types to store and manipulate groups of related data. The most commonly used collection types are lists, sets, and maps.</p>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#arrays","title":"Arrays","text":"<p>An array is a collection of elements of the same type. You can create an array using the <code>arrayOf</code> function or the <code>Array</code> class.</p> <pre><code>val numbers = arrayOf(1, 2, 3, 4, 5)\nval strings = Array(3) { i -&gt; \"Item $i\" } // creates an array of strings with 3 elements\n</code></pre> <p>You can access the elements of an array using their index:</p> <pre><code>println(numbers[0]) // prints 1\nnumbers[1] = 10\nprintln(numbers[1]) // prints 10\n</code></pre> <p>You can also use the <code>size</code> property to get the number of elements in an array:</p> <pre><code>println(numbers.size) // prints 5\n</code></pre> <p>To acces all the elements of an array, you can use a <code>for</code> loop:</p> <pre><code>for (num in numbers) {\nprintln(num)\n}\n</code></pre> <p>Or the <code>forEach</code> method:</p> <pre><code>numbers.forEach { num -&gt; println(num) }\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#lists","title":"Lists","text":"<p>A list is an ordered collection of elements that can contain duplicates. You can create a list using the <code>listOf</code> function for an immutable list or the <code>mutableListOf</code> function for a mutable list.</p> <pre><code>val immutableList = listOf(1, 2, 3, 4, 5)\nval mutableList = mutableListOf(1, 2, 3, 4, 5)\n</code></pre> <p>You can access the elements of a list using their index, use the <code>size</code> property, and iterate through the elements in the same way as with arrays.</p> <p>You can add or remove elements from a mutable list using the <code>add</code> and <code>remove</code> methods:</p> <pre><code>mutableList.add(6)\nmutableList.remove(2)\nprintln(mutableList) // prints [1, 3, 4, 5, 6]\n</code></pre> <p>With removeAt you can remove an element at a specific index:</p> <pre><code>mutableList.removeAt(0)\nprintln(mutableList) // prints [3, 4, 5, 6]\n</code></pre> <p>Lists provides the <code>contains</code> method to check if an element is in the list:</p> <pre><code>println(mutableList.contains(4)) // prints true\nprintln(mutableList.contains(2)) // prints false\n</code></pre> <p>Lists also provide many useful methods for manipulating and transforming the data, such as <code>filter</code>, <code>map</code>, <code>reduce</code>, <code>sort</code>, and more.</p>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#sets","title":"Sets","text":"<p>A set is an unordered collection of unique elements. You can create a set using the <code>setOf</code> function for an immutable set or the <code>mutableSetOf</code> function for a mutable set.</p> <pre><code>val immutableSet = setOf(1, 2, 3, 4, 5)\nval foodSet = mutableSetOf(\"Pizza\", \"Burger\", \"Pasta\")\n\nprintln(immutableSet) // prints [1, 2, 3, 4, 5]\nprintln(foodSet) // prints [Pizza, Burger, Pasta]\n</code></pre> <p>You can add an remove elements using the <code>add</code> and <code>remove</code> methods:</p> <pre><code>foodSet.add(\"Salad\")\nprintln(foodSet) // prints [Pizza, Burger, Pasta, Salad]\n\nfoodSet.add(\"Pizza\") // Duplicate, won't be added\nprintln(foodSet) // prints [Pizza, Burger, Pasta, Salad]\n\nfoodSet.remove(\"Burger\")\nprintln(foodSet) // prints [Pizza, Pasta, Salad]\n\nimmutableSet.add(6) // Error: Cannot add to an immutable set\n</code></pre> <p>You can check if an element is in the set using the <code>contains</code> method:</p> <pre><code>println(foodSet.contains(\"Pasta\")) // prints true\nprintln(foodSet.contains(\"Burger\")) // prints false\nprintln(foodSet.size) // prints 3\n</code></pre> <p>As you can see, we can query the size of the set using the <code>size</code> property.</p>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#maps","title":"Maps","text":"<p>A map is a collection of key-value pairs. You can create a map using the <code>mapOf</code> function for an immutable map or the <code>mutableMapOf</code> function for a mutable map.</p> <pre><code>val foodCaloriesMap = mutableMapOf(\n\"Pizza\" to 266,\n\"Burger\" to 295,\n\"Pasta\" to 131\n)\nprintln(foodCaloriesMap) // prints {Pizza=266, Burger=295, Pasta=131}\n</code></pre> <p>You can also declare an empty mutable map and add key-value pairs later:</p> <pre><code>val countryCapitalMap = mutableMapOf&lt;String, String&gt;()\ncountryCapitalMap[\"USA\"] = \"Washington D.C.\"\ncountryCapitalMap[\"France\"] = \"Paris\"\nprintln(countryCapitalMap) // prints {USA=Washington, D.C., France=Paris}\n</code></pre> <p>You can access the values in a map using their keys:</p> <pre><code>println(foodCaloriesMap[\"Pizza\"]) // prints 266\nfoodCaloriesMap[\"Pizza\"] = 270 // Update value\nprintln(foodCaloriesMap[\"Pizza\"]) // prints 270\n</code></pre> <p>The <code>remove()</code> method removes the key-value pair with the specified key. It also returns the removed value, or <code>null</code>, if the specified key isn't in the map.</p> <pre><code>val removedCalories = foodCaloriesMap.remove(\"Burger\")\nprintln(removedCalories) // prints 295\nprintln(foodCaloriesMap) // prints {Pizza=270, Pasta=131}\n</code></pre> <p>You can check if a key is in the map using the <code>containsKey</code> method:</p> <pre><code>println(foodCaloriesMap.containsKey(\"Pasta\")) // prints true\nprintln(foodCaloriesMap.containsKey(\"Burger\")) // prints false\n</code></pre> <pre><code>println(foodCaloriesMap.size) // prints 2\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#collection-operations","title":"Collection operations","text":"<p>Kotlin provides many useful functions to manipulate collections. Here are some common operations:</p> <ul> <li><code>filter</code>: Returns a list containing only elements that match the given predicate.</li> </ul> <pre><code>val numbers = listOf(1, 2, 3, 4, 5, 6)\nval evenNumbers = numbers.filter { it % 2 == 0 }\nprintln(evenNumbers) // prints [2, 4, 6]\n</code></pre> <ul> <li><code>map</code>: Returns a list containing the results of applying the given transformation function to each element.</li> </ul> <pre><code>val squaredNumbers = numbers.map { it * it }\nprintln(squaredNumbers) // prints [1, 4, 9, 16, 25, 36]\n</code></pre> <ul> <li><code>reduce</code>: Accumulates value starting with the first element and applying the operation from left to right.</li> </ul> <pre><code>val sum = numbers.reduce { acc, num -&gt; acc + num }\nprintln(sum) // prints 21\n</code></pre> <ul> <li><code>sort</code>: Returns a list sorted according to natural sort order or by a specified comparator.</li> </ul> <pre><code>val unsortedNumbers = listOf(5, 2, 8, 1, 4)\nval sortedNumbers = unsortedNumbers.sorted()\nprintln(sortedNumbers) // prints [1, 2, 4, 5, 8]\n</code></pre> <ul> <li><code>forEach</code>: Performs the given action on each element.</li> </ul> <pre><code>numbers.forEach { num -&gt; println(num) }\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#exceptions-and-error-handling","title":"Exceptions and error handling","text":"<p>Kotlin provides a robust mechanism for handling exceptions and errors using <code>try</code>, <code>catch</code>, and <code>finally</code> blocks.</p>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#try-catch-finally","title":"try-catch-finally","text":"<p>The <code>try</code> block contains the code that may throw an exception. The <code>catch</code> block is used to handle the exception, and the <code>finally</code> block contains code that will always be executed, regardless of whether an exception was thrown or not.</p> <pre><code>try {\nval result = 10 / 0\nprintln(\"Result: $result\")\n} catch (e: ArithmeticException) {\nprintln(\"Error: Division by zero\")\n} finally {\nprintln(\"Execution completed\")\n}\n</code></pre> <p>The <code>finally</code> block is optional and can be omitted if not needed.</p>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#throwing-exceptions","title":"Throwing exceptions","text":"<p>You can throw exceptions in Kotlin using the <code>throw</code> keyword. You can throw both built-in exceptions and custom exceptions.</p> <pre><code>fun validateAge(age: Int) {\nif (age &lt; 0) {\nthrow IllegalArgumentException(\"Age cannot be negative\")\n}\n}\n\ntry {\nvalidateAge(-5)\n} catch (e: IllegalArgumentException) {\nprintln(\"Error: ${e.message}\")\n}\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#coroutines","title":"Coroutines","text":"<p>Coroutines are a powerful feature in Kotlin that allows you to write asynchronous and non-blocking code in a sequential manner. They are lightweight threads that can be suspended and resumed without blocking the main thread.</p> <p>To use coroutines in your Kotlin project, you need to add the following dependencies to your <code>build.gradle</code> file:</p> <p><pre><code>implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-core:1.5.2'\nimplementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.5.2' // For Android projects\n</code></pre> Once you have added the dependencies, you can start using coroutines in your code. Here is a simple example of how to use coroutines:</p> <pre><code>import kotlinx.coroutines.*\n\nfun main() {\nGlobalScope.launch {\ndelay(1000L)\nprintln(\"World!\")\n}\nprintln(\"Hello,\")\nThread.sleep(2000L)\n}\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#runblocking","title":"runBlocking","text":"<p>If we want to perform a synchronous operation blocking the main thread, we would do something like this:</p> <pre><code>fun main() {\nrunBlocking {\nprintln(\"Weather forecast\")\ndelay(1000)\nprintln(\"Sunny\")\n}\n}\n</code></pre> <p>The <code>delay</code> function is a special suspending function that does not block the thread, but only suspends the coroutine for a specific time.</p> <p>The <code>runBlocking</code> function is used to start a new coroutine and block the current thread until its completion. It is typically used in main functions and tests.</p> <p>You can use <code>launch</code> inside <code>runBlocking</code> to start new coroutines. These coroutines will run concurrently with the main coroutine started by <code>runBlocking</code>, although the main coroutine will wait for their completion before it completes itself.</p> <pre><code>fun main() {\nrunBlocking {\nlaunch {\ndelay(1000L)\nprintln(\"World!\")\n}\nprintln(\"Hello,\")\n}\n}\n</code></pre> <p>This will print \"Hello,\" and \"World!\", because println(\"Hello,\") is executed immediately, while the coroutine launched with <code>launch</code> is delayed by 1 second before printing \"World!\". Finally, the <code>runBlocking</code> will wait for the launched coroutine to complete before exiting.</p>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#async-and-await","title":"async and await","text":"<p>The <code>async</code> function is used to start a new coroutine that returns a result. It returns a <code>Deferred</code> object, which represents a future result of the coroutine. You can use the <code>await</code> function to get the result of the coroutine.</p> <pre><code>fun main() {\nrunBlocking {\nval deferred = async {\ndelay(1000L)\n\"Hello, World!\"\n}\nprintln(\"Waiting for result...\")\nval result = deferred.await()\nprintln(result)\n}\n}\n</code></pre> <p>In this code, we start a new coroutine using <code>async</code>, which will return a string after a delay of 1 second. We then use <code>await</code> to get the result of the coroutine and print it.</p>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#suspending-functions","title":"Suspending functions","text":"<p>A suspending function is a special type of function that can be paused and resumed at a later time. Suspend functions are defined using the <code>suspend</code> keyword.</p> <pre><code>suspend fun fetchData(): String {\ndelay(1000L) // Simulate a long-running operation\nreturn \"Data fetched\"\n}\n</code></pre> <p>You can call suspend functions only from other suspend functions or from a coroutine.</p> <pre><code>fun main() {\nGlobalScope.launch {\nval data = fetchData()\nprintln(data)\n}\nThread.sleep(2000L)\n}\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#coroutine-scopes","title":"Coroutine scopes","text":"<p>A coroutine scope defines the context in which coroutines run. It is used to manage the lifecycle of coroutines and to ensure that they are cancelled when no longer needed.</p> <pre><code>fun main() {\nrunBlocking {\nlaunch {\n// Coroutine code here\n}\n}\n}\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#coroutinescope","title":"coroutineScope","text":"<p>The <code>coroutineScope</code> builder creates a new coroutine scope and suspends the current coroutine until all child coroutines are completed.</p> <pre><code>suspend fun fetchData(): String {\ndelay(1000L) // Simulate a long-running operation\nreturn \"Data fetched\"\n}\n\ncoroutineScope.launch {\nval data = fetchData()\nprintln(data)\n}\n</code></pre> <p>In Android, coroutine scopes are often tied to the lifecycle of components, such as activities or view models, to ensure that coroutines are cancelled when the component is destroyed.</p>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#viewmodelscope","title":"viewModelScope","text":"<p>In Android, the <code>viewModelScope</code> is a predefined coroutine scope that is tied to the lifecycle of a ViewModel. It is automatically cancelled when the ViewModel is cleared, making it a convenient way to launch coroutines in a ViewModel.</p> <pre><code>class MyViewModel : ViewModel() {\nfun fetchData() {\nviewModelScope.launch {\nval data = fetchData()\nprintln(data)\n}\n}\n}\n</code></pre>"},{"location":"U02%20Android%20basics/U02.1%20-%20Kotlin/#references","title":"References","text":"<ul> <li>Kotlin coroutines</li> <li>Android Studio coroutines</li> </ul>"},{"location":"U02%20Android%20basics/U02.2%20Basic%20Android/","title":"Unit 2.2. Introduction to Mobile Development","text":"<p>In this unit we will learn the basics of Jetpack Compose. We will see the different components that make up a Compose application and how to create user interfaces with Compose.</p>"},{"location":"U02%20Android%20basics/U02.2%20Basic%20Android/#getting-started-with-jetpack-compose","title":"Getting Started with Jetpack Compose","text":"<p>Jetpack Compose is a modern toolkit for building Android UIs. It simplifies and accelerates UI development on Android with less code, powerful tools, and intuitive Kotlin APIs. You can build then UI by defining composable functions that describe your UI.</p> <p>To get started with Jetpack Compose, you need to set up your development environment. This includes installing Android Studio and the necessary SDKs. Once your environment is set up, you can create a new Compose project using the \"Empty Activity\" template and start building your user interface.</p> <p>Info</p> <p>To view how was developing with XML views, create a new project with \"Empty Views Activity\" template.</p>"},{"location":"U02%20Android%20basics/U02.2%20Basic%20Android/#composable-functions","title":"Composable Functions","text":"<p>A composable function is a special type of function that can be used to define a part of your UI. Composable functions are annotated with the <code>@Composable</code> annotation. Here is an example of a simple composable function that displays a text:</p> <pre><code>@Composable\nfun Greeting(name: String) {\nText(text = \"Hello, $name!\")\n}\n</code></pre> <p>An annotation is a special kind of metadata that can be added to code elements such as classes, functions, or properties. Annotations provide additional information about the code and can be used by the compiler or runtime to modify behavior or perform specific actions.</p> <p>Some annotations can take parameters, which allow you to provide additional information or configuration. For example, the <code>@Composable</code> annotation does not take any parameters, but other annotations like <code>@Preview</code> can take parameters to customize the preview behavior:</p> <pre><code>@Preview(showBackground = true)\n@Composable\nfun DefaultPreview() {\nGreeting(\"Android\")\n}\n</code></pre> <ul> <li>Composable functions can accept arguments, just like regular functions. In the example above, the <code>Greeting</code> function takes a <code>name</code> parameter and uses it to display a personalized greeting. They can also return values, although it's not common practice in Compose.</li> <li>Composable functions can be nested, allowing you to create complex UIs by combining smaller, reusable components. For example, you can create a <code>UserProfile</code> composable that includes a <code>ProfilePicture</code> and a <code>UserName</code> composable.</li> <li>The name of a composable function should be descriptive and follow the standard naming conventions for functions in Kotlin. It's common to use PascalCase for composable function names, as they represent UI components. Examples: <code>UserProfile</code>, <code>LoginButton</code>, <code>ProductList</code>.</li> </ul>"},{"location":"U02%20Android%20basics/U02.2%20Basic%20Android/#modifiers","title":"Modifiers","text":"<p>Modifiers are used to change the appearance or behavior of a composable function. They can be used to set properties such as size, padding, background color, and more. Modifiers are applied to composable functions using the <code>Modifier</code> class. Here is an example of how to use modifiers to set the padding and background color of a <code>Text</code> composable:</p> <pre><code>Text(\ntext = \"Hello, World!\",\nmodifier = Modifier\n.padding(16.dp)\n.background(Color.LightGray)\n)\n</code></pre> <p>Passing modifiers to custom composables is a common practice in Jetpack Compose. It allows you to provide flexibility and customization options for the composable's appearance and behavior. By accepting a <code>Modifier</code> parameter, you enable users of your composable to apply their own modifiers, such as padding, size, or click handling.</p> <p>Here is an example of a custom composable that accepts a <code>Modifier</code> parameter:</p> <pre><code>@Composable\nfun CustomButton(\nonClick: () -&gt; Unit,\nmodifier: Modifier = Modifier\n) {\nButton(\nonClick = onClick,\nmodifier = modifier\n) {\nText(\"Custom Button\")\n}\n}\n</code></pre> <p>Info</p> <p>In the example above, the <code>CustomButton</code> composable accepts a <code>modifier</code> parameter of the type <code>Modifier</code> with a default value of <code>Modifier</code> (a companion object that provides default values for the <code>Modifier</code> class).</p> <p>We can call this <code>CustomButton</code> composable and pass our own modifiers to customize its appearance:</p> <pre><code>CustomButton(\nonClick = { /* Handle click */ },\nmodifier = Modifier\n.padding(8.dp)\n.background(Color.Blue)\n)\n</code></pre> <p>dp and sp</p> <p>dp and sp are units of measurement used in Android development to ensure that UI elements are displayed consistently across different screen sizes and densities.</p> <ul> <li> <p>dp (density-independent pixels): A unit of measurement that is based on the physical density of the screen. It is used for defining layout dimensions and spacing. 1 dp is equivalent to one pixel on a 160 dpi screen. </p> </li> <li> <p>sp (scale-independent pixels): A unit of measurement that is similar to dp but is also scaled based on the user's font size preference. It is primarily used for defining font sizes. 1 sp is equivalent to one pixel on a 160 dpi screen, but it can be scaled up or down based on the user's font size settings.</p> </li> </ul>"},{"location":"U02%20Android%20basics/U02.2%20Basic%20Android/#lifecycle-of-composables","title":"Lifecycle of composables","text":"<p>Composable functions have a lifecycle that is managed by the Compose runtime. The lifecycle of a composable function includes the following stages: 1. Composition: When a composable function is called, it is composed, and its UI elements are created and added to the UI tree. 2. Recomposition: When the state of a composable function changes, it is recomposed, and its UI elements are updated to reflect the new state. 3. Disposal: When a composable function is no longer needed, it is disposed of, and its UI elements are removed from the UI tree.</p> <p></p>"},{"location":"U02%20Android%20basics/U02.2%20Basic%20Android/#layouts-and-ui-components","title":"Layouts and UI Components","text":""},{"location":"U02%20Android%20basics/U02.2%20Basic%20Android/#common-layouts","title":"Common Layouts","text":"<p>Jetpack Compose provides several layout components that help you arrange your UI elements. Some of the most commonly used layouts include:</p>"},{"location":"U02%20Android%20basics/U02.2%20Basic%20Android/#column","title":"Column","text":"<p>Arranges its children in a vertical sequence.</p> <pre><code>Column {\nText(\"Item 1\")\nText(\"Item 2\")\nText(\"Item 3\")\n}\n</code></pre>"},{"location":"U02%20Android%20basics/U02.2%20Basic%20Android/#row","title":"Row","text":"<p>Arranges its children in a horizontal sequence.</p> <pre><code>Row {\nText(\"Item 1\")\nText(\"Item 2\")\nText(\"Item 3\")\n}\n</code></pre>"},{"location":"U02%20Android%20basics/U02.2%20Basic%20Android/#box","title":"Box","text":"<p>Stacks its children on top of each other.</p> <pre><code>Box {\nText(\"Item 1\")\nText(\"Item 2\")\n}\n</code></pre> <p></p>"},{"location":"U02%20Android%20basics/U02.2%20Basic%20Android/#lazycolumn","title":"LazyColumn","text":"<p>A vertically scrolling list that only composes and lays out the currently visible items.</p> <pre><code>LazyColumn {\nitems(100) { index -&gt;\n\nText(\"Item #$index\")\n}\n}\n</code></pre>"},{"location":"U02%20Android%20basics/U02.2%20Basic%20Android/#spacer","title":"Spacer","text":"<p>A spacer is a composable that creates an empty space between UI elements. It can be used to adjust the layout and improve the visual appearance of your UI using modifiers to set its width and height, like <code>Modifier.width()</code> and <code>Modifier.height()</code>.</p> <pre><code>Row {\nText(\"Item 1\")\nSpacer(modifier = Modifier.width(16.dp))\nText(\"Item 2\")\n}\n</code></pre>"},{"location":"U02%20Android%20basics/U02.2%20Basic%20Android/#dividers","title":"Dividers","text":"<p>A divider is a composable that creates a visual divider between UI elements. You can implement dividers in your app using the <code>HorizontalDivider</code> and <code>VerticalDivider</code>.</p> <pre><code>Column {\nText(\"Item 1\")\nHorizontalDivider(\nthickness = 2.dp,\ncolor = Color.DarkGray\n)\nText(\"Item 2\")\n}\n</code></pre> <pre><code>Row {\nText(\"Item 1\")\nVerticalDivider()\nText(\"Item 2\")\n}\n</code></pre> <p>Layouts in Compose</p>"},{"location":"U02%20Android%20basics/U02.2%20Basic%20Android/#ui-components","title":"UI Components","text":"<p>Jetpack Compose provides a variety of UI components that you can use to build your user interface. Some of the most commonly used components include:</p>"},{"location":"U02%20Android%20basics/U02.2%20Basic%20Android/#text","title":"Text","text":"<p>Displays a text string.</p> <pre><code>Text(\"Hello, World!\")\n</code></pre> <p>But the recommendation is to display text from resources:</p> <pre><code>Text(stringResource(R.string.hello_world))\n</code></pre> <p>In this example, <code>R.string.hello_world</code> is a reference to a string resource defined in the <code>res/values/strings.xml</code> file.</p> <p>You can change the color, font size, font style, and more by using parameters:</p> <pre><code>Text(\ntext = \"Hello, World!\",\ncolor = Color.Red,\nfontSize = 24.sp,\nfontStyle = FontStyle.Italic,\nfontWeight = FontWeight.Bold,\nfontFamily = FontFamily.Serif,\ntextAlign = TextAlign.Center,\n)\n</code></pre> <p>You can also use the <code>style</code> parameter:</p> <pre><code>Text(\ntext = \"Hello, World!\",\nstyle = TextStyle(\nfontSize = 20.sp,\nfontWeight = FontWeight.Bold,\ncolor = Color.Blue\n)\n)\n</code></pre> <p>Don't forget to import the necessary classes:</p> <pre><code>import androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.text.TextStyle\n... </code></pre> <p>Text in Compose</p>"},{"location":"U02%20Android%20basics/U02.2%20Basic%20Android/#text-fields","title":"Text fields","text":"<p>A text field allows the user to enter and edit text.</p> <pre><code>var state by rememberSaveable { mutableStateOf(\"Hello\") }\nTextField(\nvalue = state,\nonValueChange = { state = it },\nlabel = { Text(\"Label\") },\n)\n</code></pre> <p></p> <p>In this code we use <code>rememberSaveable</code> to save the state of the text field across recompositions and configuration changes, such as screen rotations. And <code>mutableStateOf</code> to create a mutable state variable that holds the current value of the text field.</p> <p>You can also use <code>OutlinedTextField</code> for a different style:</p> <pre><code>var state by rememberSaveable { mutableStateOf(\"Hello\") }\nOutlinedTextField(\nvalue = state,\nonValueChange = { state = it },\nlabel = { Text(\"Label\") },\n)\n</code></pre> <p></p> <p>Other parameters you can use are <code>placeholder</code>, <code>leadingIcon</code>, <code>trailingIcon</code>, <code>isError</code>, <code>singleLine</code>, <code>maxLines</code>, <code>keyboardOptions</code>, <code>keyboardActions</code>, etc.</p> <p>TextField</p>"},{"location":"U02%20Android%20basics/U02.2%20Basic%20Android/#images","title":"Images","text":"<p>To display an image, you can use the <code>Image</code> composable. You can load images from resources, URLs, or other sources.</p> <pre><code>Image(\npainter = painterResource(R.drawable.ic_launcher_foreground),\ncontentDescription = \"My Image\",\n)\n</code></pre> <p><code>painterResource</code> is used to load an image from resources.</p> <p>You also need to provide a content description for accessibility purposes.</p> <p>Images</p>"},{"location":"U02%20Android%20basics/U02.2%20Basic%20Android/#buttons","title":"Buttons","text":"<p>A button is a clickable component that can be used to perform an action when clicked.</p> <p>There are several types of buttons available in Jetpack Compose, each with its own appearance and purpose:</p> Type Appearance Purpose Filled Solid background with contrasting text. High-emphasis buttons. These are for primary actions in an application, such as \"submit\" and \"save.\" The shadow effect highlights the button's importance. Filled tonal Background color varies to match the surface. Also for primary or significant actions. Filled tonal buttons provide more visual weight and suit functions such as \"add to cart\" and \"Sign in.\" Elevated Stands out by having a shadow. Serves a similar purpose to tonal buttons. Increase elevation to make the button appear even more prominently. Outlined Features a border with no fill. Medium-emphasis buttons, containing actions that are important but not primary. They pair well with other buttons to indicate alternative, secondary actions like \"Cancel\" or \"Back.\" Text Displays text with no background or border. Low-emphasis buttons, ideal for less critical actions such as navigational links, or secondary functions like \"Learn More\" or \"View details.\" <p></p> <pre><code>Button(\nonClick = { /* Handle click */ }) {\nText(\"Click Me\")\n}\n</code></pre> <p>Parameters:</p> <ul> <li>onClick:     The function that the system calls when the user presses the button.</li> <li>enabled:     When false, this parameter makes the button appear unavailable and inactive.</li> <li>contentPadding:     The padding within the button.</li> </ul> <p>Buttons</p>"},{"location":"U02%20Android%20basics/U02.2%20Basic%20Android/#floating-action-button-fab","title":"Floating Action Button (FAB)","text":"<p>A Floating Action Button (FAB) is a circular button that floats above the UI and is used for a primary action in an application.</p> <pre><code>FloatingActionButton(\nonClick = { /* Handle click */ }\n) {\nIcon(Icons.Filled.Add, contentDescription = \"Add\")\n}\n</code></pre> <p>In Material Design, there are four types of FAB:</p> <ul> <li>FAB: A floating action button of ordinary size.</li> <li>Small FAB: A smaller floating action button.</li> <li>Large FAB: A larger floating action button.</li> <li>Extended FAB: A floating action button that contains more than just an icon.</li> </ul> <p></p> <p>Some parameters you can use: * shape: The shape of the FAB. * containerColor: The background color of the FAB. * contentColor: The color of the content inside the FAB. * elevation: The elevation of the FAB.</p> <pre><code>FloatingActionButton(\nonClick = { /* Handle click */ },\nshape = CircleShape,\ncontainerColor = Color.DarkGray,\ncontentColor = Color.White,\nelevation = FloatingActionButtonDefaults.elevation(8.dp)\n) {\nIcon(Icons.Filled.Add, contentDescription = \"Add\")\n}\n</code></pre> <p>FAB</p> <p>More buttons:</p> <ul> <li>Icon buttons</li> <li>Segmented buttons</li> </ul>"},{"location":"U02%20Android%20basics/U02.2%20Basic%20Android/#snackbar","title":"Snackbar","text":"<p>A Snackbar is a small banner that appears at the bottom of the screen to provide feedback about an operation. It can also contain an action button.</p> <p>To implement a snackbar, you first create <code>SnackbarHost</code>, which includes a <code>SnackbarHostState</code> property. <code>SnackbarHostState</code> provides access to the <code>showSnackbar()</code> function which you can use to display your snackbar.This suspending function requires a <code>CoroutineScope</code> such as with using <code>rememberCoroutineScope</code> - and can be called in response to UI events to show a Snackbar.</p> <pre><code>val snackbarHostState = remember { SnackbarHostState() }\nval scope = rememberCoroutineScope()\nButton(onClick = {\nscope.launch {\nsnackbarHostState.showSnackbar(\"Hello, Snackbar!\")\n}\n}) {\nText(\"Show Snackbar\")\n}\nSnackbarHost(hostState = snackbarHostState)\n</code></pre> <p></p> <p>You can provide an optional action and adjust the duration of the Snackbar:</p> <pre><code>val snackbarHostState = remember { SnackbarHostState() }\nval scope = rememberCoroutineScope()\nButton(onClick = {\nscope.launch {\nval result = snackbarHostState\n.showSnackbar(\nmessage = \"Snackbar\",\nactionLabel = \"Action\",\n// Defaults to SnackbarDuration.Short\nduration = SnackbarDuration.Indefinite\n)\nwhen (result) {\nSnackbarResult.ActionPerformed -&gt; {\n/* Handle snackbar action performed */\n}\nSnackbarResult.Dismissed -&gt; {\n/* Handle snackbar dismissed */\n}\n}\n}\n}) {\nText(\"Show Snackbar\")\n}\nSnackbarHost(hostState = snackbarHostState)\n</code></pre> <p>Some parameters: * actionLabel: The label for the action button. * duration: The duration for which the snackbar is displayed. It can be <code>SnackbarDuration.Short</code>, <code>SnackbarDuration.Long</code>, or <code>SnackbarDuration.Indefinite</code>.</p> <p>Snackbar</p>"},{"location":"U02%20Android%20basics/U02.2%20Basic%20Android/#cards","title":"Cards","text":"<p>A <code>Card</code> is a composable that displays content and actions on a single topic. Cards are used to group related information and make it easier to scan and understand.</p> <pre><code>Card(\nmodifier = Modifier.padding(16.dp),\nelevation = CardDefaults.cardElevation(\ndefaultElevation = 6.dp\n)\n) {\nColumn(modifier = Modifier.padding(16.dp)) {\nText(\"Card Title\", fontWeight = FontWeight.Bold)\nSpacer(modifier = Modifier.height(8.dp))\nText(\"Card content goes here.\")\nSpacer(modifier = Modifier.height(8.dp))\nButton(onClick = { /* Handle click */ }) {\nText(\"Click me\")\n}\n}\n}\n</code></pre> <p></p> <p>Similar to <code>Card</code> is <code>ElevatedCard</code>, which has a more pronounced shadow effect.</p> <p>Cards</p>"},{"location":"U02%20Android%20basics/U02.2%20Basic%20Android/#surface","title":"Surface","text":"<p>A <code>Surface</code> is a composable that provides a background for other UI elements. It can be used to create cards, buttons, and other components that need a background.</p> <pre><code>Surface(\nmodifier = Modifier.padding(16.dp),\ncolor = MaterialTheme.colorScheme.primary,\nshape = RoundedCornerShape(8.dp),\nshadowElevation = 4.dp\n) {\nText(\ntext = \"Hello, Surface!\",\nmodifier = Modifier.padding(16.dp),\ncolor = Color.White\n)\n}\n</code></pre> <p></p>"},{"location":"U02%20Android%20basics/U02.2%20Basic%20Android/#scaffold","title":"Scaffold","text":"<p>A <code>Scaffold</code> is a layout structure that provides a framework for implementing the basic material design layout structure. It includes slots for the most common top-level material components such as <code>TopAppBar</code>, <code>BottomAppBar</code> and <code>FloatingActionButton</code>.</p> <p>You usually pass a lambda to the <code>Scaffold</code> content parameter, which provides the inner padding values to be applied to the content inside the scaffold.</p> <pre><code>Scaffold(\ntopBar = {\nTopAppBar(\ntitle = { Text(\"My App\") },\ncolors = topAppBarColors(\ncontainerColor = MaterialTheme.colorScheme.primaryContainer,\ntitleContentColor = MaterialTheme.colorScheme.primary,\n),\n)\n},\nfloatingActionButton = {\nFloatingActionButton(onClick = { /* Handle click */ }) {\nIcon(Icons.Filled.Add, contentDescription = \"Add\")\n}\n},\nbottomBar = {\nBottomAppBar {\nText(\ntext = \"Bottom App Bar\",\nmodifier = Modifier.padding(16.dp),\ncolor = MaterialTheme.colorScheme.onPrimaryContainer\n)\n}\n},\n) { innerPadding -&gt;\nColumn(modifier = Modifier.padding(innerPadding)) {\nText(\"Hello, Scaffold!\") }\n}\n</code></pre> <p></p> <p>Scaffold</p> <p>App bars</p>"},{"location":"U02%20Android%20basics/U02.2%20Basic%20Android/#other-components","title":"Other components","text":"<ul> <li>Checkbox</li> <li>Radio Button</li> <li>Switch</li> <li>Progress Indicator</li> <li>Slider</li> <li>Tabs</li> <li>Menus</li> <li>Dialogs</li> <li>Tooltips</li> <li>Badges</li> <li>Chips</li> </ul>"},{"location":"U02%20Android%20basics/U02.2%20Basic%20Android/#theming-and-styling","title":"Theming and Styling","text":"<p>It's very easy to apply theming and styling in Jetpack Compose. You can use the <code>MaterialTheme</code> composable to apply a material design theme to your app.</p> <p><pre><code>class MainActivity : ComponentActivity() {\noverride fun onCreate(savedInstanceState: Bundle?) {\nsuper.onCreate(savedInstanceState)\nsetContent {\nMaterialTheme {\n// Your app content goes here\n}\n}\n}\n}\n</code></pre> You can create your own custom theme by defining colors, typography, and shapes. You can then apply your custom theme using the <code>MaterialTheme</code> composable.</p> <pre><code>@Composable\nfun MyAppTheme(content: @Composable () -&gt; Unit) {\nMaterialTheme(\ncolorScheme = lightColorScheme(\nprimary = Color(0xFF6200EE),\nsecondary = Color(0xFF03DAC5)\n),\ntypography = MaterialTheme.typography.copy(\nbodyLarge = TextStyle(\nfontFamily = FontFamily.Serif,\nfontWeight = FontWeight.Normal,\nfontSize = 16.sp\n)\n),\nshapes = MaterialTheme.shapes.copy(\nsmall = RoundedCornerShape(4.dp),\nmedium = RoundedCornerShape(8.dp),\nlarge = RoundedCornerShape(12.dp)\n),\ncontent = content\n)\n}\n</code></pre> <p>It's a good practice to create a separate file for your theme, colors, typography, and shapes. For example, you can create a file named <code>Theme.kt</code> and define your custom theme there.</p> <pre><code>@Composable\nfun MyAppTheme(content: @Composable () -&gt; Unit) {\nMaterialTheme(\ncolors = myColorPalette,\ntypography = myTypography,\nshapes = myShapes,\ncontent = content\n)\n}\n</code></pre> <p>An example of <code>myTypography</code>:</p> <pre><code>val myTypography = Typography(\nbodyLarge = TextStyle(\nfontFamily = FontFamily.Serif,\nfontWeight = FontWeight.Normal,\nfontSize = 16.sp\n)\n)\n</code></pre> <p><code>myShapes</code> example:</p> <pre><code>val myShapes = Shapes(\nsmall = RoundedCornerShape(4.dp),\nmedium = RoundedCornerShape(8.dp),\nlarge = RoundedCornerShape(12.dp)\n)\n</code></pre> <p>And <code>myColorPalette</code>:</p> <pre><code>val myColorPalette = lightColorScheme(\nprimary = Color(0xFF6200EE),\nsecondary = Color(0xFF03DAC5),\nbackground = Color(0xFFFFFFFF),\nsurface = Color(0xFFFFFFFF),\nonPrimary = Color(0xFFFFFFFF),\nonSecondary = Color(0xFF000000),\nonBackground = Color(0xFF000000),\nonSurface = Color(0xFF000000),\n)\n</code></pre>"},{"location":"U03%20Android%20architecture/U03.1%20Android%20architecture%20copy/","title":"Unit 3.1. Android architecture","text":"<p>Android architecture is a set of guidelines and best practices for building Android applications. It provides a structured approach to app development, making it easier to manage complexity and maintain code quality. The key components of Android architecture include:</p> <ol> <li> <p>Activities and Fragments: The building blocks of the user interface in Android. Activities represent a single screen, while fragments are reusable components that can be embedded within activities.</p> </li> <li> <p>ViewModel: A class that holds and manages UI-related data in a lifecycle-conscious way. ViewModels survive configuration changes, such as screen rotations, making them ideal for storing UI state.</p> </li> <li> <p>Repository: A class that abstracts data access from multiple sources, such as a local database and a remote server. Repositories provide a clean API for data access, making it easier to switch between data sources.</p> </li> <li> <p>Room: A persistence library that provides an abstraction layer over SQLite. Room simplifies database access and allows for compile-time verification of SQL queries.</p> </li> <li> <p>Dependency Injection: A design pattern that allows for the decoupling of components in an application.</p> </li> </ol> <p>By following these architectural guidelines, developers can create robust, maintainable, and testable Android applications.</p> <p>Fragments</p> <p>Fragments are modular sections of an activity, used to reuse UI components in the old Android architecture. However, with the introduction of Jetpack Compose, fragments are less commonly used in modern Android development.</p>"},{"location":"U03%20Android%20architecture/U03.1%20Android%20architecture%20copy/#references","title":"References","text":"<ul> <li>Guide to App Architecture</li> </ul>"},{"location":"U03%20Android%20architecture/U03.1%20Android%20architecture%20copy/#activities","title":"Activities","text":"<p>Activities are the entry point for interacting with the user in an Android application. Each activity is a single screen with a user interface, and it is responsible for managing the lifecycle of the UI components it contains.</p> <p>Every activity has what is known as a lifecycle, which consists of the different states that an activity can go through, from when the activity first initializes to its destruction, at which time the operating system (OS) reclaims its memory. Typically, the entry point of a program is the <code>main()</code> method. Android activities, however, begin with the <code>onCreate()</code> method.  As the user starts your app, navigates between activities, navigates inside and outside of your app, the activity changes state.</p> <p>The following diagram shows all the activity lifecycle states. As their names indicate, these states represent the status of the activity. An activity can go back and forth between states throughout the lifecycle.</p> <p>Note</p> <p>An Android app can have multiple activities. However, it is recommended to have a single activity.</p> <p></p> <p>Note</p> <p>The <code>onRestart()</code> method is not called every time the state transitions between Created and Started. It is only called if <code>onStop()</code> was called and the activity is subsequently restarted.</p> <p>The lifecycle states are:</p> <ul> <li><code>onCreate()</code>: Activity is being created.</li> <li><code>onStart()</code>: Activity becomes visible.</li> <li><code>onResume()</code>: Activity starts interacting with the user, having focus.</li> <li><code>onPause()</code>: Activity is partially visible, but not in focus.</li> <li><code>onStop()</code>: Activity is completely hidden, but still in memory.</li> <li><code>onDestroy()</code>: Activity is being destroyed.</li> <li><code>onRestart()</code>: Activity is being restarted after being stopped.</li> </ul> <p>Task: exploring lifecycle</p> <ol> <li>Create a new project from the source code of this GitHub repository.</li> <li>Open the <code>MainActivity.kt</code> file and examine the lifecycle methods that have been overridden: <code>onStart</code>, <code>onResume</code>, <code>onPause</code>, <code>onStop</code>, <code>onRestart</code>, <code>onDestroy</code>... Note how thre's a <code>Log.d</code> statement in each method.</li> <li>Run the app on an emulator or a physical device and inspect the logcat output. You should see the lifecycle methods being called as you interact with the app (e.g., opening, closing, navigating away from the app).</li> <li>Do the next to observe the lifecycle methods being called:<ul> <li>Rotate the device to see how the activity is recreated.</li> <li>Press the home button to send the app to the background and then return to it.</li> <li>Open another app to see how your activity is paused and stopped.</li> <li>Press the shared button to share content from your app. See how the activity is paused and resumed.</li> <li>With the app open, go to Setting and make a change, for example, change the device's rotation setting. See how the activity is recreated.</li> </ul> </li> </ol>"},{"location":"U03%20Android%20architecture/U03.1%20Android%20architecture%20copy/#lifecycle-of-a-composable","title":"Lifecycle of a composable","text":"<p>The UI of your app is initially built from running composable functions in a process called Composition.</p> <p>When the state of your app changes, a recomposition is scheduled. Recomposition is when Compose re-executes the composable functions whose state might have changed and creates an updated UI. The Composition is updated to reflect these changes.</p> <p>Composable functions have their own lifecycle that is independent of the Activity lifecycle. Its lifecycle is composed of the events: enters the Composition, recomposing 0 or more times, and then leaving the Composition.</p> <p></p> <p>In order for Compose to track and trigger a recomposition, it needs to know when state has changed. To indicate to Compose that it should track an object's state, the object needs to be of type State or MutableState. The State type is immutable and can only be read. A MutableState type is mutable and allows reads and writes.</p> <p>To create the mutable variable revenue, you declare it using <code>mutableStateOf</code> and an initial value.</p> <p>To instruct Compose to retain and reuse its value during recompositions, you need to declare it with the <code>rememberSaveable</code> function. This function tells Compose to save and restore the value across recompositions and configuration changes, such as screen rotations.</p> <pre><code>var revenue by rememberSaveable { mutableStateOf(0) }\n</code></pre> <p>Info</p> <p>You can also use <code>remember</code> instead of <code>rememberSaveable</code>. The difference is that <code>remember</code> only retains the value during recompositions, but not across configuration changes, i.e., if the screen is rotated or the activity is recreated.</p>"},{"location":"U03%20Android%20architecture/U03.1%20Android%20architecture%20copy/#the-log-class","title":"The Log class","text":"<p>The <code>Log</code> class in Android is used for logging messages that can help developers debug their applications. It provides a way to print messages to the logcat, which is a system-wide logging facility that collects and displays log messages from various sources, including the Android system and applications.</p> <p>First, you must import the <code>Log</code> class at the top of your Kotlin file:</p> <pre><code>import android.util.Log\n</code></pre> <p>A good practice is to define a constant for the log tag, which is a string that identifies the source of the log message (usually the activity's name). This helps in filtering log messages in logcat.</p> <pre><code>private const val TAG = \"MainActivity\"\n</code></pre> <p>Then, you can use the various logging methods provided by the <code>Log</code> class to log messages at different levels of severity:</p> <pre><code>Log.v(TAG, \"Verbose log message\")\nLog.d(TAG, \"Debug log message\")\nLog.i(TAG, \"Info log message\")\nLog.w(TAG, \"Warning log message\")\nLog.e(TAG, \"Error log message\")\n</code></pre>"},{"location":"U03%20Android%20architecture/U03.1%20Android%20architecture%20copy/#intents","title":"Intents","text":"<p>An Intent in Android is a messaging object that you can use to request an action from another app component. Intents are used for various purposes, such as starting activities, services, or broadcasting messages.</p> <p>There are two main types of intents:</p> <ul> <li>Explicit Intents: These intents specify the exact component (activity, service, etc.) to start by providing the class name. They are typically used for starting activities within the same application.</li> </ul> <p>Example of an explicit intent to start a new activity:</p> <pre><code>val intent = Intent(this, SecondActivity::class.java)\nstartActivity(intent)\n</code></pre> <ul> <li>Implicit Intents: These intents do not specify a specific component but instead declare a general action to perform. The Android system then determines the best component to handle the intent based on the action and data provided.</li> </ul> <p>Example of an implicit intent to view a webpage:</p> <pre><code>val intent = Intent(\nIntent.ACTION_VIEW,\nUri.parse(\"https://www.example.com\")\n)\nstartActivity(intent)\n</code></pre>"},{"location":"U03%20Android%20architecture/U03.1%20Android%20architecture%20copy/#intent-filters","title":"Intent Filters","text":"<p>An Intent Filter is a declaration in the AndroidManifest.xml file that specifies the types of intents an activity, service, or broadcast receiver can respond to. Intent filters allow components to be discovered and invoked by other applications based on the actions and data they can handle.</p> <p>For example, to declare an activity that can handle the \"VIEW\" action for web URLs, you would add the following intent filter to the activity in the AndroidManifest.xml file:</p> <pre><code>&lt;activity android:name=\".SecondActivity\"&gt;\n&lt;intent-filter&gt;\n&lt;action android:name=\"android.intent.action.VIEW\" /&gt;\n&lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;\n&lt;data android:scheme=\"http\" /&gt;\n&lt;data android:scheme=\"https\" /&gt;\n&lt;/intent-filter&gt;\n&lt;/activity&gt;\n</code></pre> <p>This intent filter specifies that <code>SecondActivity</code> can handle the \"VIEW\" action for both \"http\" and \"https\" schemes.</p>"},{"location":"U03%20Android%20architecture/U03.2%20The%20MVVM%20pattern/","title":"Unit 3.2 The MVVM design pattern","text":"<p>The Model-View-ViewModel (MVVM) is a software architectural pattern that facilitates the separation of the development of the graphical user interface (the view) from the business logic or back-end logic (the model) such that the view is not dependent on any specific model platform. This separation allows for easier management of complex applications, improved testability, and enhanced maintainability.</p> <p>In Android development, MVVM is commonly used in conjunction with Jetpack libraries such as LiveData, ViewModel, and Data Binding. Here's a brief overview of each component in the MVVM pattern:</p> <ol> <li>Model: The Model represents the data and business logic of the application. It is responsible for managing the data, whether it comes from a local database, a remote server, or any other source. The Model should be independent of the View and ViewModel, allowing for easy testing and modification.</li> <li>View: The View is the user interface of the application. It displays data to the user and captures user input. In Android, the View is typically represented by Activities, Fragments, or custom Views. The View should be as passive as possible, meaning it should not contain any business logic or data manipulation code.</li> <li>ViewModel: The ViewModel acts as a bridge between the Model and the View. It is responsible for preparing and managing the data for the View, handling user interactions, and updating the View when the data changes. The ViewModel should not reference the View directly, allowing for better separation of concerns and easier testing.</li> </ol> <p></p>"},{"location":"U03%20Android%20architecture/U03.2%20The%20MVVM%20pattern/#recommended-app-architecture","title":"Recommended app architecture","text":"<p>Each app should have at least two layers:</p> <ul> <li>UI layer: a layer that displays the app data on the screen but is independent of the data.</li> <li>Data layer: a layer that stores, retrieves, and exposes the app data.</li> </ul> <p>You can add another layer, called the domain layer, to simplify and reuse the interactions between the UI and data layers. This layer is optional, but recommended for complex apps.</p> <p></p>"},{"location":"U03%20Android%20architecture/U03.2%20The%20MVVM%20pattern/#ui-layer","title":"UI layer","text":"<p>The role of the UI layer, or presentation layer (the View in the MVVM pattern), is to display the application data on the screen. Whenever the data changes due to a user interaction, such as pressing a button, the UI should update to reflect the changes.</p> <p>The UI layer is made up of the following components:</p> <ul> <li>UI elements: components that render the data on the screen. You build these elements using Jetpack Compose.</li> <li>State holders: components that hold the data, expose it to the UI, and handle the app logic. An example state holder is ViewModel.</li> </ul> <p></p>"},{"location":"U03%20Android%20architecture/U03.2%20The%20MVVM%20pattern/#viewmodel","title":"ViewModel","text":"<p>The ViewModel component holds and exposes the state the UI consumes. The UI state is application data transformed by ViewModel. ViewModel lets your app follow the architecture principle of separating the UI from the model.</p> <p>ViewModel stores the app-related data that isn't destroyed when the activity is destroyed and recreated by the Android framework. Unlike the activity instance, ViewModel objects are not destroyed. The app automatically retains ViewModel objects during configuration changes so that the data they hold is immediately available after the recomposition.</p> <p>To implement ViewModel in your app, extend the ViewModel class, which comes from the architecture components library and stores app data within that class.</p> <pre><code>class MyViewModel : ViewModel() {\n// Your app data here\n}\n</code></pre> <p>To create an instance of your ViewModel class on your composable functions, use the <code>viewModel()</code> function from the <code>androidx.lifecycle.viewmodel.compose</code> package. This function creates a ViewModel the first time the system calls it and retains the same instance during recompositions.</p> <pre><code>@Composable\nfun MyScreen() {\nval myViewModel: MyViewModel = viewModel()\n// Use the ViewModel\n}\n</code></pre>"},{"location":"U03%20Android%20architecture/U03.2%20The%20MVVM%20pattern/#ui-state","title":"UI State","text":"<p>The UI is what the user sees, and the UI state is what the app says they should see. The UI is the visual representation of the UI state. Any changes to the UI state immediately are reflected in the UI.</p> <p>The UI state is usually a data class that holds all the data the UI needs to display. For example, in a weather app, the UI state might include the current temperature, humidity, and weather conditions.</p> <pre><code>data class WeatherUiState(\nval temperature: String,\nval humidity: String,\nval conditions: String\n)\n</code></pre> <p>The ViewModel exposes the UI state to the UI layer using observable data holders, such as StateFlow or LiveData. The UI layer observes these data holders and updates the UI whenever the UI state changes.</p> <pre><code>class WeatherViewModel : ViewModel() {\nprivate val _uiState = MutableStateFlow(WeatherUiState(\"\", \"\", \"\"))\nval uiState: StateFlow&lt;WeatherUiState&gt; = _uiState\n\nfun updateWeather(temperature: String, humidity: String, conditions: String) {\n_uiState.value = WeatherUiState(temperature, humidity, conditions)\n}\n}\n</code></pre> <p>The UI layer collects the UI state from the ViewModel and uses it to render the UI.</p> <pre><code>@Composable\nfun WeatherScreen(weatherViewModel: WeatherViewModel = viewModel()) {\nval uiState by weatherViewModel.uiState.collectAsState()\nWeatherContent(uiState)\n}\n\n@Composable\nfun WeatherContent(uiState: WeatherUiState) {\n// Render the UI using the uiState\n}\n</code></pre>"},{"location":"U03%20Android%20architecture/U03.2%20The%20MVVM%20pattern/#data-layer","title":"Data layer","text":"<p>The data layer is responsible for managing the app's data. It handles data storage, retrieval, and manipulation. The data layer can interact with various data sources, such as local databases, remote servers, or in-memory caches.</p> <p></p> <p>We will see the data layer in more detail in the next unit.</p>"},{"location":"U03%20Android%20architecture/U03.3%20ViewModel%20guided%20practice/","title":"Unit 3.3 ViewModel guided practice","text":"<p>In this guided practice, we will add a <code>ViewModel</code> to an existing Jetpack Compose application to manage its UI state.</p> <p></p> <p>We will use the Tip Time project you already know from previous units.</p> <p>Get the repository from GitHub and make sure you are in the main branch:</p> <pre><code>git clone https://github.com/google-developer-training/basic-android-kotlin-compose-training-tip-calculator.git\ncd basic-android-kotlin-compose-training-tip-calculator\ngit checkout main\n</code></pre>"},{"location":"U03%20Android%20architecture/U03.3%20ViewModel%20guided%20practice/#1-create-the-viewmodel","title":"1. Create the ViewModel","text":"<p>Create a new Kotlin file called <code>TipTimeViewModel.kt</code> in the <code>ui/viewmodels</code> package (create the package first).</p> <pre><code>// TipTimeViewModel.kt\n\nclass TipTimeViewModel : ViewModel() {\n}\n</code></pre>"},{"location":"U03%20Android%20architecture/U03.3%20ViewModel%20guided%20practice/#2-create-the-data-class","title":"2. Create the data class","text":"<p>Create a new Kotlin class called <code>TipTimeState.kt</code> in the <code>ui/viewmodels</code> package.</p> <p>in ui/viewmodels:</p> <pre><code>// TipTimeState.kt\n\ndata class TipTimeState (\nval amountInput: String = \"\",\nval tipInput: String = \"15\",\nval roundUp: Boolean = false,\nval tip: String = \"\" )\n</code></pre> <p>This data class holds the UI state for the Tip Time app, including the input amount, tip percentage, round-up option, and calculated tip amount.</p>"},{"location":"U03%20Android%20architecture/U03.3%20ViewModel%20guided%20practice/#3-stateflow","title":"3. StateFlow","text":"<p>StateFlow is a data holder observable flow that emits the current and new state updates. Its value property reflects the current state value.</p> <p>To update state and send it to the flow, assign a new value to the value property of the MutableStateFlow class.</p> <pre><code>// TipTimeViewModel.kt\n\nclass TipTimeViewModel : ViewModel() {\nprivate val _uiState = MutableStateFlow(TipTimeState())\nval uiState : StateFlow&lt;TipTimeState&gt; = _uiState.asStateFlow()\n}\n</code></pre> <p>The <code>asStateFlow()</code> makes this mutable state flow a read-only state flow.</p> <p><code>_uiState</code> is a backing property for the public read-only property <code>uiState</code>.</p> <p>Info</p> <p>A backing property lets you return something from a getter other than the exact object.</p> <p>For var properties, the Kotlin framework generates getters and setters.</p> <p>For getter and setter methods, you can override one or both of these methods and provide your own custom behavior. To implement a backing property, you override the getter method to return a read-only version of your data.</p>"},{"location":"U03%20Android%20architecture/U03.3%20ViewModel%20guided%20practice/#4-pass-the-logic-to-the-viewmodel","title":"4. Pass the logic to the viewmodel","text":"<p>Refactor the <code>calculateTip</code> function: move it to the <code>ViewModel</code> file. Put inside the function the calculated variables from the <code>TipTimeLayout()</code>: <code>amount</code>, <code>tipPercent</code> and <code>roundUp</code>.</p> <pre><code>// TipTimeViewModel.kt\n\nclass TipTimeViewModel : ViewModel() {\n...\n\nprivate fun calculateTip(): Unit {\n// Get the current values from the sate\nval amount = _uiState.value.amountInput.toDoubleOrNull() ?: 0.0\nval tipPercent = _uiState.value.tipInput.toDoubleOrNull() ?: 15.0\nval roundUp = _uiState.value.roundUp\n\nvar tip = tipPercent / 100 * amount\nif (roundUp) {\ntip = ceil(tip)\n}\n\nval formattedTip = NumberFormat.getCurrencyInstance().format(tip)\n\n// Update the state with the calculated tip\n_uiState.update { currentState -&gt;\ncurrentState.copy(tip = formattedTip)\n}\n}\n\n}\n</code></pre> <p>The <code>_uiState.update</code> function updates the current state with the new calculated tip, making a copy of the previous state and modifying only the tip property.</p> <p>The next step is to create functions to update the state from the UI.</p> <pre><code>// TipTimeViewModel.kt\n\nclass TipTimeViewModel : ViewModel() {\n...\n\nfun updateAmountInput(newAmount: String) {\n_uiState.update { currentState -&gt;\ncurrentState.copy(amountInput = newAmount)\n}\ncalculateTip() // Recalculate the tip each time the amount changes\n}\n\nfun updateTipInput(newTipPercent: String) {\n_uiState.update { currentState -&gt;\ncurrentState.copy(tipInput = newTipPercent)\n}\ncalculateTip() // Recalculate the tip each time the amount changes\n}\n\nfun updateRoundUp(shouldRoundUp: Boolean) {\n_uiState.update { currentState -&gt;\ncurrentState.copy(roundUp = shouldRoundUp)\n}\ncalculateTip() // Recalculate the tip each time the amount changes\n}\n\n...\n\n}\n</code></pre>"},{"location":"U03%20Android%20architecture/U03.3%20ViewModel%20guided%20practice/#5-pass-the-data-to-the-ui","title":"5. Pass the data to the ui","text":"<p>Now, we need to modify the UI layer to use the ViewModel.</p> <p>Pass the ViewModel instance to the UI, from the <code>TipTimeViewModel</code> to the <code>TipTimeLayout()</code> in the <code>MainActivity.kt</code> file. In the <code>TipTimeLayout()</code>, use the <code>ViewModel</code> instance to access the <code>uiState</code> using <code>collectAsState()</code>.</p> <pre><code>// MainActivity.kt\n\nfun TipTimeLayout(\ntipTimeViewModel: TipTimeViewModel = viewModel()\n) {\nval tipTimeUiState by tipTimeViewModel.uiState.collectAsState()\n...\n</code></pre> <p>To use this the <code>viewModel()</code> function, you must include the necessary dependency in your build.gradle.kts (or build.gradle) app file:</p> <pre><code>// build.gradle.kts\ndependencies {\n...\nimplementation \"androidx.lifecycle:lifecycle-viewmodel-compose:2.9.4\"\n...\n}\n</code></pre> <p>Update the EditFields, Text and Switch to use the ViewModel instance:</p> <pre><code>// TipTimeLayout.kt\n\nfun TipTimeLayout(\ntipTimeViewModel: TipTimeViewModel = viewModel() //ViewModel injection\n) {\n...\nEditNumberField(\n// Other options\nvalue = tipTimeUiState.amountInput , onValueChanged = { tipTimeViewModel.updateAmountInput(it) },\n)\n\nEditNumberField(\n// Other options\nvalue = tipTimeUiState.tipInput, onValueChanged = { tipTimeViewModel.updateTipInput(it) },\n)\n\nRoundTheTipRow(\nroundUp = tipTimeUiState.roundUp, onRoundUpChanged = { tipTimeViewModel.updateRoundUp(it) },\n// Other options\n)\n\nText(\ntext = stringResource(R.string.tip_amount, tipTimeUiState.tip), // Other options\n)\n}\n</code></pre> <p><code>tipTimeViewModel</code> and <code>tipTimeUiState</code> are the only objects we need to save and retrieve the state. Delete all the other variables related to state in the <code>TipTimeLayout()</code> function.</p> <p>That's all! Check the behavior of the app. It should work as before, but now the logic is separated from the UI.</p> <p>Check also rotations and configuration changes. The data should persist.</p>"},{"location":"U03%20Android%20architecture/U03.3%20ViewModel%20guided%20practice/#6-uml-diagrams-and-source-code","title":"6. UML diagrams and source code","text":""},{"location":"U03%20Android%20architecture/U03.3%20ViewModel%20guided%20practice/#class-diagram","title":"Class diagram","text":"<pre><code>classDiagram\n    class MainActivity {\n        +onCreate(Bundle)\n    }\n\n    class TipTimeLayout {\n        +TipTimeLayout(TipTimeViewModel)\n    }\n\n    class TipTimeViewModel {\n        +uiState: StateFlow&lt;TipTimeState&gt;\n        +updateAmountInput(String)\n        +updateTipInput(String)\n        +updateRoundUp(Boolean)\n        -calculateTip()\n    }\n\n    class TipTimeState {\n        +amountInput: String\n        +tipInput: String\n        +roundUp: Boolean\n        +tip: String\n    }\n\n    MainActivity --&gt; TipTimeLayout : creates\n    TipTimeLayout ..&gt; TipTimeViewModel : updates\n    TipTimeLayout ..&gt; TipTimeState : observes\n    TipTimeViewModel --&gt; TipTimeState : holds and updates</code></pre>"},{"location":"U03%20Android%20architecture/U03.3%20ViewModel%20guided%20practice/#sequence-diagram","title":"Sequence diagram","text":"<pre><code>sequenceDiagram\n    participant TextField as \"TextField (UI)\"\n    participant TipTimeViewModel as \"ViewModel\"\n    participant TipTimeState as \"Data Model\"\n    Note over TextField: User enters text\n    TextField-&gt;&gt;TipTimeViewModel: onValueChanged(text)\n    TipTimeViewModel-&gt;&gt;TipTimeViewModel: updateAmountInput(text)\n    TipTimeViewModel-&gt;&gt;TipTimeState: copy(...) with new value\n    TipTimeState--&gt;&gt;TipTimeViewModel: returns a new state object\n    Note over TipTimeViewModel: updates its internal StateFlow\n    TipTimeViewModel--&gt;&gt;TextField: recomposes with the new value</code></pre>"},{"location":"U03%20Android%20architecture/U03.3%20ViewModel%20guided%20practice/#source-code","title":"Source code","text":"<p>Tip Time with ViewModel on GitHub</p>"},{"location":"U03%20Android%20architecture/U03.4%20Navigation/","title":"Unit 3.4 Android Navigation","text":"<p>Navigation refers to the interactions that let users navigate across, into, and back out from the different pieces of content within your app.</p>"},{"location":"U03%20Android%20architecture/U03.4%20Navigation/#key-concepts","title":"Key concepts","text":"Concept Purpose Type Host A UI element that contains the current navigation destination. That is, when a user navigates through an app, the app essentially swaps destinations in and out of the navigation host. <code>NavHost</code> Graph A data structure that defines all the navigation destinations within the app and how they connect together. <code>NavGraph</code> Controller The central coordinator for managing navigation between destinations. The controller offers methods for navigating between destinations, handling deep links, managing the back stack, and more. <code>NavController</code> Destination A node in the navigation graph. When the user navigates to this node, the host displays its content. <code>NavDestination</code>Typically created when constructing the navigation graph. Route Uniquely identifies a destination and any data required by it.You can navigate using routes. Routes take you to destinations. Any serializable data type."},{"location":"U03%20Android%20architecture/U03.4%20Navigation/#set-up-the-environment","title":"Set up the environment","text":"<p>To include navigation support in your project, add the following dependencies to your app's build.gradle file:</p> <pre><code>plugins {\n// Kotlin serialization plugin for type safe routes and navigation arguments\nkotlin(\"plugin.serialization\") version \"2.0.21\"\n}\n\ndependencies {\nval nav_version = \"2.9.5\"\n\n// Jetpack Compose integration\nimplementation(\"androidx.navigation:navigation-compose:$nav_version\")\n\n// Views/Fragments integration\nimplementation(\"androidx.navigation:navigation-fragment:$nav_version\")\nimplementation(\"androidx.navigation:navigation-ui:$nav_version\")\n\n// Feature module support for Fragments\nimplementation(\"androidx.navigation:navigation-dynamic-features-fragment:$nav_version\")\n\n// Testing Navigation\nandroidTestImplementation(\"androidx.navigation:navigation-testing:$nav_version\")\n\n// JSON serialization library, works with the Kotlin serialization plugin\nimplementation(\"org.jetbrains.kotlinx:kotlinx-serialization-json:1.7.3\")\n}\n</code></pre>"},{"location":"U03%20Android%20architecture/U03.4%20Navigation/#create-a-navigation-controller","title":"Create a navigation controller","text":"<p>A <code>NavController</code> is the central component of the Navigation Architecture Component. It manages app navigation within a <code>NavHost</code>.</p> <p>When using the navigation component with Jetpack Compose, you can create a <code>NavController</code> by calling the <code>rememberNavController()</code> function. This function creates and remembers a <code>NavController</code> instance that you can use to navigate between composables.</p> <pre><code>val navController: NavHostController = rememberNavController()\n</code></pre>"},{"location":"U03%20Android%20architecture/U03.4%20Navigation/#create-a-navigation-host","title":"Create a navigation host","text":"<p>Once you have a <code>NavController</code>, you can create a <code>NavHost</code> to host your composables and manage navigation between them. The <code>NavHost</code> is responsible for displaying the current destination and handling navigation actions.</p> <p>Place your NavHost inside a composable function, typically within your app's main screen or activity.</p> <pre><code>Scaffold {\nval navController: NavHostController = rememberNavController()\n\nNavHost(\nnavController = navController,\nstartDestination = \"home\"\n) {\ncomposable(\"home\") { HomeScreen(navController) }\ncomposable(\"details\") { DetailsScreen(navController) }\n}\n}\n</code></pre> <p>In this example, the <code>NavHost</code> is set up with two destinations: \"home\" and \"details\". The <code>startDestination</code> parameter specifies the initial screen to display when the app starts.</p>"},{"location":"U03%20Android%20architecture/U03.4%20Navigation/#navigate-between-destinations","title":"Navigate between destinations","text":"<p>To navigate between destinations, you can use the <code>navigate()</code> method of the <code>NavController</code>. You can call this method from within your composable functions, typically in response to user actions such as button clicks.</p> <pre><code>@Composable\nfun HomeScreen(navController: NavHostController) {\nButton(onClick = {\nnavController.navigate(\"details\")\n}) {\nText(\"Go to Details\")\n}\n}\n</code></pre> <p>You also can navigate to the previous destination using the <code>navigateUp()</code> method:</p> <pre><code>@Composable\nfun DetailsScreen(navController: NavHostController) {\nButton(onClick = {\nnavController.navigateUp()\n}) {\nText(\"Back\")\n}\n}\n</code></pre>"},{"location":"U03%20Android%20architecture/U03.4%20Navigation/#routes","title":"Routes","text":"<p>A route is a string that uniquely identifies a destination in the navigation graph. You can define routes with enum classes for better type safety and organization.</p> <pre><code>enum class AppDestinations(val route: String) {\nHOME(\"home\"),\nDETAILS(\"details\")\n}\n...\nNavHost(\nnavController = navController,\nstartDestination = AppDestinations.HOME.route\n) {\ncomposable(AppDestinations.HOME.route) { HomeScreen(navController) }\ncomposable(AppDestinations.DETAILS.route) { DetailsScreen(navController) }\n}\n</code></pre>"},{"location":"U03%20Android%20architecture/U03.4%20Navigation/#summary","title":"Summary","text":"<p>In this unit, you have learned the basics of Android Navigation using Jetpack Compose. You have seen how to set up a navigation controller, create a navigation host, define destinations, and navigate between them using routes. With this knowledge, you can build more complex navigation flows in your Android applications.</p>"},{"location":"U03%20Android%20architecture/U03.5%20Navigation%20guided%20practice/","title":"Unit 3.5 Android Navigation Guided Practice","text":"<p>In this guided practice, we will add navigation to the TipTime application using the Jetpack Navigation component. We will add one more screen and a top bar with navigation capabilities.</p>"},{"location":"U03%20Android%20architecture/U03.5%20Navigation%20guided%20practice/#parts-of-the-navigation-component","title":"Parts of the Navigation Component","text":"<p>The Navigation component has three main parts:</p> <ul> <li>NavController: Responsible for navigating between destinations\u2014that is, the screens in your app.</li> <li>NavGraph: Maps composable destinations to navigate to.</li> <li>NavHost: Composable acting as a container for displaying the current destination of the NavGraph.</li> </ul> <p>In this guided practice, you'll focus on the NavController and the NavHost. Within the NavHost, you'll define the destinations for the TipTime app's NavGraph.</p>"},{"location":"U03%20Android%20architecture/U03.5%20Navigation%20guided%20practice/#1-create-the-tiptimeresult-and-start-layouts","title":"1. Create the TipTimeResult and Start layouts","text":"<p>Move the <code>Column</code> from inside the <code>TipTimeLayout</code> composable to its own composable function called <code>TipTimeStartScreen</code>. Add parameters for the <code>tipTimeViewModel</code> and <code>modifier</code>.</p> <pre><code>// TipTimeStartScreen.kt\n\n@Composable\nfun TipTimeStartScreen(\nmodifier: Modifier = Modifier,\ntipTimeViewModel: TipTimeViewModel = viewModel(),\n) {\nval tipTimeUiState by tipTimeViewModel.uiState.collectAsState()\n\nColumn(\n... // Existing content\n</code></pre> <p>Note how we pass the <code>tipTimeViewModel</code> as a parameter. The <code>uiState</code> is collected from the ViewModel as before.</p> <p>Create a new Kotlin file called <code>TipTimeResultScreen.kt</code> in the <code>ui</code> package.</p> <pre><code>// TipTimeResultScreen.kt\n\n@Composable\nfun TipTimeResultScreen(\nmodifier: Modifier = Modifier,\ntipTimeViewModel: TipTimeViewModel = viewModel(),\n) {\nval tipTimeUiState by tipTimeViewModel.uiState.collectAsState()\n\nColumn(\nmodifier = modifier\n.statusBarsPadding()\n.verticalScroll(rememberScrollState())\n.safeDrawingPadding(),\nhorizontalAlignment = Alignment.Companion.CenterHorizontally,\nverticalArrangement = Arrangement.Center\n) {\nText(\ntext = stringResource(R.string.tip_amount, tipTimeUiState.tip),\nstyle = MaterialTheme.typography.titleLarge,\n)\nText(\ntext = stringResource(R.string.total, tipTimeUiState.total),\nstyle = MaterialTheme.typography.titleLarge,\n)\n}\n}\n</code></pre>"},{"location":"U03%20Android%20architecture/U03.5%20Navigation%20guided%20practice/#2-defining-routes","title":"2. Defining routes","text":"<p>In the TipTime app, you will have the following routes:</p> <ul> <li>Start: The main screen where users can enter their tip amount and select a tip percentage.</li> <li>TipResult: The screen that displays the calculated tip amount and total bill.</li> </ul> <p>A route is a string that uniquely identifies a destination in the navigation graph. You can define routes as constants in a separate file for better organization.</p> <p>Create a new Kotlin file called <code>Routes.kt</code> in the <code>ui</code> package.</p> <pre><code>// Routes.kt\n\n...\nimport com.example.tiptime.R\n\nenum class Routes(@StringRes val title: Int) {\nStart (title = R.string.app_name),\nTipResult (title = R.string.tip_result)\n}\n</code></pre> <p>In this class we define an enum class <code>Routes</code> with two routes: <code>Start</code> and <code>TipResult</code>. Each route has an associated string resource for the title.</p>"},{"location":"U03%20Android%20architecture/U03.5%20Navigation%20guided%20practice/#3-add-a-navhost","title":"3. Add a NavHost","text":"<p>A NavHost is a composable that displays other composable destination, based on a given route. For example, if the current route is <code>TipResult</code>, the NavHost will display the <code>TipResultScreen</code> composable.</p> <p>The syntax for a NavHost is as follows:</p> <pre><code>NavHost(\nnavController: NavController,\nstartDestination: String,\nmodifier: Modifier = Modifier,\n) {\n// Content\n}\n</code></pre> <p>There are two important parameters.</p> <ul> <li>navController: An instance of the <code>NavHostController</code> class. You can use this object to navigate between screens, for example, by calling the <code>navigate()</code> method to navigate to another destination. You can obtain the <code>NavHostController</code> by calling <code>rememberNavController()</code> from a composable function.</li> <li>startDestination: A string route defining the destination shown by default when the app first displays the NavHost. In the case of the TipTime app, this should be the Start route.</li> </ul> <p>Like other composables, NavHost also takes a modifier parameter.</p> <p>Inside the TipTimeLayout composable, add the NavHost as follows (if you don't have a Scaffold yet, add it now):</p> <pre><code>// TipTimeLayout.kt\n\n...\nimport androidx.navigation.NavHostController\nimport androidx.navigation.compose.NavHost\nimport androidx.navigation.compose.rememberNavController\n...\n\n@Composable\nfun TipTimeLayout(\ntipTimeViewModel: TipTimeViewModel = viewModel(),\nnavController: NavHostController = rememberNavController()\n) {\nScaffold() { innerPadding -&gt;\nval tipTimeUiState by tipTimeViewModel.uiState.collectAsState()\n\nNavHost(\nnavController = navController,\nstartDestination = Routes.Start.name,\nmodifier = Modifier.padding(innerPadding)\n) {\n\n}\n...\n</code></pre> <p>Before adding the destinations, ensure you have the necessary dependencies for navigation in your <code>build.gradle.kts</code> (or <code>build.gradle</code>) app file:</p> <pre><code>// build.gradle.kts\ndependencies {\n...\nimplementation \"androidx.navigation:navigation-compose:2.9.4\"\n...\n}\n</code></pre>"},{"location":"U03%20Android%20architecture/U03.5%20Navigation%20guided%20practice/#4-add-destinations-to-the-navhost","title":"4. Add destinations to the NavHost","text":"<p>Inside the NavHost block, add the composable destinations for the Start and Result screens, adding a <code>composable()</code> function.</p> <p>The composable function has two required parameters:</p> <ol> <li>route: A string that uniquely identifies the name of the destination. You'll use the name of the enum values defined in the <code>Routes</code> enum class.</li> <li>content: A composable function that defines the UI for the destination.</li> </ol> <pre><code>// TipTimeLayout.kt\n\nNavHost(\nnavController = navController,\nstartDestination = Routes.Start.name,\nmodifier = Modifier.padding(innerPadding)\n) {\ncomposable( route = Routes.Start.name) {\nTipTimeStartScreen(\ntipTimeViewModel = tipTimeViewModel,\nmodifier = Modifier\n.fillMaxSize()\n.padding(40.dp)\n)\n\n}\ncomposable(route = Routes.TipResult.name) {\nTipTimeResultScreen(\ntipTimeViewModel = tipTimeViewModel,\nmodifier = Modifier\n.fillMaxSize()\n.padding(40.dp)\n)\n}\n}\n...\n</code></pre> <p>Run the app on the emulator or a physical device to ensure everything is working correctly. You should see the Start screen of the TipTime app.</p>"},{"location":"U03%20Android%20architecture/U03.5%20Navigation%20guided%20practice/#5-navigate-between-destinations","title":"5. Navigate between destinations","text":"<p>We will add 2 buttons to our app that will allow us to navigate from the Start to the Result screen and back.</p> <p>Add a button to the <code>TipTimeStartScreen</code> composable that navigates to the Result screen when clicked. It needs a lambda which will be called when the button is clicked.</p> <pre><code>// TipTimeStartScreen.kt\n\n@Composable\nfun TipTimeStartScreen(\nonNextButtonClicked: () -&gt; Unit, //ADD THIS\nmodifier: Modifier = Modifier,\ntipTimeViewModel: TipTimeViewModel = viewModel(),\n) {\nval tipTimeUiState by tipTimeViewModel.uiState.collectAsState()\n\nColumn(\n// Existing content\n) {\n// Existing content\nSpacer(modifier = Modifier.height(30.dp))\nButton(\nonClick = onNextButtonClicked,\n) {\nText(stringResource(R.string.next))\n}\n\n}\n</code></pre> <p>The <code>onNextButtonClicked</code> parameter is the lambda function that will be called when the button is clicked.</p> <p>Do the same on the <code>TipTimeResultScreen</code> composable to navigate back to the Start screen.</p> <pre><code>// TipTimeResultScreen.kt\n\n@Composable\nfun TipTimeResultScreen(\nonBackButtonClicked: () -&gt; Unit, //ADD THIS\nmodifier: Modifier = Modifier,\ntipTimeViewModel: TipTimeViewModel = viewModel(),\n) {\nval tipTimeUiState by tipTimeViewModel.uiState.collectAsState()\n\nColumn(\n// Existing content\n) {\n// Existing content\nSpacer(modifier = Modifier.height(30.dp))\nButton(\nonClick = onBackButtonClicked,\n) {\nText(stringResource(R.string.back))\n}\n}\n}\n</code></pre> <p>Now, go back to the <code>TipTimeLayout</code> composable and pass the navigation actions to the <code>TipTimeStartScreen</code> and <code>TipTimeResultScreen</code> composables.</p> <pre><code>// TipTimeLayout.kt\n\n...kotlin\nNavHost(\nnavController = navController,\nstartDestination = Routes.Start.name,\nmodifier = Modifier.padding(innerPadding)\n) {\ncomposable( route = Routes.Start.name) {\nTipTimeStartScreen(\ntipTimeViewModel = tipTimeViewModel,\nonNextButtonClicked = { navController.navigate(Routes.TipResult.name) }, //ADD THIS\nmodifier = Modifier\n.fillMaxSize()\n.padding(40.dp)\n)\n}\ncomposable(route = Routes.TipResult.name) {\nTipTimeResultScreen(\ntipTimeViewModel = tipTimeViewModel,\nonBackButtonClicked = { navController.navigate(Routes.Start.name) }, //ADD THIS\nmodifier = Modifier\n.fillMaxSize()\n.padding(40.dp)\n)\n}\n}\n</code></pre> <p>The <code>onNextButtonClicked</code> lambda navigates to the <code>TipResult</code> route when the button is clicked, and the <code>onBackButtonClicked</code> lambda navigates back to the <code>Start</code> route.</p> <p>Run your app again. You should be able to navigate between the Start and Result screens using the buttons.</p>"},{"location":"U03%20Android%20architecture/U03.5%20Navigation%20guided%20practice/#6-add-a-topappbar-with-navigation-support","title":"6. Add a TopAppBar with navigation support","text":"<p>First, create a new composable function called <code>TipTimeTopBar</code> in the <code>TipTimeLayout.kt</code> file (create it in a separate file if you want).</p> <pre><code>@Composable\nfun TipTimeTopBar(\ncurrentScreen: Routes,\ncanNavigateBack: Boolean,\nmodifier: Modifier = Modifier,\nnavigateUp: () -&gt; Unit = {},\n) {\n\n}\n</code></pre> <p>The parameters are as follows:</p> <ul> <li>currentScreen: The current screen being displayed. This is used to set the title of the top bar.</li> <li>canNavigateBack: A boolean indicating whether the user can navigate back from the current screen. This is used to determine whether to show the back button.</li> <li>navigateUp: A lambda function that is called when the back button is clicked.</li> </ul> <p>In the body of the <code>TipTimeTopBar</code> function, add a <code>TopAppBar</code> composable.</p> <pre><code>fun TipTimeTopBar(\n// existing parameters\n) {\nTopAppBar(\ntitle = { Text(stringResource(currentScreen.title)) },\ncolors = TopAppBarDefaults.topAppBarColors(\ncontainerColor = MaterialTheme.colorScheme.primaryContainer,\n),\nmodifier = modifier,\nnavigationIcon = {\nif (canNavigateBack) {\nIconButton(onClick = navigateUp) {\nIcon(\nimageVector = Icons.AutoMirrored.Filled.ArrowBack,\ncontentDescription = stringResource(R.string.back)\n)\n}\n}\n}\n)\n}\n</code></pre> <p>The <code>title</code> will display the title of the current screen, stored in the <code>Routes</code> enum class. If <code>canNavigateBack</code> is true, a back button will be displayed that calls the <code>navigateUp</code> lambda when clicked.</p> <p>To use the icons remember to include the required dependency in your <code>build.gradle.kts</code> (or <code>build.gradle</code>) app file:</p> <pre><code>// build.gradle.kts\ndependencies {\n...\nimplementation(\"androidx.compose.material:material-icons-extended-android:1.6.8\")\n...\n</code></pre> <p>And, in the <code>TipTimeLayout</code> composable:</p> <pre><code>import androidx.compose.material.icons.Icons\nimport androidx.compose.material.icons.automirrored.filled.ArrowBack\n</code></pre> <p>The Up button should only show if there's a composable on the back stack. If the app has no screens on the back stack (we are at the Start screen) then the Up button should not be shown. To check this, you need a reference to the back stack. For that, you can use the <code>currentBackStackEntryAsState()</code> extension function of <code>NavController</code>.</p> <pre><code>// TipTimeLayout.kt\n\nimport androidx.navigation.compose.currentBackStackEntryAsState\n\n@Composable\nfun TipTimeLayout(\ntipTimeViewModel: TipTimeViewModel = viewModel(),\nnavController: NavHostController = rememberNavController()\n) {\n// Get current back stack entry\nval backStackEntry by navController.currentBackStackEntryAsState()\n// Get the name of the current screen\nval currentScreen = Routes.valueOf(\nbackStackEntry?.destination?.route ?: Routes.Start.name\n)\n...\n</code></pre> <p><code>currentScreen</code> is equal to the result of calling the <code>valueOf()</code> class function of <code>Routes</code>. The route of the destination is the indicated by <code>backStackEntry</code>, or the default value of <code>Routes.Start.name</code>.</p> <p>Now, we can pass the value of <code>currentScreen</code> to the <code>TipTimeTopBar</code> composable. For the <code>canNavigateBack</code> parameter, pass in a boolean expression checking if the <code>previousBackStackEntry</code> property of <code>navController</code> is not equal to <code>null</code>. Finally, to navigate back to the previous screen, call the <code>navigateUp()</code> method of <code>navController</code>:</p> <pre><code>// TipTimeLayout.kt\n\nScaffold(\ntopBar = {\nTipTimeTopBar(\ncurrentScreen = currentScreen,\ncanNavigateBack = navController.previousBackStackEntry != null,\nnavigateUp = { navController.navigateUp() },\n)\n...\n</code></pre> <p>Check the app again. You should see the TopAppBar with the title of the current screen. When you navigate to the Result screen, the back button should appear, allowing you to navigate back to the Start screen.</p>"},{"location":"U03%20Android%20architecture/U03.5%20Navigation%20guided%20practice/#7-add-a-share-button","title":"7. Add a share button","text":"<p>We want to add a share button to the TopAppBar on the Result screen. This button will allow users to share the tip amount and total bill using other apps on their device.</p> <p>To do that, we must first create an intent to share the text. The intent type that we need is <code>ACTION_SEND</code> with MIME type <code>\"text/plain\"</code>.</p> <p>In <code>TipTimeLayout.kt</code>, create a private function called <code>createShareIntent</code> that takes the tip and total values as parameters and returns an <code>Intent</code>:</p> <pre><code>// TipTimeLayout.kt\n\nimport android.content.Intent\n\nprivate fun createShareIntent(context: Context, tip: String, total: String) {\nval shareText = context.getString(R.string.tip_amount_total_bill, tip, total)\n// Create an ACTION_SEND implicit intent with order details in the intent extras\nval intent = Intent(Intent.ACTION_SEND).apply {\ntype = \"text/plain\"\nputExtra(Intent.EXTRA_SUBJECT, context.getString(R.string.your_tip))\nputExtra(Intent.EXTRA_TEXT, shareText)\n}\ncontext.startActivity(\nIntent.createChooser(\nintent,\ncontext.getString(R.string.your_tip)\n)\n)\n}\n</code></pre> <p>Context</p> <p>The Context in Android is an interface to global information about an application environment. It allows access to application-specific resources and classes, as well as up-calls for application-level operations such as launching activities, broadcasting, and receiving intents, etc.</p> <p>Don't forget to create the string resources:</p> <pre><code>// res/values/strings.xml\n...\n&lt;string name=\"tip_amount_total_bill\"&gt;Tip Amount: %s\\nTotal Bill: %s&lt;/string&gt;\n&lt;string name=\"your_tip\"&gt;Your tip&lt;/string&gt;\n&lt;string name=\"share\"&gt;Share&lt;/string&gt;\n...\n</code></pre> <p>We need 2 more parameters in the <code>TipTimeTopBar</code> composable (<code>showShare</code> and <code>onShareClicked</code>), along with an <code>actions</code> parameter:</p> <pre><code>// AppBar.kt\n\n@Composable\nfun TipTimeTopBar(\n// Existing parameters\nshowShare: Boolean = false,\nonShareClicked: () -&gt; Unit = {},\n) {\nTopAppBar(\n// Existing parameters\nactions = {\nif (showShare) {\nIconButton(onClick = onShareClicked) {\nIcon(\nimageVector = Icons.Filled.Share,\ncontentDescription = stringResource(R.string.share)\n)\n}\n}\n}\n)\n}\n</code></pre> <p>The <code>actions</code> content is displayed at the end of the top app bar. This should typically be <code>IconButtons</code>. The default layout here is a Row, so icons inside will be placed horizontally.</p> <p>The last step is to call pass the new parameter values to the <code>TipTimeTopBar</code> from the Scaffold topBar:</p> <pre><code>// TipTimeLayout.kt\n\n...\nScaffold(\ntopBar = {\nTipTimeTopBar(\n// existing parameters\nshowShare = currentScreen == Routes.TipResult,\nonShareClicked = { createShareIntent(context, tip = uiState.tip, total = uiState.total) }\n)\n...\n</code></pre> <p>The <code>showShare</code> boolean is true only when the current screen is the <code>TipResult</code> screen. The <code>onShareClicked</code> lambda calls the <code>createShareIntent</code> function with the tip and total values from the <code>uiState</code>.</p> <p>This should work. Launch your app and check if the share button appears on the Result screen. When clicked, it should open a chooser dialog with available apps to share the tip amount and total bill.</p>"},{"location":"U03%20Android%20architecture/U03.5%20Navigation%20guided%20practice/#source-code","title":"Source code","text":"<p>You can find the complete source code for this guided practice on GitHub: TipTime with Navigation, branch <code>navigation</code>.</p>"},{"location":"U04%20Persistence%20with%20Room/U04.1%20Persistence%20with%20Room/","title":"Unit 4.1. Android persistence with Room","text":"<p>Room is a persistence library that provides an abstraction layer over SQLite to allow fluent database access while harnessing the full power of SQLite. It simplifies the database interactions and provides compile-time checks of SQL queries, reducing the likelihood of runtime errors.</p>"},{"location":"U04%20Persistence%20with%20Room/U04.1%20Persistence%20with%20Room/#sqlite","title":"SQLite","text":"<p>SQLite is a lightweight, embedded relational database management system (RDBMS) that is widely used in mobile applications, including Android. It is a serverless database engine that stores data in a single file on the device's file system. SQLite supports standard SQL syntax and provides features such as transactions, indexing, and data types.</p> <p>SQLite is similar to other relational database management systems, but it has some differences in the types of data.</p> <p>In the next table you can see the mapping between SQLite data types and Java/Kotlin data types:</p> SQLite Data Type Kotlin Data Type INTEGER Int, Long REAL Float, Double TEXT String INTEGER (0 or 1) Boolean BLOB Byte[] NULL null <p>The tipical SQL operations are similar to other RDBMS.</p> <pre><code>-- Insert a new record\nINSERT INTO users (name, age) VALUES ('John Doe', 30);\n\n-- Query records\nSELECT * FROM users ORDER BY name LIMIT 10;\nSELECT * FROM users WHERE id = 12;\n\n-- Update a record\nUPDATE users SET age = 31 WHERE name = 'John Doe';\n\n-- Delete a record\nDELETE FROM users WHERE name = 'John Doe';\n</code></pre>"},{"location":"U04%20Persistence%20with%20Room/U04.1%20Persistence%20with%20Room/#the-data-layer","title":"The data layer","text":"<p>The data layer is responsible for managing the app's data, including storing, retrieving, and updating data. In Android, the data layer can be implemented using various technologies, such as SQLite, Room, SharedPreferences, or network APIs.</p> <p></p> <p>In this unit, we will focus on using Room as the data layer for Android applications.</p>"},{"location":"U04%20Persistence%20with%20Room/U04.1%20Persistence%20with%20Room/#room-components","title":"Room components","text":"<p>Room is an ORM (Object Relational Mapping) library that provides an abstraction layer over SQLite. It simplifies database access and provides compile-time checks for SQL queries.</p> <p>Room consists of three main components: Entity, DAO (Data Access Object), and Database.</p> <p></p>"},{"location":"U04%20Persistence%20with%20Room/U04.1%20Persistence%20with%20Room/#declaring-room-dependencies","title":"Declaring Room dependencies","text":"<p>To use Room in your Android project, you need to add the following dependencies to your <code>build.gradle</code> file:</p> <pre><code>dependencies {\nval room_version = \"2.8.3\"\n\nimplementation(\"androidx.room:room-runtime:$room_version\")\n\n// If this project uses any Kotlin source, use Kotlin Symbol Processing (KSP)\n// See Add the KSP plugin to your project\nksp(\"androidx.room:room-compiler:$room_version\")\n\n// If this project only uses Java source, use the Java annotationProcessor\n// No additional plugins are necessary\nannotationProcessor(\"androidx.room:room-compiler:$room_version\")\n\n// optional - Kotlin Extensions and Coroutines support for Room\nimplementation(\"androidx.room:room-ktx:$room_version\")\n\n// optional - RxJava2 support for Room\nimplementation(\"androidx.room:room-rxjava2:$room_version\")\n\n// optional - RxJava3 support for Room\nimplementation(\"androidx.room:room-rxjava3:$room_version\")\n\n// optional - Guava support for Room, including Optional and ListenableFuture\nimplementation(\"androidx.room:room-guava:$room_version\")\n\n// optional - Test helpers\ntestImplementation(\"androidx.room:room-testing:$room_version\")\n\n// optional - Paging 3 Integration\nimplementation(\"androidx.room:room-paging:$room_version\")\n}\n</code></pre> <p>For adding KSP to your project, include the following in your top-level <code>build.gradle</code> file:</p> <pre><code>plugins {\n//Previously declared plugins\nid(\"com.google.devtools.ksp\") version \"2.0.21-1.0.27\" apply false\n}\n</code></pre> <p>Then, enable KSP in your app-level <code>build.gradle.kts</code> file:</p> <pre><code>//Previously declared plugins\nplugins {\nid(\"com.google.devtools.ksp\")\n}\n</code></pre> <p>Info</p> <p>KSP (Kotlin Symbol Processing) is a powerful tool for generating code at compile time. It is specifically designed for Kotlin and provides better performance and integration with Kotlin features compared to traditional annotation processors. Room uses KSP to generate the necessary code for database operations based on the annotations you provide in your Entity and DAO classes.</p> <p>More about Room</p>"},{"location":"U04%20Persistence%20with%20Room/U04.1%20Persistence%20with%20Room/#entity","title":"Entity","text":"<p>An Entity represents a table in the database. It is defined using a Kotlin data class annotated with <code>@Entity</code>. Each property of the data class corresponds to a column in the table.</p> <pre><code>import androidx.room.Entity\nimport androidx.room.PrimaryKey\n\n@Entity(tableName = \"users\")\ndata class User(\n@PrimaryKey(autoGenerate = true)\nval id: Int = 0,\nval name: String,\nval age: Int\n)\n</code></pre> <p>Another annotations that we can use in an Entity are:</p> <ul> <li><code>@ColumnInfo</code>: Specifies the column name in the database.</li> <li><code>@Ignore</code>: Excludes a property from being persisted in the database.</li> <li><code>@Embedded</code>: Allows embedding another data class as a column in the entity (used for relationships between entities).</li> <li><code>@ForeignKey</code>: Defines a foreign key relationship between two entities.</li> <li><code>@Index</code>: Creates an index on one or more columns to improve query performance.</li> <li><code>@TypeConverters</code>: Specifies custom type converters for complex data types.</li> <li><code>@Relation</code>: Defines a relationship between two entities (used in conjunction with <code>@Embedded</code>).</li> </ul> <p>Example:</p> <pre><code>@Entity(tableName = \"orders\")\ndata class Order(\n@PrimaryKey(autoGenerate = true)\nval orderId: Int = 0,\n@ForeignKey(\nentity = User::class,\nparentColumns = [\"id\"],\nchildColumns = [\"userId\"],\nonDelete = ForeignKey.CASCADE\n)\nval userId: Int,\n@ColumnInfo(name = \"product_name\")\nval product: String,\n@ColumnInfo(name = \"quantity_ordered\")\nval quantity: Int\n@Ignore\nval tempData: String // This property will not be persisted in the database\n)\n</code></pre> <p>More about Entities</p>"},{"location":"U04%20Persistence%20with%20Room/U04.1%20Persistence%20with%20Room/#dao-data-access-object","title":"DAO (Data Access Object)","text":"<p>A DAO is an interface that defines the methods for accessing the database. It is annotated with <code>@Dao</code> and contains methods for performing CRUD (Create, Read, Update, Delete) operations on the entities.</p> <pre><code>import androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.Query\nimport androidx.room.Update\nimport androidx.room.Delete\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface UserDao {\n@Insert(onConflict = OnConflictStrategy.IGNORE)\nsuspend fun insertUser(user: User): Long //Returns the new rowId\n\n@Query(\"SELECT * FROM users\")\nfun getAllUsers(): Flow&lt;List&lt;User&gt;&gt;\n\n@Query(\"SELECT * FROM users WHERE id = :userId\")\nsuspend fun getUserById(userId: Int): User?\n\n@Update\nsuspend fun updateUser(user: User)\n\n@Delete\nsuspend fun deleteUser(user: User)\n}\n</code></pre> <p>The <code>@Insert</code> operation can produce a conflict. A conflict occurs when you try to insert a new row that has the same primary key or unique constraint as an existing row in the table.</p> <p>There are  different conflict strategies:</p> <ul> <li><code>OnConflictStrategy.REPLACE</code>: Replaces the existing row with the new data.</li> <li><code>OnConflictStrategy.IGNORE</code>: Ignores the new data if a conflict occurs.</li> <li><code>OnConflictStrategy.ABORT</code>: Aborts the transaction if a conflict occurs (default behavior).</li> <li><code>OnConflictStrategy.FAIL</code>: Fails the transaction if a conflict occurs.</li> <li><code>OnConflictStrategy.ROLLBACK</code>: Rolls back the transaction if a conflict occurs.</li> </ul> <p>If the <code>@Insert</code> method receives a single parameter, it can return a long value, which is the new rowId for the inserted item.</p> <p>The <code>@Update</code> and <code>@Delete</code> methods can optionally return an integer value representing the number of rows affected by the operation.</p> <p>In the <code>@Query</code> method, you can pass parameters using the <code>:</code> syntax:</p> <pre><code>@Query(\"SELECT * FROM users WHERE id = :userId\")\nsuspend fun getUserById(userId: Int): User?\n\n@Query(\"SELECT * FROM user WHERE age BETWEEN :minAge AND :maxAge\")\nfun loadAllUsersBetweenAges(minAge: Int, maxAge: Int): Array&lt;User&gt;\n\n@Query(\"SELECT * FROM user WHERE first_name LIKE :search \" + \"OR last_name LIKE :search\")\nfun findUserWithName(search: String): List&lt;User&gt;\n</code></pre> <p>When do not use suspend functions in DAO methods</p> <p>You should not use <code>suspend</code> functions in DAO methods that return <code>LiveData</code> or <code>Flow</code>. These return types are designed to be observed and will automatically handle threading for you. Using <code>suspend</code> with these return types can lead to unexpected behavior and is not necessary.</p> <p>Flow vs. LiveData in Room DAOs</p> <p>Both <code>Flow</code> and <code>LiveData</code> are observable data holders that can be used to observe changes in the database. However, there are some differences between them:</p> <ul> <li> <p>Flow is a Kotlin coroutine-based API that provides a more flexible and powerful way to handle asynchronous data streams. It supports operators for transforming and combining data streams, making it suitable for complex data processing scenarios.</p> </li> <li> <p>LiveData is a lifecycle-aware component that is part of the Android Architecture Components. It is designed to work seamlessly with the Android lifecycle, automatically managing subscriptions based on the lifecycle state of the observing components (e.g., Activities or Fragments).</p> </li> </ul> <p>In general, if you are using Kotlin coroutines and need more advanced data processing capabilities, <code>Flow</code> is a better choice. If you are working within the Android lifecycle and want a simpler way to observe data changes, <code>LiveData</code> may be more appropriate.</p> <p>More about DAOs</p>"},{"location":"U04%20Persistence%20with%20Room/U04.1%20Persistence%20with%20Room/#database","title":"Database","text":"<p>The database class is an abstract class that extends <code>RoomDatabase</code>. It is annotated with <code>@Database</code> and defines the entities and DAOs for the database.</p> <p>A singleton pattern is typically used to ensure that only one instance of the database is created throughout the app's lifecycle.</p> <p>An implementation example is shown below:</p> <pre><code>import androidx.room.Database\nimport androidx.room.Room\nimport androidx.room.RoomDatabase\nimport android.content.Context\n\n@Database(entities = [User::class, Order::class], version = 1)\nabstract class AppDatabase : RoomDatabase() {\nabstract fun userDao(): UserDao\nabstract fun orderDao(): OrderDao\n\ncompanion object {\n@Volatile\nprivate var INSTANCE: AppDatabase? = null\n\nfun getDatabase(context: Context): AppDatabase {\nreturn INSTANCE ?: synchronized(this) {\nval instance = Room.databaseBuilder(\ncontext.applicationContext,\nAppDatabase::class.java,\n\"app_database\"\n).build()\nINSTANCE = instance\ninstance\n}\n}\n}\n}\n</code></pre> <p>The version number on the Database annotation should be incremented whenever the database schema is changed. For example, if a new entity is added or an existing entity is modified, the version number should be increased to ensure that the database is properly migrated to the new schema.</p> <p>The <code>synchronized</code> block ensures that only one thread can access the database instance creation code at a time, preventing multiple instances from being created in a multi-threaded environment.</p>"},{"location":"U04%20Persistence%20with%20Room/U04.1%20Persistence%20with%20Room/#repository","title":"Repository","text":"<p>The Repository acts as a mediator between the data sources (Room database, network, etc.) and the rest of the application. It provides a clean API for data access and abstracts the underlying data sources.</p> <p>Although not strictly part of Room, the Repository pattern is commonly used in conjunction with Room.</p> <p></p> <p>It is usual to create a Repository class for each Entity/DAO pair. An example of a UserRepository is shown below:</p> <pre><code>class UserRepository(private val userDao: UserDao) {\nval allUsers: Flow&lt;List&lt;User&gt;&gt; = userDao.getAllUsers()\n\nsuspend fun insert(user: User): Long {\nreturn userDao.insertUser(user)\n}\n\nsuspend fun getUserById(userId: Int): User? {\nreturn userDao.getUserById(userId)\n}\n\nsuspend fun update(user: User) {\nuserDao.updateUser(user)\n}\n\nsuspend fun delete(user: User) {\nuserDao.deleteUser(user)\n}\n}\n</code></pre>"},{"location":"U04%20Persistence%20with%20Room/U04.1%20Persistence%20with%20Room/#using-the-data-in-the-ui-layer","title":"Using the data in the UI layer","text":"<p>In the UI layer, you can use ViewModels to interact with the Repository and observe data changes.</p> <pre><code>import androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport kotlinx.coroutines.flow.collect\nimport kotlinx.coroutines.launch\n\nclass UserViewModel(private val userRepository: UserRepository) : ViewModel() {\n\nval allUsers = userRepository.allUsers\n\nfun insertUser(user: User) {\nviewModelScope.launch {\nuserRepository.insert(user)\n}\n}\n\nfun getUserById(userId: Int) {\nviewModelScope.launch {\nuserRepository.getUserById(userId)?.let { user -&gt;\n// Update UI with user data\n}\n}\n}\n\nfun updateUser(user: User) {\nviewModelScope.launch {\nuserRepository.update(user)\n}\n}\n\nfun deleteUser(user: User) {\nviewModelScope.launch {\nuserRepository.delete(user)\n}\n}\n}\n</code></pre>"},{"location":"U04%20Persistence%20with%20Room/U04.2%20Room%20guided%20practice/","title":"Unit 4.2. Room guided practice","text":"<p>In this guided practice, you will enhance the Tip Time app by adding data persistence using Room. You will create a database to store tip calculations and retrieve them later.</p> <p></p>"},{"location":"U04%20Persistence%20with%20Room/U04.2%20Room%20guided%20practice/#the-data-layer","title":"The data layer","text":"<p>The data layer will consist of the following components:</p> <ol> <li>Entity: Represents a table within the database. Each entity is a data class annotated with <code>@Entity</code>.</li> <li>DAO (Data Access Object): Provides methods for accessing the database. DAOs are interfaces annotated with <code>@Dao</code>.</li> <li>Database: The main database class that holds the database and serves as the main access point for the underlying SQLite database. It is annotated with <code>@Database</code>.</li> <li>Repository: A class that abstracts access to multiple data sources. It mediates between the data layer and the rest of the app.</li> </ol> <p>We will create a new package named <code>data</code> to hold these components.</p>"},{"location":"U04%20Persistence%20with%20Room/U04.2%20Room%20guided%20practice/#1-add-room-dependencies","title":"1. Add Room dependencies","text":"<p>First, declare the KSP plugin in your top level <code>build.gradle.kts</code> file:</p> <pre><code>plugins {\n//Previously declared plugins\nid(\"com.google.devtools.ksp\") version \"2.0.21-1.0.27\" apply false\n}\n</code></pre> <p>Then, enable KSP in your app-level <code>build.gradle.kts</code> file:</p> <pre><code>//Previously declared plugins\nplugins {\nid(\"com.google.devtools.ksp\")\n}\n</code></pre> <p>Finally, add the following Room dependencies to your <code>build.gradle</code> file:</p> <pre><code>dependencies {\nval room_version = \"2.8.3\"\n\n// Previous dependencies\n\n//Room\nimplementation(\"androidx.room:room-runtime:$room_version\")\nksp(\"androidx.room:room-compiler:$room_version\")\nimplementation(\"androidx.room:room-ktx:$room_version\")\n}\n</code></pre> <p>Sync your project to download the dependencies.</p>"},{"location":"U04%20Persistence%20with%20Room/U04.2%20Room%20guided%20practice/#2-create-the-entity","title":"2. Create the Entity","text":"<p>In the <code>data</code> package, create a new Kotlin data class named <code>Tip</code> to represent the tip calculation entity. Annotate the class with <code>@Entity</code> and define the necessary fields:</p> <pre><code>//Tip.kt\n\nimport androidx.room.Entity\nimport androidx.room.PrimaryKey\n\n@Entity(tableName = \"tips\")\ndata class Tip(\n@PrimaryKey(autoGenerate = true)\nval id: Int = 0,\nval billAmount: Double,\nval tipPercentage: Int,\nval roundUp: Boolean,\n)\n</code></pre> <p>As you can see, we use annotations to define the table name. That means that Room will create and use a table named <code>tips</code> in the database.</p> <p>The <code>id</code> field is annotated with <code>@PrimaryKey</code> and set to auto-generate, so Room will automatically assign a unique ID to each tip calculation.</p>"},{"location":"U04%20Persistence%20with%20Room/U04.2%20Room%20guided%20practice/#3-create-the-dao","title":"3. Create the DAO","text":"<p>In the <code>data</code> package, create a new Kotlin interface named <code>TipDao</code>. Annotate the interface with <code>@Dao</code> and define methods for inserting and retrieving tip calculations:</p> <pre><code>//TipDao.kt\n\nimport androidx.room.Dao\nimport androidx.room.Insert\nimport androidx.room.Query\nimport kotlinx.coroutines.flow.Flow\n\n@Dao\ninterface TipDao {\n@Query(\"SELECT * FROM tips ORDER BY id ASC\")\nfun getAllTips(): Flow&lt;List&lt;Tip&gt;&gt;\n\n@Query(\"SELECT * FROM tips WHERE id = :id\")\nfun getTipById(id: Int): Flow&lt;Tip?&gt;\n\n@Insert(onConflict = OnConflictStrategy.IGNORE)\nsuspend fun insertTip(tip: Tip)\n\n@Update\nsuspend fun updateTip(tip: Tip)\n\n@Delete\nsuspend fun deleteTip(tip: Tip)\n}\n</code></pre> <p>Similar to the entity, we use annotations to define SQL queries for retrieving data from the database.</p> <p>The select methods return a <code>Flow</code> of data, allowing us to observe changes in the database. They have the annotation <code>@Query</code> with the corresponding SQL query as a parameter.</p> <p>The onConflict strategy for the insert method is set to <code>IGNORE</code>, meaning that if a conflict occurs (e.g., trying to insert a tip with an existing ID), the insertion will be ignored.</p> <p>The insert, update, and delete methods are suspended functions, allowing them to be called from a coroutine.</p> <p>Info</p> <p>A suspended method is a special kind of function in Kotlin that can be paused and resumed at a later time. This is particularly useful for performing long-running operations, such as database operations or network requests, without blocking the main thread of the application.</p>"},{"location":"U04%20Persistence%20with%20Room/U04.2%20Room%20guided%20practice/#4-create-the-database","title":"4. Create the Database","text":"<p>In the <code>data</code> package, create a new Kotlin abstract class named <code>TipDatabase</code>. Annotate the class with <code>@Database</code> and define the database configuration:</p> <pre><code>//TipDatabase.kt\n\n@Database(entities = [Tip::class], version = 1, exportSchema = false)\nabstract class TipDatabase : RoomDatabase() {\n\nabstract fun tipDao(): TipDao\n\ncompanion object {\n@Volatile\nprivate var Instance: TipDatabase? = null\n\nfun getDatabase(context: Context): TipDatabase {\n// if the Instance is not null, return it, otherwise create a new database instance.\nreturn Instance ?: synchronized(this) {\nRoom.databaseBuilder(context, TipDatabase::class.java, \"tip_database\")                    .fallbackToDestructiveMigration(false)\n.build()\n.also { Instance = it }\n}\n}\n}\n}\n</code></pre> <p>The database class must satisfy the following conditions:</p> <ul> <li>The class must be annotated with a <code>@Database</code> annotation that includes an <code>entities</code> array that lists all of the data entities associated with the database.</li> <li>The class must be an abstract class that extends <code>RoomDatabase</code>.</li> <li>For each DAO class that is associated with the database, the database class must define an abstract method that has zero arguments and returns an instance of the DAO class.</li> </ul> <p>The version number is set to 1. If you make changes to the database schema in the future, you will need to increment this version number, so that Room can handle the migration.</p> <p>The method <code>getDatabase</code> implements the singleton pattern to ensure that only one instance of the database is created throughout the app's lifecycle. The <code>synchronized</code> block ensures that the database instance is created in a thread-safe manner.</p> <p>The <code>Room.databaseBuilder</code> method is used to create the database instance, specifying the context, the database class, and the database name. The parameter <code>fallbackToDestructiveMigration(false)</code> indicates that Room should not delete the database if a migration is needed but not found.</p>"},{"location":"U04%20Persistence%20with%20Room/U04.2%20Room%20guided%20practice/#5-create-the-repository","title":"5. Create the Repository","text":"<p>A repository class abstracts access to multiple data sources. It mediates between the data layer and the rest of the app. It's not mandatory, but it's a good practice to use it.</p> <p>In the <code>data</code> package, create a new Kotlin class named <code>TipRepository</code>. Define the repository class as follows:</p> <pre><code>//TipRepository.kt\n\nimport kotlinx.coroutines.flow.Flow\n\nclass TipRepository(private val tipDao: TipDao) {\n\nfun getAllTips(): Flow&lt;List&lt;Tip&gt;&gt; = tipDao.getAllTips()\n\nfun getTipById(id: Int): Flow&lt;Tip?&gt; = tipDao.getTipById(id)\n\nsuspend fun insertTip(tip: Tip) = tipDao.insertTip(tip)\n\nsuspend fun updateTip(tip: Tip) = tipDao.updateTip(tip)\n\nsuspend fun deleteTip(tip: Tip) = tipDao.deleteTip(tip)\n}\n</code></pre> <p>The data layer is done, you can run the app now to check that everything is working fine. No database operations are performed yet, so the app should work as before.</p>"},{"location":"U04%20Persistence%20with%20Room/U04.2%20Room%20guided%20practice/#6-add-the-save-functionality-to-the-viewmodel","title":"6. Add the save functionality to the ViewModel","text":"<p>Now that we have the data layer set up, we need to integrate it into the ViewModel to allow saving tip calculations.</p> <p>In the <code>TipViewModel</code>, change the constructor to accept an Application context and inherit from <code>AndroidViewModel</code> instead of <code>ViewModel</code>. This will allow us to access the database instance.</p> <p>Then, create an instance of the <code>TipRepository</code> using the <code>TipDatabase</code> and implement a method to save the tip calculation.</p> <pre><code>//TipTimeViewModel.kt\nimport android.app.Application\nimport androidx.lifecycle.AndroidViewModel\nimport androidx.lifecycle.viewModelScope\nimport kotlinx.coroutines.launch\n\nclass TipTimeViewModel(application: Application) : AndroidViewModel(application) {   // Existing properties and methods\n\nprivate val tipRepository: TipRepository = TipRepository(\nTipDatabase.getDatabase(application).tipDao()\n)\n\nfun saveTipCalculation() {\n// Launch a coroutine in the ViewModel's scope\nviewModelScope.launch {\nval tip = Tip(\nbillAmount = _uiState.value.amountInput.toDoubleOrNull() ?: 0.0,\ntipPercentage = _uiState.value.tipInput.toIntOrNull() ?: 15,\nroundUp = _uiState.value.roundUp\n)\n// Use the repository to insert the tip\ntipRepository.insertTip(tip)\n}\n}\n}\n</code></pre>"},{"location":"U04%20Persistence%20with%20Room/U04.2%20Room%20guided%20practice/#7-save-from-the-ui","title":"7. Save from the UI","text":"<p>Finally, we need to call the <code>saveTipCalculation</code> method from the UI when the user wants to save a tip calculation. You can add a button in the UI that triggers this action.</p> <p>For example, in your Composable function, change the <code>onNextButtonClicked</code> lambda to call the save method:</p> <pre><code>//TipTimeLayout.kt\n\ncomposable( route = Routes.Start.name) {\nTipTimeStartScreen(\ntipTimeViewModel = tipTimeViewModel,\nonNextButtonClicked = {\ntipTimeViewModel.saveTipCalculation()\nnavController.navigate(Routes.TipResult.name)\n},\nmodifier = Modifier\n.fillMaxSize()\n.padding(40.dp)\n)\n}\n</code></pre> <pre><code>sequenceDiagram\n    actor User\n\n    User-&gt;&gt;+EditScreen: Clicks \"Save\"/\"Update\" Button\n    EditScreen-&gt;&gt;+ViewModel: Calls saveTipCalculation()\n\n    ViewModel-&gt;&gt;+Repository: Calls insertTip(tip) or updateTip(tip)\n    Repository-&gt;&gt;+DAO: Calls insert(tip) or update(tip)\n    DAO-&gt;&gt;+Database: Executes SQL INSERT or UPDATE statement\n    Database--&gt;&gt;-DAO: Confirms operation success\n    DAO--&gt;&gt;-Repository: Returns confirmation\n    Repository--&gt;&gt;-ViewModel: Returns confirmation\n    ViewModel--&gt;&gt;-EditScreen: (Completes coroutine scope)\n</code></pre>"},{"location":"U04%20Persistence%20with%20Room/U04.2%20Room%20guided%20practice/#8-add-a-list-screen","title":"8. Add a list screen","text":"<p>Now that we have the ability to save tip calculations, let's add a new screen to display the list of saved tips.</p> <p>Change the name of your <code>TipTimeStartScreen</code> to <code>TipTimeEditScreen</code>. Create a new screen with the name <code>TipTimeStartScreen</code>, that will contain a lazy column to show the list of saved tips.</p> <p>Adjust your navigation to include the new screen:</p> <pre><code>//Routes.kt\n\nenum class Routes(@StringRes val title: Int) {\nStart (title = R.string.app_name),\nEditTip (title = R.string.edit_tip),\nTipResult (title = R.string.tip_result)\n}\n</code></pre> <p>The <code>TipTimeStartScreen</code> will contain the next composables:</p> <ul> <li><code>TipTimeStartScreen</code>: the main composable that contains the lazy column.</li> <li><code>TipList</code>: the lazy column that displays the list of saved tips.</li> <li><code>TipItem</code>: the individual item in the list that displays the tip details inside a card component.</li> </ul> <p>Lets see each composable implementation:</p> <pre><code>//TipTimeStartScreen.kt\n\n@OptIn(ExperimentalMaterial3Api::class)\n@Composable\nfun TipTimeStartScreen(\nonItemClick: (Int) -&gt; Unit,\nmodifier: Modifier = Modifier,\nstartViewModel: StartViewModel = viewModel(),\ncontentPadding: PaddingValues = PaddingValues(0.dp)\n) {\nval uiState by startViewModel.uiState.collectAsState()\nval tipList = uiState.itemList\n\nColumn(\nhorizontalAlignment = Alignment.CenterHorizontally,\nmodifier = modifier,\n) {\nif (tipList.isEmpty()) {\nText(\ntext = stringResource(R.string.no_tips_description),\ntextAlign = TextAlign.Center,\nstyle = MaterialTheme.typography.titleLarge,\nmodifier = Modifier.padding(contentPadding),\n)\n} else {\nTipList(\ntipList = tipList,\nonItemClick = { onItemClick(it.id) },\ncontentPadding = contentPadding,\nmodifier = Modifier.padding(horizontal = 6.dp)\n)\n}\n}\n}\n</code></pre> <p>In this composable, we observe the <code>uiState</code> from the <code>StartViewModel</code> (that we will create later) to get the list of saved tips. If the list is empty, we display a message; otherwise, we show the <code>TipList</code> composable.</p> <pre><code>//TipTimeStartScreen.kt\n\n@Composable\nfun TipList(\ntipList: List&lt;Tip&gt;,\nonItemClick: (Tip) -&gt; Unit,\nmodifier: Modifier = Modifier,\ncontentPadding: PaddingValues,\n) {\nLazyColumn(\nmodifier = modifier,\ncontentPadding = contentPadding\n) {\nitems(items = tipList, key = { it.id }) { tip -&gt;\nTipItem(tip = tip,\nmodifier = Modifier\n.padding(6.dp)\n.clickable { onItemClick(tip) })\n}\n}\n}\n</code></pre> <p>Here we are using a <code>LazyColumn</code> to display the list of tips. Each item in the list is represented by the <code>TipItem</code> composable. When we click on an item, we call the <code>onItemClick</code> lambda with the selected tip.</p> <p>LazyColumn</p> <p>A <code>LazyColumn</code> is a vertically scrolling list that only composes and lays out the currently visible items. This makes it more efficient than a regular <code>Column</code> for displaying large lists of data, as it only creates the views that are currently needed.</p> <pre><code>//TipTimeStartScreen.kt\n\n@Composable\nfun TipItem(\ntip: Tip,\nmodifier: Modifier = Modifier\n) {\nCard(\nmodifier = modifier,\nelevation = CardDefaults.cardElevation(defaultElevation = 2.dp)\n) {\nColumn(\nmodifier = Modifier.padding(20.dp),\nverticalArrangement = Arrangement.spacedBy(8.dp),\n) {\nText(\ntext = stringResource(R.string.bill_amount)  + \": \" + tip.billAmount,\nstyle = MaterialTheme.typography.bodyLarge\n)\nSpacer(Modifier.weight(1f))\nText(\ntext = stringResource(R.string.tip_amount, tip.tipPercentage),\nstyle = MaterialTheme.typography.bodyMedium,\ntextAlign = TextAlign.End,\nmodifier = Modifier.fillMaxWidth()\n)\n}\n}\n}\n</code></pre> <p>Here we define how each tip item looks. We use a <code>Card</code> component to display the tip details, including the bill amount and tip percentage, that we get from the <code>Tip</code> entity.</p> <p>The <code>TipTimeStartScreen</code> will need a corresponding ViewModel to fetch the list of saved tips from the database. Create a new ViewModel named <code>StartViewModel</code> on the <code>ui.viewmodels</code> package:</p> <pre><code>package com.example.tiptime.viewmodels\n\nimport android.app.Application\nimport androidx.lifecycle.AndroidViewModel\nimport androidx.lifecycle.viewModelScope\nimport com.example.tiptime.data.Tip\nimport com.example.tiptime.data.TipDatabase\nimport com.example.tiptime.data.TipRepository\nimport kotlinx.coroutines.flow.SharingStarted\nimport kotlinx.coroutines.flow.StateFlow\nimport kotlinx.coroutines.flow.map\nimport kotlinx.coroutines.flow.stateIn\n\n/**\n * ViewModel for the Start screen.\n */\nclass StartViewModel(application: Application) : AndroidViewModel(application) {\n\nprivate val tipRepository: TipRepository = TipRepository(\nTipDatabase.getDatabase(application).tipDao()\n)\n\nval uiState: StateFlow&lt;StartUiState&gt; = tipRepository.getAllTips()\n.map { StartUiState(it) }\n.stateIn(\nscope = viewModelScope,\nstarted = SharingStarted.WhileSubscribed(5000),\ninitialValue = StartUiState()\n)\n\ncompanion object {\n// Timeout for keeping the flow active while there are no subscribers.\nprivate const val TIMEOUT_MILLIS = 5_000L\n}\n}\n\n/**\n * The UI state for the Start screen.\n */\ndata class StartUiState(\nval itemList :List&lt;Tip&gt; = listOf()\n)\n</code></pre> <p>In the view model, we create an instance of the <code>TipRepository</code> to access the data layer. We define a <code>uiState</code> property that is a <code>StateFlow</code> of <code>StartUiState</code>, which contains the list of saved tips. The mapping function transforms the flow of tips from the repository into the UI state. The <code>stateIn</code> function is used to convert the flow into a state flow that can be observed by the UI.</p> <p>The companion object contains a constant for the timeout duration when there are no subscribers to the flow.</p> <p>In the same file we define the <code>StartUiState</code> data class, which holds the list of tips to be displayed in the UI.</p> <p>Now, it's time to modify the navigation to include the new screen. In your <code>TipTimeLayout.kt</code> file, update the navigation graph to include the changes:</p> <pre><code>//TipTimeLayout.kt\n\nfun TipTimeLayout(\ntipTimeViewModel: TipTimeViewModel = viewModel(),\nstartViewModel: StartViewModel = viewModel(), // ADD THIS LINE\nnavController: NavHostController = rememberNavController()\n) {\n...\n\n\nNavHost(\nnavController = navController,\nstartDestination = Routes.Start.name,\nmodifier = Modifier.padding(innerPadding)\n) {\ncomposable( route = Routes.Start.name) {\nTipTimeStartScreen(\nstartViewModel = startViewModel,\nonItemClick = { navController.navigate(Routes.EditTip.name)},\nmodifier = Modifier\n.fillMaxSize()\n.padding(40.dp)\n)\n}\ncomposable( route = Routes.EditTip.name) {\nTipTimeEditScreen(\ntipTimeViewModel = tipTimeViewModel,\nonNextButtonClicked = {\ntipTimeViewModel.saveTipCalculation()\nnavController.navigate(Routes.TipResult.name)\n},\nmodifier = Modifier\n.fillMaxSize()\n.padding(40.dp)\n)\n}\n// Rest of the navigation graph\n}\n</code></pre> <p>Note how in the <code>onNextButtonClicked</code> lambda of the <code>TipTimeEditScreen</code>, we call the <code>saveTipCalculation</code> method before navigating to the <code>TipResult</code> screen.</p> <p>This should be enough. Check that everything is working fine by running the app. You should be able to save tip calculations and see them listed in the start screen.</p> <p>However, when you open a tip element, it does not show the details of the tip. We will solve it in the next point.</p>"},{"location":"U04%20Persistence%20with%20Room/U04.2%20Room%20guided%20practice/#9-edit-tips","title":"9. Edit tips","text":"<p>For editing tips, we need to modify the <code>TipTimeEditScreen</code> to accept a tip ID and load the corresponding tip details from the database.</p> <p>From the <code>TipTimeLayout.kt</code> we need to pass the tip ID when navigating to the <code>TipTimeEditScreen</code>. Then, we will load the tip details in the ViewModel based on the passed ID, with the repository method <code>getTipById</code>.</p> <p>First, modify the Routes enum to include a parameter for the tip ID and a string resource for the route:</p> <pre><code>//Routes.kt\n\nenum class Routes(@StringRes val title: Int, val route: String) {\nStart(title = R.string.app_name, route = \"Start\"),\nEditTip(title = R.string.edit_tip, route = \"EditTip\"),\nTipResult(title = R.string.tip_result, route = \"TipResult\");\n\ncompanion object {\nconst val TIP_ID_ARG = \"tipId\"\n}\n\n/**\n     * The route pattern that accepts a tip id argument, e.g. \"EditTip/{tipId}\"\n     */\nfun withArg(): String = \"$route/{$TIP_ID_ARG}\"\n\n/**\n     * Build a concrete route for the given id, e.g. \"EditTip/3\"\n     */\nfun createRouteFor(id: Int): String = \"$route/$id\"\n}\n</code></pre> <p>This code still maintains the string resource for the title, but now also includes a <code>route</code> property for each enum value. The <code>withArg</code> method constructs a route pattern that includes a placeholder for the tip ID, while the <code>createRouteFor</code> method generates a concrete route by substituting the placeholder with an actual tip ID.</p> <p>In the <code>TipTimeLayout</code> composable, modify the <code>currentScreen</code> variable to use the new route property:</p> <pre><code>//TipTimeLayout.kt\n\n// Resolve a route string for the current entry (may include concrete id like \"EditTip/3\")\nval currentRoute = backStackEntry?.destination?.route ?: Routes.Start.route\n\n// Map the route string to our Routes enum, handling both plain and \"withArg\" patterns\nval currentScreen = Routes.values().firstOrNull { r -&gt;\ncurrentRoute == r.route ||\ncurrentRoute.startsWith(r.route + \"/\") ||\ncurrentRoute == r.withArg()\n} ?: Routes.Start\n</code></pre> <p>This code modifies the way the current screen is determined by checking if the current route matches either the base route or starts with the base route followed by a slash (indicating a concrete ID).</p> <p>In the composable for the Start screen, modify the navigation to pass the tip ID when navigating to the EditTip screen:</p> <pre><code>//TipTimeLayout.kt\n\ncomposable(route = Routes.Start.route) {\nTipTimeStartScreen(\nstartViewModel = startViewModel,\n// Navigate to EditTip with the selected tip id using the helper\nonItemClick = { id -&gt; navController.navigate(Routes.EditTip.createRouteFor(id)) },\nmodifier = Modifier\n.fillMaxSize()\n.padding(40.dp)\n)\n}\n</code></pre> <p>Here, we use the <code>createRouteFor</code> method to generate the navigation route with the selected tip ID.</p> <p>In the composable for the <code>EditTip</code> screen, modify the route to accept the tip ID argument and retrieve it from the back stack entry. We also modify the onClick lambda to save/update the tip in the database:</p> <pre><code>//TipTimeLayout.kt\n\n// EditTip route now accepts a path parameter using the enum helper\ncomposable(\nroute = Routes.EditTip.withArg(),\narguments = listOf(navArgument(Routes.TIP_ID_ARG) { type = NavType.IntType })\n) { backStackEntry -&gt;\nval tipId = backStackEntry.arguments?.getInt(Routes.TIP_ID_ARG) ?: 0\nTipTimeEditScreen(\ntipTimeViewModel = tipTimeViewModel,\nonNextButtonClicked = {\ntipTimeViewModel.saveTipCalculation()\nnavController.navigate(Routes.TipResult.route)\n},\ntipId = tipId,\nmodifier = Modifier\n.fillMaxSize()\n.padding(40.dp)\n)\n}\n</code></pre> <p>Here, we define the route to accept an integer argument for the tip ID. We retrieve the tip ID from the back stack entry's arguments and pass it to the <code>TipTimeEditScreen</code> composable.</p> <p>In the <code>TipTimeEditScreen</code>, add a new argument for the tip ID and load the tip details in the ViewModel:</p> <pre><code>fun TipTimeEditScreen(\nonNextButtonClicked: () -&gt; Unit,\nmodifier: Modifier = Modifier,\ntipTimeViewModel: TipTimeViewModel = viewModel(),\ntipId: Int? = 0\n) {\n// Use LaunchedEffect to load the tip when the screen is first displayed\nLaunchedEffect(tipId) {\nif (tipId != null &amp;&amp; tipId != 0) { // Assuming 0 is not a valid ID\ntipTimeViewModel.loadTipById(tipId)\n} else {\ntipTimeViewModel.resetTip() // Optional: Clear fields for a new tip\n}\n}\n// Rest of the composable code\n</code></pre> <p>Here, we use <code>LaunchedEffect</code> to load the tip details when the screen is first displayed. If a valid tip ID is provided, we call the <code>loadTipById</code> method in the ViewModel to fetch the tip details. If the tip ID is 0 or null, we reset the fields for a new tip.</p> <p>LaunchedEffect</p> <p><code>LaunchedEffect</code> is a composable function in Jetpack Compose that allows you to run suspend functions or side effects in response to changes in the composition. It is typically used to perform actions that should occur when a specific key or set of keys change. LaunchedEffect</p> <p>Another modification is done in the Next button click lambda to call the <code>saveTipCalculation</code> method:</p> <pre><code>//TipTimeEditScreen.kt\n\n//Previous composables\nButton(\nonClick = onNextButtonClicked,\n) {\n// Change button text based on whether it's a new tip or an edit\nval buttonText = if (tipId != null &amp;&amp; tipId != 0) {\nstringResource(R.string.update)\n} else {\nstringResource(R.string.save)\n}\nText(buttonText)\n}\n</code></pre> <p>Finally, in the <code>TipTimeViewModel</code>, we need new methods to load a tip by its ID and reset or update the tip fields.</p> <p>First, add a new property to hold the currently loaded tip:</p> <pre><code>private var currentTipId: Int? = null\n</code></pre> <p>The <code>loadTipById</code> method fetches the tip from the repository and updates the UI state:</p> <pre><code>fun loadTipById(tipId: Int) {\ncurrentTipId = tipId\nviewModelScope.launch {\n// Fetch the tip from the repository\nval tip = tipRepository.getTipById(tipId).firstOrNull()\ntip?.let {\n// Update the UI state with the fetched tip data\n_uiState.update { currentState -&gt;\ncurrentState.copy(\nid = it.id,\namountInput = it.billAmount.toString(),\ntipInput = it.tipPercentage.toString(),\nroundUp = it.roundUp\n)\n}\n// Recalculate tip and total for the loaded values\ncalculateTip()\n}\n}\n}\n</code></pre> <p>let and scope functions</p> <p>The <code>let</code> function in Kotlin is a scope function that allows you to execute a block of code on an object and return the result of the block. It is often used for null-checking and chaining operations on an object. let function Scope functions</p> <p>The <code>saveTipCalculation</code> method is modified to handle both insert and update operations based on whether a tip is being edited or created, depending on the value of <code>currentTipId</code>:</p> <pre><code>fun saveTipCalculation() {\n// Launch a coroutine in the ViewModel's scope\nviewModelScope.launch {\nval tip = Tip(\nid = currentTipId ?: 0, // Use currentTipId if it exists, otherwise 0 for a new entry\nbillAmount = _uiState.value.amountInput.toDoubleOrNull() ?: 0.0,\ntipPercentage = _uiState.value.tipInput.toIntOrNull() ?: 15,\nroundUp = _uiState.value.roundUp\n)\n// Use the repository to insert the tip\nif (currentTipId == null || currentTipId == 0) {\ntipRepository.insertTip(tip)\n} else {\ntipRepository.updateTip(tip)\n}\n}\n}\n</code></pre> <p>Finally, the <code>resetTip</code> method clears the current tip ID and resets the UI state. It is called when creating a new tip and the tip id is 0 or null:</p> <pre><code>fun resetTip() {\ncurrentTipId = null\n_uiState.value = TipTimeState() // Reset to default state\n}\n</code></pre> <p>Check that everything is working fine by running the app. You should be able to update tips loaded from the list.</p>"},{"location":"U04%20Persistence%20with%20Room/U04.2%20Room%20guided%20practice/#10-adding-tips","title":"10. Adding tips","text":"<p>To add a new tip, we need a FAB button on the <code>TipTimeLayout</code> that navigates to the <code>EditTip</code> screen without passing an id with the value of 0:</p> <pre><code>//TipTimeLayout.kt\n\nScaffold(\ntopBar = {\n//TopBar content\n},\nfloatingActionButton = {\n// Add a FAB only on the Start screen\nif (currentScreen == Routes.Start) {\nandroidx.compose.material3.FloatingActionButton(\nonClick = { navController.navigate(Routes.EditTip.createRouteFor(0)) }\n) {\nIcon(\nimageVector = Icons.Default.Add,\ncontentDescription = stringResource(R.string.add_tip)\n)\n}\n}\n}\n</code></pre>"},{"location":"U04%20Persistence%20with%20Room/U04.2%20Room%20guided%20practice/#11-deleting-tips","title":"11. Deleting tips","text":"<p>For delete an existing tip, we need a button in the <code>TipTimeEditScreen</code> that calls a new method in the ViewModel to delete the current tip. This button should only be visible when editing an existing tip (i.e., when <code>tipId</code> is not null or 0).</p> <pre><code>//TipTimeEditScreen.kt\n\n// Add a delete button if editing an existing tip\nif (tipId != null &amp;&amp; tipId != 0) {\nSpacer(modifier = Modifier.height(16.dp))\nOutlinedButton(\nonClick = {\ntipTimeViewModel.deleteTip()\nbackNavitation()\n},\nmodifier = Modifier,\n) {\nText(stringResource(R.string.delete))\n}\n}\n</code></pre> <p>We are calling a the backNavigation lambda to return to the previous screen after deleting the tip, but we need to passit as argument from the TipTimeLayout:</p> <pre><code>//TipTimeLayout.kt\n\ncomposable(\nroute = Routes.EditTip.withArg(),\narguments = listOf(navArgument(Routes.TIP_ID_ARG) { type = NavType.IntType })\n) { backStackEntry -&gt;\nval tipId = backStackEntry.arguments?.getInt(Routes.TIP_ID_ARG) ?: 0\nTipTimeEditScreen(\ntipTimeViewModel = tipTimeViewModel,\nonNextButtonClicked = {\ntipTimeViewModel.saveTipCalculation()\nnavController.navigate(Routes.TipResult.route)\n},\nbackNavigation = { navController.navigateUp() }, //ADD THIS LINE\ntipId = tipId,\nmodifier = Modifier\n.fillMaxSize()\n.padding(40.dp)\n)\n}\n</code></pre> <p>And in the TipTimeEditScreen composable, add the new argument:</p> <pre><code>//TipTimeEditScreen.kt\n\nfun TipTimeEditScreen(\nonNextButtonClicked: () -&gt; Unit,\nbackNavigation: () -&gt; Unit, // ADD THIS LINE\n...\n</code></pre> <p>Finally, implement the <code>deleteTip</code> method in the <code>TipTimeViewModel</code>:</p> <pre><code>//TipTimeViewModel.kt\n\nfun deleteTip() {\nval tipId = currentTipId ?: return // If no current tip, do nothing\nval tip = Tip(\nid = tipId,\nbillAmount = _uiState.value.amountInput.toDoubleOrNull() ?: 0.0,\ntipPercentage = _uiState.value.tipInput.toIntOrNull() ?: 15,\nroundUp = _uiState.value.roundUp\n)\nviewModelScope.launch {\ntipRepository.deleteTip(tip)\n}\n}\n</code></pre> <p>Done! Check that everything is working fine by running the app. You should be able to delete existing tips.</p>"},{"location":"U04%20Persistence%20with%20Room/U04.2%20Room%20guided%20practice/#12-fixing-state-issues","title":"12. Fixing state issues","text":"<p>You can notice some sate issues when rotating the Edit Screen. To fix it, we need to save the current tip ID in the next files:</p> <pre><code>//TipTimeEditScreen.kt\n\n@Composable\nfun TipTimeEditScreen(\n// Existing parameters\n) {\n// Use LaunchedEffect to load the tip when the screen is first displayed\nLaunchedEffect(tipId) {\nif (tipId != null &amp;&amp; tipId != 0) { // Assuming 0 is not a valid ID\ntipTimeViewModel.loadOrKeepTip(tipId)  //CHANGE THIS\n} else {\n//tipTimeViewModel.resetTip() // DELETE THIS\n}\n}\n...\n</code></pre> <pre><code>//TipTimeLayout.kt\n\n...\n\nfloatingActionButton = {\nif (currentScreen == Routes.Start) {\nandroidx.compose.material3.FloatingActionButton(\nonClick = { tipTimeViewModel.resetTip() //ADD THIS\nnavController.navigate(Routes.EditTip.createRouteFor(0))\n}\n)\n\n...\n\ncomposable(route = Routes.TipResult.route) {\nTipTimeResultScreen(\ntipTimeViewModel = tipTimeViewModel,\nonBackButtonClicked = {\nnavController.navigate(Routes.Start.route) {popUpTo(0)}\ntipTimeViewModel.resetTip() //ADD THIS\n},\nmodifier = Modifier\n.fillMaxSize()\n.padding(10.dp)\n)\n}\n</code></pre> <pre><code>//TipTimeViewModel.kt\n\n//ADD THIS FUNCTION\nfun loadOrKeepTip(tipId: Int) {\nif (currentTipId == null || currentTipId == 0) { // Assuming 0 is not a valid ID\nloadTipById(tipId)\n}\n}\n</code></pre> <pre><code>//TipTimeViewModel.kt\n\n//MODIFY THIS FUNCTION\nfun deleteTip() {\nval tipId = currentTipId ?: return // If no current tip, do nothing\nval tip = Tip(\nid = tipId,\nbillAmount = _uiState.value.amountInput.toDoubleOrNull() ?: 0.0,\ntipPercentage = _uiState.value.tipInput.toIntOrNull() ?: 15,\nroundUp = _uiState.value.roundUp\n)\nviewModelScope.launch {\ntipRepository.deleteTip(tip)\nresetTip() //ADD THIS\n}\n}\n</code></pre> <p>Basically, we ensure that the tip ID is only reset when navigating to the Edit screen for a new tip or when returning to the Start screen. This prevents the tip ID from being lost during configuration changes like screen rotations.</p>"},{"location":"U04%20Persistence%20with%20Room/U04.2%20Room%20guided%20practice/#improvements","title":"Improvements","text":"<p>The basic functionality is in place, but still some possible improvements to the app could be:</p> <ul> <li>Show snackbars to inform the user about successful save, update, or delete operations.</li> <li>Improve navigation.</li> <li>Disable the save/update button when the input fields are blank or invalid.</li> <li>Add confirmation dialog before deleting a tip.</li> </ul>"},{"location":"U04%20Persistence%20with%20Room/U04.2%20Room%20guided%20practice/#references","title":"References","text":"<p>In the codelab you can see more details about Room and how to use it in Android apps: Use Room for data persistence</p>"},{"location":"U04%20Persistence%20with%20Room/U04.2%20Room%20guided%20practice/#source-code","title":"Source code","text":"<p>GitHub repository</p>"},{"location":"U04%20Persistence%20with%20Room/U04.3%20Relationships/","title":"Unit 4.3. Relationships with Room","text":""},{"location":"U04%20Persistence%20with%20Room/U04.3%20Relationships/#types-of-relationships","title":"Types of relationships","text":"<p>There are 4 types of relationships in Room:</p> <ul> <li>One-to-One: A single entity is related to a single instance of another entity.</li> <li>One-to-Many: A single entity is related to multiple instances of another entity.</li> <li>Many-to-Many: Multiple instances of one entity are related to multiple instances of another entity.</li> <li>Nested relationships: Entities can contain other entities as fields, creating a hierarchy.</li> </ul>"},{"location":"U04%20Persistence%20with%20Room/U04.3%20Relationships/#implementing-relationships","title":"Implementing relationships","text":"<p>In Room, there are 2 main ways to implement relationships:</p> <p>Using an intermediate data class to represent the relationship. This class contains fields for both entities involved in the relationship:</p> <pre><code>@Dao\ninterface UserBookDao {\n@Query(\n\"SELECT user.name AS userName, book.name AS bookName \" +\n\"FROM user, book \" +\n\"WHERE user.id = book.user_id\"\n)\nfun loadUserAndBookNames(): Flow&lt;List&lt;UserBook&gt;&gt;\n}\n\ndata class UserBook(val userName: String?, val bookName: String?)\n</code></pre> <p>Using the multimap return types approach. You define a multimap return:</p> <pre><code>@Query(\n\"SELECT * FROM user\" +\n\"JOIN book ON user.id = book.user_id\"\n)\nfun loadUserAndBookNames(): Map&lt;User, List&lt;Book&gt;&gt;\n</code></pre> <p>In this case, Room will automatically create a map where each <code>User</code> is associated with a list of <code>Book</code> objects.</p>"},{"location":"U04%20Persistence%20with%20Room/U04.3%20Relationships/#one-to-one-relationship","title":"One-to-one relationship","text":"<p>In a one-to-one relationship, each instance of an entity is associated with a single instance of another entity.</p> <pre><code>@Entity\ndata class User(\n@PrimaryKey val id: Int,\nval userName: String\n)\n\n@Entity\ndata class Book(\n@PrimaryKey val bookId: Int,\nval bookName: String,\nval userId: Int\n)\n</code></pre> <p>To query the one-to-one relationship, you can create a data class that combines both entities:</p> <pre><code>data class UserWithBook(\n@Embedded val user: User,\n@Relation(\nparentColumn = \"id\",\nentityColumn = \"userId\"\n)\nval book: Book\n)\n</code></pre> <p>Finally, you can create a DAO method to retrieve the data:</p> <pre><code>@Transaction\n@Query(\"SELECT * FROM User\")\nfun getUsersWithBooks(): List&lt;UserWithBook&gt;\n</code></pre> <p>Transaction annotation</p> <p>The <code>@Transaction</code> annotation ensures that the query is executed in a single transaction, which is important for maintaining data integrity.</p>"},{"location":"U04%20Persistence%20with%20Room/U04.3%20Relationships/#one-to-many-relationship","title":"One-to-many relationship","text":"<p>In a one-to-many relationship, a single instance of an entity is associated with multiple instances of another entity.</p> <pre><code>@Entity\ndata class User(\n@PrimaryKey val id: Int,\nval userName: String\n)\n\n@Entity\ndata class Book(\n@PrimaryKey val bookId: Int,\nval bookName: String,\nval userId: Int\n)\n\ndata class UserWithBooks(\n@Embedded val user: User,\n@Relation(\nparentColumn = \"id\",\nentityColumn = \"userId\"\n)\nval books: List&lt;Book&gt;\n)\n</code></pre> <p>To query the one-to-many relationship, you can create a DAO method:</p> <pre><code>@Transaction\n@Query(\"SELECT * FROM User\")\nfun getUsersWithBooks(): List&lt;UserWithBooks&gt;\n</code></pre>"},{"location":"U04%20Persistence%20with%20Room/U04.3%20Relationships/#many-to-many-relationship","title":"Many-to-many relationship","text":"<p>In a many-to-many relationship, multiple instances of one entity are associated with multiple instances of another entity. This is typically implemented using an associative entity.</p> <pre><code>@Entity\ndata class Student(\n@PrimaryKey val studentId: Int,\nval studentName: String\n)\n\n@Entity\ndata class Course(\n@PrimaryKey val courseId: Int,\nval courseName: String\n)\n\n@Entity(primaryKeys = [\"studentId\", \"courseId\"])\ndata class StudentCourseCrossRef(\nval studentId: Int,\nval courseId: Int\n)\n</code></pre> <p>Then, you need to create data classes to represent the relationships:</p> <pre><code>data class StudentWithCourses(\n@Embedded val student: Student,\n@Relation(\nparentColumn = \"studentId\",\nentityColumn = \"courseId\",\nassociateBy = Junction(StudentCourseCrossRef::class)\n)\nval courses: List&lt;Course&gt;\n)\n\ndata class CourseWithStudents(\n@Embedded val course: Course,\n@Relation(\nparentColumn = \"courseId\",\nentityColumn = \"studentId\",\nassociateBy = Junction(StudentCourseCrossRef::class)\n)\nval students: List&lt;Student&gt;\n)\n</code></pre> <p>Finally, you can create DAO methods to retrieve the data:</p> <pre><code>@Transaction\n@Query(\"SELECT * FROM Student\")\nfun getStudentsWithCourses(): List&lt;StudentWithCourses&gt;\n\n@Transaction\n@Query(\"SELECT * FROM Course\")\nfun getCoursesWithStudents(): List&lt;CourseWithStudents&gt;\n</code></pre>"},{"location":"U04%20Persistence%20with%20Room/U04.3%20Relationships/#transactions","title":"Transactions","text":"<p>When performing multiple related database operations, it's important to ensure that they are executed atomically. Room provides the <code>@Transaction</code> annotation to handle this.</p> <pre><code>@Dao\ninterface UserDao {\n@Transaction\nsuspend fun insertUserAndBooks(user: User, books: List&lt;Book&gt;) {\ninsertUser(user)\nbooks.forEach { insertBook(it) }\n}\n\n@Insert\nsuspend fun insertUser(user: User)\n\n@Insert\nsuspend fun insertBook(book: Book)\n}\n</code></pre> <p>In this code snippet, the <code>insertUserAndBooks</code> method is annotated with <code>@Transaction</code>, ensuring that both the user and their books are inserted atomically.</p> <p>When you call a transaction inside a try-catch block, if any operation fails, the entire transaction is rolled back, maintaining data integrity:</p> <pre><code>try {\nuserDao.insertUserAndBooks(user, books)\n} catch (e: Exception) {\n// Handle the error\n}\n</code></pre>"},{"location":"U04%20Persistence%20with%20Room/U04.3%20Relationships/#references","title":"References","text":"<ul> <li>Room Relationships</li> </ul>"},{"location":"U04%20Persistence%20with%20Room/U04.4%20More/","title":"Unit 4.4. More about Android development","text":"<p>At this point, you can develop a large variety of Android applications. However, there are many more topics and advanced features in Android development that you can explore to enhance your skills further.</p> <p>Here you have some links to additional resources and topics you might find interesting:</p>"},{"location":"U04%20Persistence%20with%20Room/U04.4%20More/#ui","title":"UI","text":"<ul> <li>Change the App icon</li> <li>Simple animations with Jetpack Compose</li> <li>Adaptative layouts</li> <li>Grid layouts</li> </ul>"},{"location":"U04%20Persistence%20with%20Room/U04.4%20More/#preferences-and-storage","title":"Preferences and storage","text":"<ul> <li>Permissions</li> <li>DataStore: Preferences</li> <li>Shared Storage</li> </ul>"},{"location":"U04%20Persistence%20with%20Room/U04.4%20More/#connectivity","title":"Connectivity","text":"<ul> <li>Connecting to the internet and loading data</li> <li>Using Google Maps</li> </ul>"},{"location":"U04%20Persistence%20with%20Room/U04.4%20More/#sensors-and-hardware","title":"Sensors and hardware","text":"<ul> <li>Sensors</li> <li>Camera</li> <li>User location</li> </ul>"},{"location":"U04%20Persistence%20with%20Room/U04.4%20More/#services-and-background-tasks","title":"Services and background tasks","text":"<ul> <li>WorkManager</li> <li>Services</li> </ul>"},{"location":"U04%20Persistence%20with%20Room/U04.4%20More/#publishing-your-app","title":"Publishing your app","text":"<ul> <li>Google Play Console</li> </ul>"},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.1%20Introduction%20to%20Flutter/","title":"Unit 5.1. Introduction to Flutter","text":"<p>Flutter is an open-source UI software development kit created by Google. It is used to develop cross-platform applications for Android, iOS, Linux, macOS, Windows and the web from a single codebase. Flutter was first announced in 2015 and released in May 2017.</p> <p></p>"},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.1%20Introduction%20to%20Flutter/#key-features-of-flutter","title":"Key Features of Flutter","text":"<ul> <li>Cross-Platform Development: Write once, run anywhere. Flutter allows developers to create applications that work on multiple platforms without needing to rewrite code for each one.</li> <li>Hot Reload: Flutter's hot reload feature allows developers to see changes in real-time without restarting the application, significantly speeding up the development process.</li> <li>Rich Widget Library: Flutter provides a comprehensive set of pre-designed widgets that follow both Material Design (for Android) and Cupertino (for iOS) guidelines, enabling developers to create visually appealing UIs.</li> <li>High Performance: Flutter applications are compiled to native code, which ensures high performance and smooth animations.</li> <li>Customizable UI: Flutter's widget-based architecture allows for extensive customization of UI components, enabling developers to create unique designs.</li> <li>Strong Community and Ecosystem: Flutter has a growing community and a rich ecosystem of packages and plugins that extend its functionality.</li> </ul>"},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.1%20Introduction%20to%20Flutter/#the-dart-programming-language","title":"The Dart Programming Language","text":"<p>Flutter uses Dart as its programming language. Dart is an object-oriented, class-based language with a syntax similar to JavaScript and Java.</p> <p></p> <p>It is designed for building high-performance applications and offers features such as:</p> <ul> <li>Ahead-of-Time (AOT) Compilation: Dart can be compiled to native code (machine code), which improves the performance of Flutter applications.</li> <li>Just-in-Time (JIT) Compilation: During development, Dart supports JIT compilation, allowing for features like hot reload.</li> <li>Asynchronous Programming: Dart has built-in support for asynchronous programming using <code>async</code> and <code>await</code>, making it easier to handle tasks like network requests and file I/O.</li> </ul> <p>The Dart language documentation can be found at: https://dart.dev/guides</p>"},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.1%20Introduction%20to%20Flutter/#the-flutter-widgets","title":"The Flutter Widgets","text":"<p>In Flutter, everything is a widget. Widgets are the building blocks of a Flutter application's user interface. They describe what their view should look like given their current configuration and state. There are two main types of widgets:</p> <ul> <li>Stateless Widgets: These widgets do not maintain any state. They are immutable and are rebuilt whenever their configuration changes. Examples include <code>Text</code>, <code>Icon</code>, and <code>RaisedButton</code>.</li> <li>Stateful Widgets: These widgets maintain state that can change over time. They are mutable and can rebuild themselves when their state changes. Examples include <code>Checkbox</code>, <code>TextField</code>, and <code>Slider</code>.</li> </ul> <p>You can learn more about Flutter widgets at: https://flutter.dev/docs/development/ui/widgets</p> <p>In the next table you can see the correspondence between the most common Jetpack Compose composables and their Flutter widget equivalents:</p> Jetpack Compose Composable Flutter Widget Text Text Button ElevatedButton Column Column Row Row Box Container Image Image Scaffold Scaffold TextField TextField LazyColumn ListView Card Card Icon Icon FloatingActionButton FloatingActionButton Modifier BoxDecoration / EdgeInsets / etc. Spacer SizedBox TopAppBar AppBar Snackbar SnackBar"},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.1%20Introduction%20to%20Flutter/#the-widgets-tree","title":"The widgets tree","text":"<p>In Flutter, the user interface is built using a hierarchical structure of widgets, known as the widget tree. Each widget can have child widgets, which in turn can have their own children, forming a tree-like structure. The root of the tree is typically a <code>MaterialApp</code> or <code>CupertinoApp</code> widget, which provides the overall structure and theme for the application.</p> <p>The widget tree is essential for understanding how Flutter builds and renders the UI. When a widget's state changes, Flutter efficiently rebuilds only the affected parts of the widget tree, ensuring optimal performance. </p> <p>For instance, a simple Flutter app might have a widget tree that looks like this:</p> <p></p> <p>Material and Cupertino</p> <p>Flutter provides two sets of design languages: Material Design (used for Android) and Cupertino (used for iOS).</p> <p>The Material design language was created for any platform, not just Android. When you write a Material app in Flutter, it has the Material look and feel on all devices, even iOS. If you want your app to look like a standard iOS-styled app, then you would use the Cupertino library.</p> <p>You can technically run a Cupertino app on either Android or iOS, but (due to licensing issues) Cupertino won't have the correct fonts on Android. For this reason, use an iOS-specific device when writing a Cupertino app.</p>"},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.1%20Introduction%20to%20Flutter/#starting-with-flutter","title":"Starting with Flutter","text":"<p>To start developing with Flutter, you need to set up your development environment. Follow the steps form the official Flutter installation guide</p> <p>Task</p> <ul> <li>Create a new Flutter App project using Android Studio (don't forget to install the Flutter and Dart plugins).</li> <li>Explore the default project structure and identify the main files and directories.</li> <li>Run the default Flutter app on an emulator or physical device to see it in action.</li> <li>Add the plugin Flutter Snipets by George Herbert and try some of the snippets listed in https://github.com/georgeherby/flutter-snippets/blob/master/README.md</li> </ul> <p>The most important files and directories in a Flutter project are:</p> <ul> <li><code>lib/main.dart</code>: The main entry point of the application where the app's execution starts.</li> <li><code>pubspec.yaml</code>: The configuration file for the project, where you can specify dependencies, assets, and other settings.</li> <li><code>analysis_options.yaml</code>: Configuration file for static analysis options.</li> <li><code>android/</code>, <code>ios/</code>, <code>linux/</code>, <code>windows/</code>, <code>web/</code>: Directories containing platform-specific code for each platform, respectively.</li> <li><code>test/</code>: Directory for writing unit and widget tests for the application.</li> </ul>"},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.1%20Introduction%20to%20Flutter/#installing-packages","title":"Installing packages","text":"<p>Flutter uses a package manager called pub to manage dependencies. You can add packages to your project by specifying them in the <code>pubspec.yaml</code> file under the <code>dependencies</code> section. After adding a package, run <code>flutter pub get</code> to install it.</p> <p>Otherwise, you can use the command line to add packages. For example, to add the <code>http</code> package, you would run:</p> <pre><code>flutter pub add http\nflutter pub get\n</code></pre> <p>If we want to add a package only for the developer environment (for example, testing packages), we can add it under the <code>dev_dependencies</code> section:</p> <pre><code>flutter pub add dev:flutter_test\nflutter pub get\n</code></pre> <p>We can specify a particular version of a package by appending the version number:</p> <pre><code>flutter pub add http: ^0.13.0\nflutter pub get\n</code></pre> <p>Here, <code>^0.13.0</code> indicates that we want to use version 0.13.0 or any compatible newer version.</p> <p>Other useful commands are:</p> <ul> <li><code>flutter pub upgrade</code>: Upgrades all the dependencies to the latest versions.</li> <li><code>flutter pub remove &lt;package_name&gt;</code>: Removes a package from the dependencies.</li> <li><code>flutter pub deps</code>: Lists all the dependencies in the project along with their versions.</li> </ul> <p>For search and explore available packages, you can visit the pub.dev website.</p> <p>Task</p> <ul> <li>Do the Codelab Write your first Flutter app</li> <li>Refactor the default Flutter app to separate the app's parts in screens, states and components folders.</li> </ul>"},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.1%20Introduction%20to%20Flutter/#flutter-documentation-and-resources","title":"Flutter Documentation and Resources","text":"<p>Some useful links to learn more about Flutter:</p> <ul> <li>Official Flutter Documentation: https://flutter.dev/docs</li> <li>Flutter learning resources: https://flutter.dev/learn</li> <li>Flutter widget catalog: https://flutter.dev/docs/development/ui/widgets/catalog</li> <li>Flutter YouTube Channel: https://www.youtube.com/flutterdev</li> </ul>"},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.2%20Flutter%20Architecture/","title":"Unit 5.2. Flutter Architecture","text":"<p>In this section, we will explore the architecture of basic Flutter applications, including the Provider state management approach.</p> <p>First of all, we need to review the difference between Stateless and Stateful widgets in Flutter.</p>"},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.2%20Flutter%20Architecture/#flutter-widgets-and-state-management","title":"Flutter widgets and state management","text":"<p>As you can remember from the previous section, there are 2 types of Flutter Widgets, Stateless and Stateful widgets.</p>"},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.2%20Flutter%20Architecture/#stateless-widgets","title":"Stateless Widgets","text":"<p>Stateless widgets are immutable, meaning that their properties cannot change - all values are final. A stateless widget is useful when the part of the user interface you are describing does not depend on anything other than the configuration information in the object itself and the <code>BuildContext</code> in which the widget is inflated.</p> <p>Let's recall the structure of a stateless widget:</p> <pre><code>class myWidget extends StatelessWidget {\nconst myWidget({super.key});\n\n@override\nWidget build(BuildContext context) {\nreturn const Placeholder();\n}\n}\n</code></pre> <p>As the most notable points, we see that it is a class that descends from the <code>StatelessWidget</code> class, has a constructor, and overrides the <code>build</code> method, which defines the appearance of the widget.</p> <p>The lifecycle of this type of widget can be represented as follows:</p> <p></p> <p>The widget's lifecycle begins with its constructor, to which arguments can be provided. Once created, and when it is inserted into the widget tree, the <code>build()</code> method, inherited from <code>StatelessWidget</code>, is invoked, and we will override it to establish its design.</p> <p>Once created, it is not destroyed, but is redrawn by invoking the <code>build()</code> method again whenever necessary, generally when a parent node in the widget tree needs to be redrawn.</p>"},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.2%20Flutter%20Architecture/#stateful-widgets","title":"Stateful Widgets","text":"<p>The structure of a stateful widget is as follows:</p> <pre><code>class myWidget extends StatefulWidget {\nconst myWidget({super.key});\n\n@override\nState&lt;myWidget&gt; createState() =&gt; _myWidgetState();\n}\n\nclass _myWidgetState extends State&lt;myWidget&gt; {\n@override\nWidget build(BuildContext context) {\nreturn const Placeholder();\n}\n}\n</code></pre> <p>We see that it is a Stateful widget because it descends from the <code>StatefulWidget</code> class, which indicates that it contains a mutable state. The constructor, like stateless widgets, in order to be referenced within the widget tree, will also have a key property.</p> <p>This class overrides the <code>createState()</code> method of the <code>StatefulWidget</code> class. This method is invoked by the framework when the widget is inserted into the widget tree for the first time, creating an instance of the state <code>_myWidgetState</code>. With this, every time the widget is redrawn, the framework will reuse this instance so that the state is not lost.</p> <p>We could therefore represent the lifecycle of a stateful widget very similarly to a stateless widget:</p> <p></p> <p>The state of the widget, on the other hand, is defined as a class descending from <code>State</code>, and it is here where we override the <code>build</code> method to construct the widget.</p> <p>This state, as we have commented, is mutable, and therefore has a more complex lifecycle. Let's look at this lifecycle and its relationship with the lifecycle of the widget it is associated with:</p> <p></p> <p>Let's contrast both lifecycles:</p> <p>Lifecycle of the Stateful Widget</p> <ol> <li>The lifecycle of the stateful widget begins by invoking its constructor.</li> <li>The <code>createState</code> method is invoked to create the associated state, so the state now begins its own lifecycle.</li> </ol> <p>Lifecycle of the State</p> <ol> <li>The lifecycle of the state begins with the invocation of its constructor via the <code>createState</code> method of the associated widget. Since the widget is not yet in the tree, we should not perform initializations here that depend on the context (Remember that the build context is determined by the widget's position in the tree).</li> <li>The <code>initState</code> method is launched, where operations for initializing data are generally carried out, or this data is obtained from external sources, such as a database or the network. When we override this method, we must invoke the constructor of its superclass, so that it performs initialization tasks. This method will be executed only once.</li> <li>The <code>didChangeDependencies</code> method is invoked once, immediately after <code>initState</code>. This method will be launched again only when some initialization involving a widget of type <code>InheritedWidget</code> needs to be done. At this point, Flutter marks this widget with the flag <code>dirty=true</code>, to indicate that it needs to be rebuilt.</li> <li>If a rebuild of the widget is needed (<code>dirty=true</code>), the <code>build()</code> method is invoked to determine the widgets that our widget will have to render. After this, the state is marked as clean, with <code>dirty=false</code>.</li> </ol> <p>At this point, we already have the widget inserted into the tree and rendered according to its state, so the widget is considered clean. From this moment on, several things can happen that set this flag back to <code>dirty</code> and imply a rebuild of it:</p> <ul> <li>5a.  If an event occurs (like a button tap) that modifies the state, the <code>setState()</code> method is invoked, which marks the state as <code>dirty=true</code> again, so that it is rebuilt in the <code>build</code> method, providing it with the updated state.</li> <li>5b.  If a parent widget requests that its descendants be rebuilt and this involves the widget in question, the <code>didUpdateWidget</code> method is invoked, providing it with the previous widget as an argument and marking the state as dirty, so that it is rebuilt again.</li> <li>5c.  If the widget depends on an <code>InheritedWidget</code> and this inherited widget changes, the <code>didChangeDependencies</code> method is invoked, also rebuilding the widget. Inherited widgets are a third type of widget that allows a descendant widget to directly access its state, without needing to go up the widget tree to reach it.</li> <li>6.  If the widget will no longer be used, <code>dispose()</code> is invoked to destroy it. In this method, animations should be stopped, connections closed, etc.</li> </ul>"},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.2%20Flutter%20Architecture/#navigation","title":"Navigation","text":"<p>Flutter provides a complete system for navigating between screens and handling deep links. Small applications without complex deep linking can use <code>Navigator</code>, while apps with specific deep linking and navigation requirements should also use the <code>Router</code> to correctly handle deep links on Android and iOS, and to stay in sync with the address bar when the app is running on the web. </p> <p>Deep Links</p> <p>Deep links are links that not only open an app, but also take the user to a specific location \"deep\" inside the app. For example, a deep link could take the user directly to a specific product page in a shopping app, rather than just opening the app's home screen.</p>"},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.2%20Flutter%20Architecture/#simple-navigation","title":"Simple Navigation","text":"<p>Navigation between different screens in a Flutter application is typically managed using the <code>Navigator</code> class, which maintains a stack of routes (screens).</p> <p>Terminology</p> <p>In Flutter, screens and pages are called routes.</p> <p></p> <p>The Navigator widget displays screens as a stack using the correct transition animations for the target platform. To navigate to a new screen, access the <code>Navigator</code> through the route's <code>BuildContext</code> and call imperative methods such as <code>push()</code> or <code>pop()</code>:</p> <pre><code>ElevatedButton(\nonPressed: () {\nNavigator.push(\ncontext,\nMaterialPageRoute(builder: (context) =&gt; SecondScreen()),\n);\n},\nchild: Text('Go to Second Screen'),\n);\n</code></pre> <p>The Navigator class also provides methods for more complex navigation scenarios, such as replacing the current route, removing routes from the stack, and more:</p> <ul> <li><code>pop()</code>: Removes the top route from the stack, returning to the previous screen.</li> <li><code>pushReplacement()</code>: Replaces the current route with a new one.</li> <li><code>popUntil()</code>: Pops routes until a specified condition is met.</li> <li><code>pushAndRemoveUntil()</code>: Pushes a new route and removes routes until a specified condition is met.</li> <li><code>pushReplacement()</code>: Replaces the current route on the top of the stack with a new one.</li> <li><code>replace()</code>: Replaces a route on the stack with a new one.</li> <li><code>replaceRouteBelow()</code>: Replaces a route below another route in the stack.</li> </ul> <p>Some examples:</p> <pre><code>// Pop the current route off the stack\nNavigator.pop(context);\n\n// Replace the current route with a new one\nNavigator.pushReplacement(\ncontext,\nMaterialPageRoute(builder: (context) =&gt; NewScreen()),\n);\n\n// Pop routes until a specific condition is met\nNavigator.popUntil(context, ModalRoute.withName('/home'));\n\n// Replace a route with a new one\nRoute oldRoute = ...;\nRoute newRoute = ...;\n\nNavigator.replace(\ncontext,\noldRoute: oldRoute,\nnewRoute: newRoute,\n);\n</code></pre> <p>In the next example, we can see a simple Flutter application with two screens and navigation between them using the <code>Navigator</code> class:</p> <pre><code>import 'package:flutter/material.dart';\n\nvoid main() {\nrunApp( MyApp());\n}\n\nclass MyApp extends StatelessWidget {\nconst MyApp({super.key});\n\n@override\nWidget build(BuildContext context) {\nreturn  MaterialApp(\ntitle: 'Sample',\ntheme: ThemeData(\ncolorScheme: ColorScheme.fromSeed(seedColor: Colors.lightGreen),\n),\nhome: FirstRoute(),\n);\n}\n}\n\nclass FirstRoute extends StatelessWidget {\nconst FirstRoute({super.key});\n\n@override\nWidget build(BuildContext context) {\nreturn Scaffold(\nappBar: AppBar(title: const Text('First Route')),\nbody: Center(\nchild: ElevatedButton(\nchild: const Text('Open route'),\nonPressed: () {\n// Navigate to second route when tapped.\n},\n),\n),\n);\n}\n}\n\nclass SecondRoute extends StatelessWidget {\nconst SecondRoute({super.key});\n\n@override\nWidget build(BuildContext context) {\nreturn Scaffold(\nappBar: AppBar(title: const Text('Second Route')),\nbody: Center(\nchild: ElevatedButton(\nonPressed: () {\n// Navigate back to first route when tapped.\n},\nchild: const Text('Go back!'),\n),\n),\n);\n}\n}\n</code></pre> <p>To navigate from the first route to the second route, we can use the <code>Navigator.push</code> method in the <code>onPressed</code> callback of the button in the <code>FirstRoute</code> class:</p> <pre><code>// Within the `FirstRoute` widget:\nonPressed: () {\nNavigator.push(\ncontext,\nMaterialPageRoute(\nbuilder: (context) =&gt; const SecondRoute(),\n),\n);\n}\n</code></pre> <p>To return to the first route from the second route, we can use the <code>Navigator.pop</code> method in the <code>onPressed</code> callback of the button in the <code>SecondRoute</code> class:</p> <pre><code>// Within the SecondRoute widget\nonPressed: () {\nNavigator.pop(context);\n}\n</code></pre>"},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.2%20Flutter%20Architecture/#design-patterns","title":"Design patterns","text":"<p>Flutter applications can be structured using various design patterns to manage complexity and improve maintainability. Some common design patterns used in Flutter development include:</p> <ul> <li>Provider Pattern: This pattern uses the <code>provider</code> package to manage state and dependencies in a Flutter application. It allows widgets to access shared data and services without tight coupling.</li> <li>BLoC (Business Logic Component) Pattern: This pattern separates business logic from the UI by using streams to manage state. It promotes a reactive programming model and helps in creating testable and maintainable code.   More info about the BLoC pattern can be found here.   </li> <li>MVVM (Model-View-ViewModel) Pattern: This pattern separates the UI (View) from the business logic (ViewModel) and data (Model). It allows for better separation of concerns and easier testing. You can see an example of the MVVM pattern applied to Flutter here. </li> </ul>"},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.2%20Flutter%20Architecture/#the-provider-pattern","title":"The Provider Pattern","text":"<p>The Provider Pattern is a widely used design pattern in Flutter for state management and dependency injection. It leverages the <code>provider</code> package to make data and services available to widgets throughout the widget tree without tight coupling.</p> <p>Info</p> <p>Provider is based on the <code>InheritedWidget</code> mechanism, which allows data to be efficiently propagated down the widget tree. It simplifies the process of sharing state and dependencies between widgets, making it easier to manage complex applications. </p> <p>The key concepts of the Provider Pattern include:</p> <ul> <li>Providers: These are classes that extend <code>ChangeNotifier</code> or other provider types (like <code>FutureProvider</code>, <code>StreamProvider</code>, etc.) to hold and manage state or services. They notify listeners when the state changes.</li> <li>Consumers: Widgets that listen to changes in the provider and rebuild themselves when the provider notifies them of changes. The <code>Consumer</code> widget or the <code>Provider.of&lt;T&gt;(context)</code> method can be used to access the provider's data.</li> <li>ChangeNotifierProvider: A specific type of provider that listens to a <code>ChangeNotifier</code> and rebuilds dependent widgets when notified of changes.</li> <li>MultiProvider: A widget that allows multiple providers to be created and made available to the widget tree.</li> </ul> <p></p> <p>Here's a simple example of using the Provider Pattern in a Flutter application. First of all, add the <code>provider</code> package to your <code>pubspec.yaml</code> file:</p> <pre><code>dependencies:\nflutter:\nsdk: flutter\nprovider: ^6.0.0\n</code></pre> <p>Next, create a simple model class that extends <code>ChangeNotifier</code> to manage the state:</p> <pre><code>import 'package:flutter/foundation.dart';\n\nclass CounterModel extends ChangeNotifier {\nint _count = 0;\n\nint get count =&gt; _count;\n\nvoid increment() {\n_count++;\nnotifyListeners(); // Notify listeners about the change\n}\n}\n</code></pre> <p>Now, set up the provider in your main application file:</p> <pre><code>import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nimport 'counter_model.dart'; // Import the CounterModel\n\nvoid main() {\nrunApp( MyApp() );\n}\n\nclass MyApp extends StatelessWidget {\nconst MyApp({super.key});\n\n@override\nWidget build(BuildContext context) {\nreturn ChangeNotifierProvider( // Here we set up the provider\ncreate: (context) =&gt; CounterModel(),\nchild: MaterialApp(\nhome: CounterScreen(),\n),\n);\n}\n}\n</code></pre> <p>Finally, create a screen that consumes the provider and displays the counter value:</p> <pre><code>import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nimport 'counter_model.dart';\n\nclass CounterScreen extends StatelessWidget {\nconst CounterScreen({super.key});\n\n@override\nWidget build(BuildContext context) {\nreturn Scaffold(\nappBar: AppBar(title: const Text('Provider Example')),\nbody: Center(\nchild: Consumer&lt;CounterModel&gt;(\nbuilder: (context, counter, child) {\nreturn Text('Count: ${counter.count}');\n},\n),\n),\nfloatingActionButton: FloatingActionButton(\nonPressed: () {\nProvider.of&lt;CounterModel&gt;(context, listen: false).increment();\n},\nchild: const Icon(Icons.add),\n),\n);\n}\n}\n</code></pre> <p>In this example, we created a simple counter application using the Provider Pattern. The <code>CounterModel</code> class manages the counter state and notifies listeners when the count changes. The <code>ChangeNotifierProvider</code> makes the <code>CounterModel</code> available to the widget tree, and the <code>Consumer</code> widget listens for changes and rebuilds the UI accordingly.</p> <p>Instead of Consumer, we could also use <code>Provider.of&lt;CounterModel&gt;(context)</code> directly in the <code>build</code> method to access the counter value, but using <code>Consumer</code> is often more efficient as it only rebuilds the specific part of the widget tree that depends on the provider.</p> <p>The same example with <code>Provider.of</code> would look like this:</p> <pre><code>class CounterScreen extends StatelessWidget {\nconst CounterScreen({super.key});\n\n@override\nWidget build(BuildContext context) {\nfinal counter = Provider.of&lt;CounterModel&gt;(context);\n\nreturn Scaffold(\nappBar: AppBar(title: const Text('Provider Example')),\nbody: Center(\nchild: Text('Count: ${counter.count}'),\n),\nfloatingActionButton: FloatingActionButton(\nonPressed: () {\ncounter.increment();\n},\nchild: const Icon(Icons.add),\n),\n);\n}\n}\n</code></pre> <p>The diagram below illustrates the relationship between the main components of the Provider Pattern in this example:</p> <pre><code>graph TD\n    A[&lt;b&gt;MyApp&lt;/b&gt; \\n &lt;i&gt;ChangeNotifierProvider&lt;/i&gt;] --&gt; B[&lt;b&gt;CounterScreen&lt;/b&gt; \\n &lt;i&gt;Consumer&lt;/i&gt;]\n    B --&gt; C([&lt;b&gt;CounterModel&lt;/b&gt; \\n &lt;i&gt;ChangeNotifier&lt;/i&gt;])\n    C -.-&gt; A</code></pre> <p>In case we need to manage multiple providers, we can use the <code>MultiProvider</code> widget to simplify the setup:</p> <pre><code>return MultiProvider(\nproviders: [\nChangeNotifierProvider(create: (context) =&gt; CounterModel()),\nChangeNotifierProvider(create: (context) =&gt; AnotherModel()),\n],\nchild: MaterialApp(\nhome: CounterScreen(),\n),\n);\n</code></pre> <p>This way, we can easily manage multiple providers in our Flutter application using the Provider Pattern.</p>"},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.3%20Geolocation/","title":"Unit 5.3. Geolocation with Flutter","text":""},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.3%20Geolocation/#install-the-geolocation-package","title":"Install the geolocation package","text":"<p>We will use the <code>geolocator</code> package to access the device's location services. Add the following dependency to your <code>pubspec.yaml</code> file:</p> <pre><code>flutter pub add geolocator\n</code></pre> <p>We also need the <code>provider</code> package for state management. If you don't have it yet, add it as well:</p> <pre><code>flutter pub add provider\n</code></pre> <p>On Android you'll need to add either the <code>ACCESS_COARSE_LOCATION</code> or the <code>ACCESS_FINE_LOCATION</code> permission to your <code>Android Manifest</code>. To do so open the AndroidManifest.xml file (located under <code>android/app/src/main</code>) and add one of the following two lines as direct children of the <code>&lt;manifest&gt;</code> tag (when you configure both permissions the <code>ACCESS_FINE_LOCATION</code> will be used by the geolocator plugin):</p> <pre><code>&lt;uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\" /&gt;\n&lt;uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" /&gt;\n</code></pre> <p>FINE and COARSE location</p> <p>The <code>ACCESS_FINE_LOCATION</code> permission provides a more accurate location using GPS, while the <code>ACCESS_COARSE_LOCATION</code> permission provides a less accurate location using Wi-Fi and cell towers. Choose the permission that best fits your app's needs.</p> <p>On iOS you'll need to add the following entry to your Info.plist file (located under <code>ios/Runner</code>) in order to access the device's location. Simply open your Info.plist file and add the following (make sure you update the description so it is meaningful in the context of your App):</p> <pre><code>&lt;key&gt;NSLocationWhenInUseUsageDescription&lt;/key&gt;\n&lt;string&gt;This app needs access to location when open.&lt;/string&gt;\n</code></pre>"},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.3%20Geolocation/#getting-a-single-location","title":"Getting a single location","text":"<p>Before start coding, we are going to do the next app files:</p> <ul> <li><code>main.dart</code>: the entry point of the app.</li> <li><code>my_app.dart</code>: the main widget of the app.</li> <li><code>location_screen.dart</code>: the screen that shows the location.</li> <li><code>location_provider.dart</code>: the provider that handles the location logic.</li> </ul> <p>In <code>my_app.dart</code>, we will set up the MaterialApp and the ChangeNotifierProvider for listening to location changes from the LocationProvider.</p> <pre><code>// my_app.dart\nimport 'package:provider/provider.dart';\n\nimport 'location_screen.dart';\n\nclass MyApp extends StatelessWidget {\nconst MyApp({super.key});\n\n@override\nWidget build(BuildContext context) {\nreturn ChangeNotifierProvider(\ncreate: (BuildContext context) =&gt; LocationProvider(),\nchild: MaterialApp(\ntitle: 'Geolocation App',\ntheme: ThemeData(\ncolorScheme: ColorScheme.fromSeed(seedColor: Colors.lightBlue),\n),\ndebugShowCheckedModeBanner: false,\nhome: LocationScreen() ,\n),\n);\n}\n}\n</code></pre> <p>In the location_provider.dart file, we will implement the logic to get the current location using the Geolocator package. First, we create a property to hold the current position, <code>currentPosition</code>:</p> <pre><code>// location_provider.dart\n\nimport 'dart:async';\n\nimport 'package:flutter/material.dart';\nimport 'package:geolocator/geolocator.dart';\n\nclass LocationProvider with ChangeNotifier {\nPosition? _currentPosition;\nPosition? get currentPosition =&gt; _currentPosition;\n}\n</code></pre> <p>Following the Geolocator package documentation, we will implement a private method to check and request location permissions, <code>checkPermission()</code>:</p> <pre><code>// location_provider.dart\n\nFuture&lt;Position&gt; _determinePosition() async {\n// Check if location services are enabled\nbool serviceEnabled = await Geolocator.isLocationServiceEnabled();\n\nif (!serviceEnabled) {\n// Location services are not enabled return an error message\nreturn Future.error('Location services are disabled.');\n}\n\n// Check location permissions\nLocationPermission permission = await Geolocator.checkPermission();\nif (permission == LocationPermission.denied) {\npermission = await Geolocator.requestPermission();\n\nif (permission == LocationPermission.denied) {\nreturn Future.error('Location permissions are denied');\n}\n}\n\nif (permission == LocationPermission.deniedForever) {\nreturn Future.error(\n'Location permissions are permanently denied, we cannot request permissions.',\n);\n}\n\n// If permissions are granted, return the current location\nreturn await Geolocator.getCurrentPosition();\n}\n</code></pre> <p>Now, we will implement the <code>fetchCurrentLocation()</code>, inside the LocationProvider class, that will use <code>_determinePosition()</code> to get the current location and update the <code>currentPosition</code> property:</p> <pre><code>// location_provider.dart\n\nFuture&lt;void&gt; fetchCurrentLocation() async {\ntry {\n_currentPosition = await _determinePosition();\nnotifyListeners();\n} catch (e) {\n// Handle location errors here if necessary\nprint(e);\n}\n}\n</code></pre> <p>This method will be called from the UI to fetch the current location when needed. Note how we call <code>notifyListeners()</code> to inform any listeners that the location has been updated.</p> <p>Finally, in the <code>location_screen.dart</code> file, we will create a simple UI to display the current location and a button to fetch it:</p> <pre><code>// location_screen.dart\n\nimport 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nimport 'location_provider.dart';\n\nclass LocationScreen extends StatefulWidget {\nconst LocationScreen({super.key});\n\n@override\nState&lt;LocationScreen&gt; createState() =&gt; _LocationScreenState();\n}\n\nclass _LocationScreenState extends State&lt;LocationScreen&gt; {\n\n\nFuture&lt;void&gt; _fetchCurrentLocation() async {\nfinal provider = Provider.of&lt;LocationProvider&gt;(context, listen: false);\nawait provider.fetchCurrentLocation();\n}\n\n@override\nWidget build(BuildContext context) {\nvar locationProvider = Provider.of&lt;LocationProvider&gt;(context, listen: true);\nfinal pos = locationProvider.currentPosition;\n\nreturn Scaffold(\nappBar: AppBar(\ntitle: const Text('Live Location'),\ncenterTitle: true,\nbackgroundColor: Theme.of(context).colorScheme.primary,\n),\nbody: Center(\nchild: pos != null\n? Column(\nmainAxisSize: MainAxisSize.min,\nchildren: [\nconst SizedBox(height: 16),\n\nText('Latitude: ${pos.latitude}'),\nText('Longitude: ${pos.longitude}'),\nconst SizedBox(height: 8),\nText('Accuracy: ${pos.accuracy} m'),\nText('Timestamp: ${pos.timestamp ?? 'N/A'}'),\n],\n)\n: const Text('No location yet. Tap \"Get location\" to get it.'),\n),\nfloatingActionButton: FloatingActionButton.extended(\nonPressed: _fetchCurrentLocation,\nlabel: Text('Get location'),\nicon: Icon(Icons.map),\n),\n);\n}\n}\n</code></pre> <p>Here we are using a StatefulWidget to manage the state of the location fetching process. The <code>_fetchCurrentLocation()</code> method calls the <code>fetchCurrentLocation()</code> method from the LocationProvider when the button is pressed. The UI displays the current latitude, longitude, accuracy, and timestamp if a location is available; otherwise, it prompts the user to get the location.</p> <p>Futures</p> <p>A <code>Future</code> in Dart represents a potential value or error that will be available at some time in the future. It is used for asynchronous programming, allowing you to perform tasks that may take time (like fetching data from the internet or accessing device features) without blocking the main thread of execution. More info about Futures here.</p> <p>The first time we launch the app, it will ask for location permissions.</p> <p></p> <p>Once running, the app will look like this:</p> <p></p> <p>If we are using the Android Studio emulator, we can simulate location changes by going to the \"Extended controls\" (three dots icon) &gt; \"Location\" and entering new latitude and longitude values.</p> <p></p>"},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.3%20Geolocation/#getting-continuous-location-updates","title":"Getting continuous location updates","text":"<p>To get continuous location updates, we will modify the <code>LocationProvider</code> to include a stream subscription that listens for location changes. We will use the <code>getPositionStream()</code> method from the Geolocator package.</p> <p>First, we need to add a <code>StreamSubscription&lt;Position&gt;</code> property to the <code>LocationProvider</code> class to manage the subscription:</p> <pre><code>// location_provider.dart\n\nclass LocationProvider with ChangeNotifier {\nPosition? _currentPosition;\nPosition? get currentPosition =&gt; _currentPosition;\n\nStreamSubscription&lt;Position&gt;? _positionStream; //ADD THIS\n}\n...\n</code></pre> <p>The core of the continuous location updates will be handled by a new method called <code>startListening()</code>. This method will set up the stream subscription to listen for location updates:</p> <pre><code>// location_provider.dart\n\n/// Start listening to location updates. This will request permissions if needed\n/// (by calling determinePosition) and then subscribe to the position stream.\nFuture&lt;void&gt; startListening({LocationSettings? locationSettings}) async {\n// Try to read a cached last-known position first to give callers\n// a quick value while we request permissions or fetch a fresh position.\ntry {\nfinal lastKnown = await Geolocator.getLastKnownPosition(); if (lastKnown != null) {\n_currentPosition = lastKnown;\nnotifyListeners();\n}\n} catch (e) {\n// Non-fatal: continue to request a fresh position below.\nprint('startListening: getLastKnownPosition failed: $e');\n}\n\n// Ensure permissions and services are available before starting the stream\ntry {\n// Capture and store the initial/current position so callers have a value\n// available immediately after startListening completes.\nfinal initialPosition = await _determinePosition();\n_currentPosition = initialPosition;\nnotifyListeners();\n} catch (e) {\n// If we couldn't obtain a single position (permissions/service disabled),\n// do not start the stream. Caller can inspect logs or call fetchCurrentLocation.\nprint('startListening: could not determine position first: $e');\nreturn;\n}\n\n// Avoid double subscription (Singleton pattern)\nif (_positionStream != null) return;\n\n// Use provided settings or default ones\nfinal settings =\nlocationSettings ??\nconst LocationSettings(\naccuracy: LocationAccuracy.best,\ndistanceFilter: 10,\n);\n\n// Subscribe to the position stream\n_positionStream = Geolocator.getPositionStream(locationSettings: settings)\n.listen(\n(Position position) {\n_currentPosition = position;\nnotifyListeners();\n},\nonError: (error) {\nprint('Position stream error: $error');\n},\n);\n}\n</code></pre> <p>In this function, we first try to get the last known position to provide a quick initial value: <code>Geolocator.getLastKnownPosition()</code>.</p> <p>Then, we ensure that location services and permissions are available by calling <code>_determinePosition()</code>. If successful, we set up the stream subscription using <code>Geolocator.getPositionStream()</code> with the provided or default location settings.</p> <p>To stop listening to location updates, we will implement a <code>stopListening()</code> method that cancels the stream subscription:</p> <pre><code>// location_provider.dart\n\nFuture&lt;void&gt; stopListening() async {\nawait _positionStream?.cancel();\n_positionStream = null;\n}\n</code></pre> <p>Also, we need to ensure that we clean up the subscription when the <code>LocationProvider</code> is disposed of. We can override the <code>dispose()</code> method of the provider to call <code>stopListening()</code>:</p> <pre><code>// location_provider.dart\n\n/// Clean up resources when the provider is disposed.\n@override\nvoid dispose() {\nstopListening();\nsuper.dispose();\n}\n</code></pre> <p>With these changes, the <code>LocationProvider</code> can now provide continuous location updates to any listeners. You can call <code>startListening()</code> to begin receiving updates and <code>stopListening()</code> to stop them when they are no longer needed.</p> <p>The next step is to update the <code>LocationScreen</code> to start and stop listening for location updates when the screen is initialized and disposed of, respectively.</p> <p>Create a new StatefulWidget called <code>ContinuousLocationScreen</code> (you can duplicate the existing <code>LocationScreen</code>) and assign it to the home property in <code>my_app.dart</code>. The new screen is similar to the previous one but includes calls to <code>startListening()</code> and <code>stopListening()</code> in the appropriate lifecycle methods:</p> <pre><code>// continuous_location_screen.dart\n\nimport 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\n\nimport 'location_provider.dart';\n\nclass ContinuousLocationScreen extends StatefulWidget {\nconst ContinuousLocationScreen({super.key});\n\n@override\nState&lt;ContinuousLocationScreen&gt; createState() =&gt; _ContinuousLocationScreenState();\n}\n\nclass _ContinuousLocationScreenState extends State&lt;ContinuousLocationScreen&gt; {\n\n@override\nvoid initState() {\nsuper.initState();\nfinal provider = Provider.of&lt;LocationProvider&gt;(context, listen: false);\nprovider.startListening();\n}\n\n@override\nvoid dispose() {\nfinal provider = Provider.of&lt;LocationProvider&gt;(context, listen: false);\nprovider.stopListening();\nsuper.dispose();\n}\n\n@override\nWidget build(BuildContext context) {\nvar locationProvider = Provider.of&lt;LocationProvider&gt;(context, listen: true);\nfinal pos = locationProvider.currentPosition;\n\nreturn Scaffold(\nappBar: AppBar(\ntitle: const Text('Live Location'),\ncenterTitle: true,\nbackgroundColor: Theme.of(context).colorScheme.primary,\n),\nbody: Center(\nchild: pos != null\n? Column(\nmainAxisSize: MainAxisSize.min,\nchildren: [\nconst SizedBox(height: 16),\n\nText('Latitude: ${pos.latitude}'),\nText('Longitude: ${pos.longitude}'),\nconst SizedBox(height: 8),\nText('Accuracy: ${pos.accuracy} m'),\nText('Timestamp: ${pos.timestamp ?? 'N/A'}'),\n],\n)\n: const Text('No location yet. Wait a moment.'),\n)\n);\n}\n}\n</code></pre> <p>Task</p> <p>Modify the <code>ContinuousLocationScreen</code> to include a button that allows the user to manually start and stop location updates. The button should toggle between \"Start Listening\" and \"Stop Listening\" based on the current state of the location updates.</p>"},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.3%20Geolocation/#showing-location-on-a-map","title":"Showing location on a map","text":"<p>To display the user's location on a map, we are going to use the next packages:</p> <ul> <li>flutter_map: that provides a customizable map widget based on OpenStreetMap.</li> <li>latlong2: that provides latitude and longitude data types.</li> </ul> <p>Import them using the following commands:</p> <pre><code>flutter pub add flutter_map\nflutter pub add latlong2\n</code></pre> <p>The <code>pubspec.yaml</code> file should now include these dependencies:</p> <pre><code># pubspec.yaml\n\ndependencies:\nflutter:\nsdk: flutter\ngeolocator: ^14.0.2\nprovider: ^6.1.5+1\nflutter_map: ^8.2.2\nlatlong2: ^0.9.1\n</code></pre> <p>We are goig to create a new screen called <code>MapScreen</code> that will display the user's location on a map. Create a new file named <code>map_screen.dart</code> and create a new StatefulWidget called <code>MapScreen</code>:</p> <pre><code>// map_screen.dart\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter_map/flutter_map.dart';\nimport 'package:latlong2/latlong.dart';\nimport 'package:provider/provider.dart';\n\nimport 'location_provider.dart';\n\n\nclass MapScreen extends StatefulWidget {\nconst MapScreen({super.key});\n\n@override\nState&lt;MapScreen&gt; createState() =&gt; _MapScreenState();\n}\n\nclass _MapScreenState extends State&lt;MapScreen&gt; {\nlate final MapController _mapController;\nfinal double _initialZoom = 14.0; // The bigger the value, the closer the zoom\n...\n}\n</code></pre> <p>Here we have defined a <code>MapController</code> to control the map and an initial zoom level.</p> <p>In the <code>MyApp</code> class, update the home property to use the <code>MapScreen</code> instead of the previous location screen:</p> <pre><code>// my_app.dart\n\nhome: MapScreen(),\n</code></pre> <p>Next, create the <code>initState()</code> method to initialize the <code>MapController</code>:</p> <pre><code>// map_screen.dart\n\n@override\nvoid initState() {\nsuper.initState();\n\nWidgetsBinding.instance.addPostFrameCallback((_) async { // Fetch location after the first frame\nfinal provider = Provider.of&lt;LocationProvider&gt;(context, listen: false);\nawait provider.fetchCurrentLocation();\n});\n_mapController = MapController();\n}\n</code></pre> <p>In this method, we also fetch the current location after the first frame is rendered (<code>WidgetsBinding.instance.addPostFrameCallback</code>) to ensure that we have a location to display on the map.</p> <p>Also, override the <code>dispose()</code> method to clean up resources:</p> <pre><code>// map_screen.dart\n\n@override\nvoid dispose() {\n_mapController.dispose();\nsuper.dispose();\n}\n</code></pre> <p>In this screen we want to fetch a location when the favorite button is pressed. So, we will create a method called <code>_fetchCurrentLocation()</code>:</p> <pre><code>// map_screen.dart\n\nFuture&lt;void&gt; _fetchCurrentLocation() async {\nfinal provider = Provider.of&lt;LocationProvider&gt;(context, listen: false);\nawait provider.fetchCurrentLocation();\nfinal pos = provider.currentPosition;\nif (pos != null) {\n_mapController.move(LatLng(pos.latitude, pos.longitude), _initialZoom);\n}\n}\n</code></pre> <p>This method fetches asynchronously the current location using the <code>LocationProvider</code> and moves the map to that location if it is available.</p> <p>In the <code>build</code> method, we will create the UI for the map screen: a Scaffold with an AppBar, a FlutterMap widget to display the map, and a FloatingActionButton to fetch the current location. We also add a Text widget in top-center to show the current latitude and longitude.</p> <pre><code>@override\nWidget build(BuildContext context) {\nvar locationService = Provider.of&lt;LocationProvider&gt;(context, listen: true);\nfinal pos = locationService.currentPosition;\n\nreturn Scaffold(\nappBar: AppBar(\ntitle: const Text('Map Location'),\ncenterTitle: true,\nbackgroundColor: Theme.of(context).colorScheme.primary,\n),\nfloatingActionButton: FloatingActionButton.extended(\nonPressed: _fetchCurrentLocation,\nlabel: Text('Get location'),\nicon: Icon(Icons.map),\n),\n// The main widget that renders the map\nbody: Column(\nchildren: [\nText(\npos != null\n? 'Latitude: ${pos.latitude} \\nLongitude: ${pos.longitude}'\n: 'No location yet.',\nstyle: TextStyle(fontSize: 16),\n),\nExpanded(\nchild: pos != null\n? FlutterMap(\nmapController: _mapController,\n// Map options, such as initial center and zoom\noptions: MapOptions(\ninitialCenter: LatLng(\npos!.latitude,\npos.longitude,\n), // Centered on user's location\ninitialZoom: _initialZoom,\n),\n// The map is built in layers\nchildren: [\n// Layer 1: The base map from OpenStreetMap\nTileLayer(\nurlTemplate:\n'https://tile.openstreetmap.org/{z}/{x}/{y}.png',\nuserAgentPackageName: 'com.example.flutter_map_example',\n),\n// Layer 2: Our pins (markers)\nMarkerLayer(\nmarkers: [\nMarker(\npoint: LatLng(pos.latitude, pos.longitude),\nchild: Icon(\nIcons.location_pin,\ncolor: Colors.red,\nsize: 40,\n),\n),\n],\n),\n],\n)\n: Center(\nchild: Column(\nchildren: [\nText('No location yet.'),\nCircularProgressIndicator(), //Shows a loading indicator while waiting for location\n],\n),\n),\n),\n],\n),\n);\n}\n</code></pre> <p>The widget that renders the map is <code>FlutterMap</code>, which takes a <code>MapOptions</code> object to configure the initial center and zoom level. The map is built in layers, with a <code>TileLayer</code> for the base map and a <code>MarkerLayer</code> for displaying markers.</p> <p>The Marker object is created using the current latitude and longitude from the <code>LocationProvider</code> and a red location pin icon.</p> <p>If the map is not yet available (i.e., no location has been fetched), we display a loading indicator.</p> <p>Launch the app and test with different locations using the Android Studio emulator's extended controls as described earlier.</p> <p></p> <p>Task</p> <p>Modify the <code>MapScreen</code> to include a button that starts/stops continuous location updates using the <code>startListening()</code> and <code>stopListening()</code> methods from the <code>LocationProvider</code>. The map must show the updated location as it changes.</p>"},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.4%20Mobile%20sensors/","title":"Unit 5.4. Mobile sensors with Flutter","text":""},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.4%20Mobile%20sensors/#overview","title":"Overview","text":"<p>Flutter provides access to various device sensors through plugins available on pub.dev. These plugins allow you to read data from sensors such as accelerometers, gyroscopes, magnetometers, and more.</p> <p>We are going to use the package <code>sensors_plus</code>, which provides a simple way to access sensor data in Flutter applications. The sensor available in this package include:</p> <ul> <li>Accelerometer: describes the acceleration of the device, in m/s<sup>2</sup>, including the effects of gravity. Unlike <code>UserAccelerometerEvent</code>, this stream reports raw data from the accelerometer without any post-processing. The accelerometer is unable to distinguish between the effect of an accelerated movement of the device and the effect of the surrounding gravitational field. This means that, at the surface of Earth, even if the device is completely still, the reading of AccelerometerEvent is an acceleration of intensity 9.8 directed upwards (the opposite of the graviational acceleration). This can be used to infer information about the position of the device (horizontal/vertical/tilted). AccelerometerEvent reports zero acceleration if the device is free falling.</li> <li>User Accelerometer: describes the acceleration of the device, in m/s<sup>2</sup>. If the device is still, or is moving along a straight line at constant speed, the reported acceleration is zero. If the device is moving e.g. towards north and its speed is increasing, the reported acceleration is towards north; if it is slowing down, the reported acceleration is towards south; if it is turning right, the reported acceleration is towards east. The data of this stream is obtained by filtering out the effect of gravity from <code>AccelerometerEvent</code>.</li> <li>Gyroscope: describes the rotation of the device.</li> <li>Magnetometer: describes the ambient magnetic field around the device. A compass is an example usage of this data.</li> <li>Barometer: describes the ambient air pressure around the device, in hPa. An altimeter is an example usage of this data. Not supported on web browsers.</li> </ul> <p>The page Flutter Gems has a list of sensor packages that you can explore for more options, like light, infrared, movement etc.</p>"},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.4%20Mobile%20sensors/#installing-sensor-packages","title":"Installing Sensor Packages","text":"<pre><code>flutter pub add sensors_plus\n</code></pre> <p>The <code>pubspec.yaml</code> file should now include the <code>sensors_plus</code> package under dependencies:</p> <pre><code>dependencies:\nflutter:\nsdk: flutter\nsensors_plus: ^7.0.0\n</code></pre> <p>On iOS you must also include a key called <code>NSMotionUsageDescription</code> in your app's <code>Info.plist</code> file. This key provides a message that tells the user why the app is requesting access to the device\u2019s motion data. The plugin itself needs access to motion data to get barometer data.</p> <p>Example <code>Info.plist</code> entry:</p> <pre><code>&lt;key&gt;NSMotionUsageDescription&lt;/key&gt;\n&lt;string&gt;This app requires access to the barometer to provide altitude information.&lt;/string&gt;\n</code></pre>"},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.4%20Mobile%20sensors/#using-sensors-in-flutter","title":"Using Sensors in Flutter","text":"<p>We are starting with a simple example that reads accelerometer data and displays it on the screen.</p> <p>First, setup the main function and MyApp class:</p> <pre><code>// main.dart\n\nimport 'package:flutter/material.dart';\nimport 'package:flutter_sensors/sensors_screen.dart';\n\nvoid main() {\nrunApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n@override\nWidget build(BuildContext context) {\nreturn MaterialApp(\ntheme: ThemeData(\ncolorScheme: ColorScheme.fromSeed(seedColor: Colors.grey),\n),\ndebugShowCheckedModeBanner: false,\nhome: SensorsScreen(),\n);\n}\n}\n</code></pre> <p>As seen in previous exercises, you can put the MyApp class in a separate file if you want.</p> <p>In the <code>sensors_screen.dart</code> file, we will create a stateful widget that listens to accelerometer events and updates the UI accordingly.</p> <pre><code>// sensors_screen.dart\n\nimport 'dart:async';\nimport 'package:flutter/material.dart';\nimport 'package:sensors_plus/sensors_plus.dart';\n\n\nclass SensorsScreen extends StatefulWidget {\nconst SensorsScreen({super.key});\n\n@override\nState&lt;SensorsScreen&gt; createState() =&gt; _SensorsScreenState();\n}\n\nclass _SensorsScreenState extends State&lt;SensorsScreen&gt; {\n...\n}\n</code></pre> <p>Inside the <code>_SensorsScreenState</code> class, we will define variables to hold the accelerometer data and a subscription to listen to accelerometer events.</p> <pre><code>// sensors_screen.dart \n\nclass _SensorsScreenState extends State&lt;SensorsScreen&gt; {\n// List to store accelerometer data\nList&lt;AccelerometerEvent&gt; _accelerometerValues = [];\n// StreamSubscription for accelerometer events\nlate StreamSubscription&lt;AccelerometerEvent&gt; _accelerometerSubscription;\n...\n</code></pre> <p>The values are stored in the <code>_accelerometerValues</code> list, and the subscription is stored in <code>_accelerometerSubscription</code>. This variable is declared as <code>late</code> because it will be initialized in the <code>initState</code> method.</p> <p>Next, we will initialize the subscription in the <code>initState</code> method to listen to accelerometer events:</p> <pre><code>@override\nvoid initState() {\nsuper.initState();\n\n_accelerometerSubscription = accelerometerEventStream().listen((event) {\nsetState(() {\n// Update the _accelerometerValues list with the latest event\n_accelerometerValues = [event];\n});\n});\n}\n</code></pre> <p>Note that we call <code>setState</code> to update the UI instead of using providers or other state management solutions for simplicity.</p> <p>When the screen is disposed of, we need to cancel the subscription to avoid memory leaks:</p> <pre><code>// sensors_screen.dart\n\n@override\nvoid dispose() {\n// Cancel the accelerometer event subscription to prevent memory leaks\n_accelerometerSubscription.cancel();\n\nsuper.dispose();\n}\n</code></pre> <p>Finally, we will build the UI to display the accelerometer data:</p> <pre><code>// sensors_screen.dart\n\n@override\nWidget build(BuildContext context) {\n//print (_accelerometerValues);\nreturn Scaffold(\nappBar: AppBar(\ntitle: Text('Sensors Example'),\nbackgroundColor: Theme.of(context).colorScheme.primary,\nforegroundColor: Theme.of(context).colorScheme.onPrimary,\n),\nbody: Center(\nchild: Column(\nmainAxisAlignment: MainAxisAlignment.center,\nchildren: &lt;Widget&gt;[\n// Accelerometer Data\nText(\n'Accelerometer Data:',\nstyle: TextStyle(fontSize: 20),\n),\nSizedBox(height: 10),\nif (_accelerometerValues.isNotEmpty)\nText(\n'X: ${_accelerometerValues[0].x.toStringAsFixed(2)}, '\n'Y: ${_accelerometerValues[0].y.toStringAsFixed(2)}, '\n'Z: ${_accelerometerValues[0].z.toStringAsFixed(2)}',\nstyle: TextStyle(fontSize: 16),\n)\nelse\nText('No data available', style: TextStyle(fontSize: 16)),          ],\n),\n),\n);\n}\n</code></pre> <p>This code builds a simple UI with an AppBar and a body that displays the accelerometer data. The data is formatted to two decimal places for better readability.</p> <p>If you are running this on the Andoid Studio emulator, you can simulate accelerometer data by using the \"Extended Controls\" menu (three dots icon) and navigating to the \"Sensors\" section. Here, you can adjust the accelerometer values to see how your app responds.</p> <p></p> <p>Task</p> <p>Complete the app to also display user accelerometer, gyroscope, magnetometer and barometer data. You will need to create additional subscriptions for these sensors, dispose them and update the UI accordingly.</p> <p></p>"},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.5%20Camera/","title":"Unit 5.5. Camera with Flutter","text":""},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.5%20Camera/#overview","title":"Overview","text":"<p>Flutter provides access to the device camera through plugins available on pub.dev. These plugins allow you to capture photos and videos, as well as access camera streams.</p> <p>This section demonstrates how to use the camera plugin to display a preview, take a photo, and display it using the following steps:</p> <ol> <li>Add the required dependencies.</li> <li>Get a list of the available cameras.</li> <li>Create and initialize the CameraController.</li> <li>Use a CameraPreview to display the camera's feed.</li> <li>Take a picture with the CameraController.</li> <li>Display the picture with an Image widget.</li> </ol> <p>We are going to use the package <code>camera</code>, which provides a simple way to access the camera in Flutter applications. This package allows you to: - Display a live camera preview. - Capture photos and videos. - Control camera settings such as flash, zoom, and focus. - Access multiple cameras (front and back).</p>"},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.5%20Camera/#adding-dependencies","title":"Adding dependencies","text":"<p>Add the <code>camera</code> package to your <code>pubspec.yaml</code> file:</p> <pre><code>flutter pub add camera\n</code></pre> <p>Additionally, you may want to include the <code>path_provider</code> and <code>path</code> packages to help with saving captured images:</p> <pre><code>flutter pub add path_provider\nflutter pub add path\n</code></pre> <p><code>path_provider</code> helps you find the correct paths to store files on the device, while <code>path</code> provides utilities for manipulating file paths.</p> <p>For android, You must update minSdkVersion to 21 (or higher).</p> <pre><code>android {\n    ...\n    defaultConfig {\n        ...\n        minSdkVersion 21\n        ...\n    }\n    ...\n}\n</code></pre> <p>On iOS, the following lines must be added inside <code>ios/Runner/Info.plist</code> to the access the camera and microphone.</p> <pre><code>&lt;key&gt;NSCameraUsageDescription&lt;/key&gt;\n&lt;string&gt;Explanation on why the camera access is needed.&lt;/string&gt;\n&lt;key&gt;NSMicrophoneUsageDescription&lt;/key&gt;\n&lt;string&gt;Explanation on why the microphone access is needed.&lt;/string&gt;\n</code></pre>"},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.5%20Camera/#project-structure","title":"Project structure","text":"<p>The project will have the following structure:</p> <ul> <li><code>main.dart</code>: Entry point of the application.</li> <li><code>my_app.dart</code>: Contains the MyApp class that sets up the MaterialApp and loads the a Future to get the available cameras.</li> <li><code>take_picture_screen.dart</code>: Screen to take a picture using the camera.</li> <li><code>display_picture_screen.dart</code>: Screen to display the captured picture.</li> </ul> <p>The <code>main.dart</code> file will look like this:</p> <pre><code>// main.dart\n\nimport 'package:camera/camera.dart';\nimport 'package:flutter/material.dart';\n\nimport 'my_app.dart';\n\nvoid main() {\nfinal Future&lt;List&lt;CameraDescription&gt;&gt; camerasFuture = availableCameras(); // Fetch the available cameras before running the app\nrunApp(MyApp(camerasFuture: camerasFuture)); // Pass the Future&lt;List&lt;CameraDescription&gt;&gt; to MyApp\n}\n</code></pre> <p>As the available cameras are fetched asynchronously, we pass a <code>Future&lt;List&lt;CameraDescription&gt;&gt;</code> to the MyApp class.</p>"},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.5%20Camera/#getting-available-cameras","title":"Getting available cameras","text":"<p>In the <code>my_app.dart</code> file, we will set up the MaterialApp and load the available cameras using a FutureBuilder.</p> <p>The fisrt thing is to create a stateful widget that takes a <code>Future&lt;List&lt;CameraDescription&gt;&gt;</code> as a parameter:</p> <pre><code>// my_app.dart\n\nimport 'package:camera/camera.dart';\nimport 'package:camera_flutter/take_picture_screen.dart';\nimport 'package:flutter/material.dart';\n\nclass MyApp extends StatefulWidget {\nfinal Future&lt;List&lt;CameraDescription&gt;&gt; camerasFuture; // Declare a Future&lt;List&lt;CameraDescription&gt;&gt; to hold the available cameras\nconst MyApp({super.key, required this.camerasFuture}); // Accept a Future&lt;List&lt;CameraDescription&gt;&gt; in the constructor\n\n@override\nState&lt;MyApp&gt; createState() =&gt; _MyAppState();\n}\n</code></pre> <p>Then, in the state class, we will use a FutureBuilder to wait for the cameras to be available before building the MaterialApp. The line <code>future: widget.camerasFuture</code> returns a snapshot that contains the state of the Future. It can be in one of the following states: <code>ConnectionState.waiting</code>, <code>ConnectionState.done</code>, <code>ConnectionState.active</code>, or <code>ConnectionState.none</code>. Once we get the snapshot, we can check if it has errors (<code>snapshot.hasError</code>) or if it has data (<code>snapshot.hasData</code>) and if the data is empty or not (<code>snapshot.data!.isEmpty</code>).</p> <p>The body content depends on the snapshot state of the Future. If the snapshot has data and it is not empty, we proceed get the first camera from the list and navigate to the TakePictureScreen, passing the camera as a parameter:</p> <pre><code>// my_app.dart\n\nclass _MyAppState extends State&lt;MyApp&gt; {\n@override\nWidget build(BuildContext context) {\nreturn MaterialApp(\ntitle: 'Material App',\ntheme: ThemeData( colorScheme: ColorScheme.fromSeed(seedColor: Colors.black)),\nhome: FutureBuilder&lt;List&lt;CameraDescription&gt;&gt;( // Fetch the available cameras using the FutureBuilder\nfuture: widget.camerasFuture, // Use the passed Future&lt;List&lt;CameraDescription&gt;&gt;\nbuilder: (context, snapshot) { // Build the UI based on the snapshot state. Snapshot is an AsyncSnapshot&lt;List&lt;CameraDescription&gt;&gt; that contains the state of the Future\n// If the Future is still loading, show a loading indicator\nif (snapshot.connectionState == ConnectionState.waiting) {\nreturn const Scaffold(\nbody: Center(child: CircularProgressIndicator()),\n);\n// If the Future has completed with an error, show the error message\n} else if (snapshot.hasError) {\nreturn Scaffold(\nbody: Center(child: Text('Error: ${snapshot.error}')),\n);\n// If the Future has completed successfully and has data, show the TakePictureScreen with the first available camera\n} else if (snapshot.hasData &amp;&amp; snapshot.data!.isNotEmpty) {\nfinal firstCamera = snapshot.data!.first;\nreturn TakePictureScreen(camera: firstCamera);\n// If the Future has completed successfully but has no data, show a message indicating no cameras were found\n} else {\nreturn const Scaffold(\nbody: Center(child: Text('No cameras found')),\n);\n}\n},\n),\n);\n}\n}\n</code></pre>"},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.5%20Camera/#taking-pictures","title":"Taking pictures","text":"<p>Once we have a camera, we need to create a CameraController to control the camera and display a preview. We will create a new screen called <code>TakePictureScreen</code> that takes a <code>CameraDescription</code> as a parameter. This widget must be a stateful widget because we need to initialize and dispose the CameraController asynchronously.</p> <p>In the stateful widget class, we get the camer from the MyApp widget:</p> <pre><code>// take_picture_screen.dart\n\nimport 'package:camera/camera.dart';\nimport 'package:flutter/foundation.dart';\nimport 'package:flutter/material.dart';\n\nimport 'display_picture_screen.dart';\n\n// A screen that allows users to take a picture using a given camera.\nclass TakePictureScreen extends StatefulWidget {\nconst TakePictureScreen({super.key, required this.camera});\nfinal CameraDescription camera;\n\n@override\nTakePictureScreenState createState() =&gt; TakePictureScreenState();\n}\n</code></pre> <p>Then, in the state class, we create a CameraController and initialize it in the <code>initState</code> method. We also need to dispose of the controller in the <code>dispose</code> method to free up resources when the widget is removed from the widget tree.</p> <pre><code>// take_picture_screen.dart\n\nclass TakePictureScreenState extends State&lt;TakePictureScreen&gt; {\nlate CameraController _controller;\nlate Future&lt;void&gt; _initializeControllerFuture;\n\n@override\nvoid initState() {\nsuper.initState();\n// To display the current output from the Camera,\n// create a CameraController.\n_controller = CameraController(\n// Get a specific camera from the list of available cameras.\nwidget.camera,\n// Define the resolution to use.\nResolutionPreset.medium,\n);\n\n// Next, initialize the controller. This returns a Future.\n_initializeControllerFuture = _controller.initialize();\n}\n\n@override\nvoid dispose() {\n// Dispose of the controller when the widget is disposed.\n_controller.dispose();\nsuper.dispose();\n}\n\n...\n}\n</code></pre> <p>The <code>_initializeControllerFuture</code> variable holds the Future returned by the <code>initialize</code> method, which we will use later to display a loading indicator while the camera is being initialized.</p> <p>In the <code>build</code> method, we will use a FutureBuilder to wait for the camera to be initialized before displaying the CameraPreview. We will also add a FloatingActionButton to take a picture when pressed.</p> <pre><code>// take_picture_screen.dart\n\n@override\nWidget build(BuildContext context) {\nreturn Scaffold(\nappBar: AppBar(\ntitle: const Text('Take a picture'),\nbackgroundColor: Theme.of(context).colorScheme.primary,\n),\n// You must wait until the controller is initialized before displaying the\n// camera preview. Use a FutureBuilder to display a loading spinner until the\n// controller has finished initializing.\nbody: FutureBuilder&lt;void&gt;(\nfuture: _initializeControllerFuture,\nbuilder: (context, snapshot) {\nif (snapshot.connectionState == ConnectionState.done) {\n// If the Future is complete, display the preview.\nreturn CameraPreview(_controller);\n} else {\n// Otherwise, display a loading indicator.\nreturn const Center(child: CircularProgressIndicator());\n}\n},\n),\nfloatingActionButton: FloatingActionButton(\n// Provide an onPressed callback.\nonPressed: () async {\n// Take the Picture in a try / catch block. If anything goes wrong, catch the error.\ntry {\n// Ensure that the camera is initialized.\nawait _initializeControllerFuture;\n\n// Attempt to take a picture and get the file `image` where it was saved.\nfinal image = await _controller.takePicture();\n\nif (!context.mounted) return;\n\n// If the picture was taken, display it on a new screen.\nawait Navigator.of(context).push(\nMaterialPageRoute&lt;void&gt;(\nbuilder: (context) =&gt; DisplayPictureScreen(\n// Pass the automatically generated path to the DisplayPictureScreen widget.\nimagePath: image.path,\n),\n),\n);\n} catch (e) {\n// If an error occurs, log the error to the console.\nif (kDebugMode) { // Only print in debug mode\nprint(e);\n}\n}\n},\nchild: const Icon(Icons.camera_alt),\n),\n);\n}\n</code></pre> <p>The line  <code>final image = await _controller.takePicture();</code> captures a picture and returns a <code>XFile</code> object that contains the path to the saved image. Then, we navigate to the <code>DisplayPictureScreen</code>, passing the image path as a parameter.</p>"},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.5%20Camera/#displaying-pictures","title":"Displaying pictures","text":"<p>We will create a new screen called <code>DisplayPictureScreen</code> that takes the image path as a String parameter and displays the image using an <code>Image</code> widget. We also show a text with the image path.</p> <p>This can be a stateless widget since we only need to display the image.</p> <pre><code>import 'dart:io';\n\nimport 'package:flutter/material.dart';\n\n// A widget that displays the picture taken by the user.\nclass DisplayPictureScreen extends StatelessWidget {\nfinal String imagePath;\n\nconst DisplayPictureScreen({super.key, required this.imagePath});\n\n@override\nWidget build(BuildContext context) {\nreturn Scaffold(\nappBar: AppBar(\ntitle: const Text('Display the Picture'),\nbackgroundColor: Theme.of(context).colorScheme.primary,\n),\n// The image is stored as a file on the device. Use the `Image.file`\n// constructor with the given path to display the image.\nbody: Column(\nchildren: [\nText(imagePath),\nExpanded(child: Image.file(File(imagePath))),\n],\n),\n);\n}\n}\n</code></pre> <p>Run the app. The first time it should ask you for camera permissions.</p> <p></p> <p>Once granted, you should see the camera preview.</p> <p></p> <p>Press the camera button to take a picture, and it will navigate to the display screen showing the captured image.</p> <p></p> <p>As you can see, the picture is sotred in a cache directory inside the app data folder. We will work later on how to save the picture in a more permanent location.</p>"},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.5%20Camera/#references","title":"References","text":"<ul> <li>camera package</li> <li>Flutter Camera Documentation</li> </ul>"},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.6%20Files%20storage/","title":"Unit 5.6. Files storage with Flutter","text":"<p>Android apps store data (files, settings) within their own private areas (app-specific storage, Shared Preferences, databases), not usually in a user-visible \"apps folder\". </p> <p>Developers use app-specific storage (internal/external) for app data, Shared Preferences for small data (like settings), and Databases for structured data, with newer Android versions restricting external app access for privacy.</p> <ul> <li>App-Specific Storage:<ul> <li>Internal: For sensitive data, private to the app.</li> <li>External: For larger files, also private to the app on modern Android.</li> </ul> </li> <li>Shared Preferences: For small key-value pairs (booleans, ints, strings) like user settings. For Flutter, the package <code>shared_preferences</code> is commonly used.</li> <li>Databases: For structured data using libraries like Room (e.g., SQLite). Flutter uses packages like <code>sqflite</code> and <code>floor</code> for SQLite databases .</li> <li>Shared Storage: For files intended to be shared (media, documents), requiring permissions and using APIs like MediaStore or Storage Access Framework (SAF).</li> </ul>"},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.6%20Files%20storage/#saving-pictures-in-the-gallery","title":"Saving pictures in the gallery","text":"<p>To save pictures in the gallery, we can use the package <code>gallery_saver_plus</code> that provides simple methods to save images and videos to the device's gallery.</p> <p>Add the de pendency to your <code>pubspec.yaml</code> file:</p> <pre><code>flutter pub add gallery_saver_plus\n</code></pre> <p>For Android 10 (API level 29) and below, add this permission to your <code>android/app/src/main/AndroidManifest.xml</code>:</p> <pre><code>&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /&gt;\n</code></pre> <p>For iOS, add the following keys to your <code>ios/Runner/Info.plist</code> file to request permission to access the photo library:</p> <pre><code>&lt;key&gt;NSPhotoLibraryUsageDescription&lt;/key&gt;\n&lt;string&gt;This app needs access to photo library to save images and videos&lt;/string&gt;\n</code></pre> <p>To save an image to the gallery, we simply call the <code>GallerySaver.saveImage</code> method with the file path of the image:</p> <pre><code>final success = await GallerySaver.saveImage('/path/to/local/image.jpg');\n</code></pre> <p>We will add a Floating Action Button to our DisplayPictureScreen that saves the displayed picture to the gallery when pressed:</p> <pre><code>// display_picture_screen.dart\n\nimport 'package:gallery_saver_plus/gallery_saver.dart';\n\n@override\nWidget build(BuildContext context) {\nreturn Scaffold(\n// Previous code...\nfloatingActionButton: FloatingActionButton.extended(\nonPressed: () async {\ntry {\n// Save image to gallery\nfinal bool? success = await GallerySaver.saveImage(imagePath);\n// Show a snackbar with the result\nfinal message = (success == true)\n? 'Image saved to gallery'\n: 'Failed to save image';\nif (context.mounted) { // Check if context is still valid\nScaffoldMessenger.of(\ncontext,\n).showSnackBar(SnackBar(content: Text(message)));\n}\n} catch (e) {\n// Show error snackbar\nif (context.mounted) {\nScaffoldMessenger.of(\ncontext,\n).showSnackBar(SnackBar(content: Text('Error saving image: $e')));\n}\n}\nif(context.mounted) Navigator.of(context).pop();\n},\nlabel: Text(\"Save to gallery\"),\nicon: const Icon(Icons.save_alt),\n),\n);\n}\n</code></pre> <p>We are calling an asynchronous method to save the image and showing a snackbar with the result. The <code>context.mounted</code> check ensures that the widget is still in the widget tree before showing the snackbar or navigating back.</p>"},{"location":"U05%20Multiplatform%20development%20with%20Flutter/U05.6%20Files%20storage/#save-the-image-in-the-internal-app-directory","title":"Save the image in the internal app directory","text":"<p>To save the image in the internal app directory, we can use the <code>path_provider</code> package to get the correct directory path.</p> <p>Then, we can get the internal app directory and save the image there:</p> <pre><code>import 'package:path_provider/path_provider.dart';\nimport 'dart:io';\n\nFuture&lt;String&gt; saveImageToInternalDirectory(File imageFile) async {\n// Create  the folder images if not exists\nfinal directory = await getApplicationDocumentsDirectory();\nfinal String imagesPath = '${directory.path}/images';\nfinal imagesDirectory = Directory(imagesPath);\nif (!await imagesDirectory.exists()) {\nawait imagesDirectory.create(recursive: true);\n}\n// Get the internal app directory\nfinal String path = imagesDirectory.path;\n\n// Create a new file in the internal directory\nfinal String fileName = imageFile.path.split('/').last;\nfinal File newImage = await imageFile.copy('$path/$fileName');\n\nreturn newImage.path; // Return the new file path\n}\n</code></pre> <p>This method creates an <code>images</code> folder in the app's internal documents directory (if it doesn't already exist) and copies the image file there. It returns the new file path.</p> <p>Then, call this function from the Floating Action Button's <code>onPressed</code> method instead of saving to the gallery:</p> <pre><code>onPressed: () async {\ntry {\n// Save image to internal app directory\nfinal String newPath = await saveImageToInternalDirectory(File(imagePath));\n// Show a snackbar with the result\nif (context.mounted) {\nScaffoldMessenger.of(\ncontext,\n).showSnackBar(SnackBar(content: Text('Image saved to $newPath')));\n}\n} catch (e) {\n// Show error snackbar\nif (context.mounted) {\nScaffoldMessenger.of(\ncontext,\n).showSnackBar(SnackBar(content: Text('Error saving image: $e')));\n}\n}\nif(context.mounted) Navigator.of(context).pop();\n},\n</code></pre> <p>The image will be saved in the app's internal storage under the <code>images</code> folder. Check the snackbar message to see the path where the image was saved.</p> <p></p> <p>Check the app's internal storage to see the saved image. You can use Android Studio's Device File Explorer or similar tools for other platforms.</p>"},{"location":"U06%20Connectivity%20and%20remote%20applications/U06.1%20Introduction%20to%20Firebase%20and%20Firestore/","title":"Unit 6.1 Introduction to Firebase and Firestore","text":""},{"location":"U06%20Connectivity%20and%20remote%20applications/U06.1%20Introduction%20to%20Firebase%20and%20Firestore/#firebase-overview","title":"Firebase Overview","text":"<p>Firebase is a platform developed by Google for creating mobile and web applications. It provides a variety of tools and services to help developers build high-quality apps, including real-time databases, authentication, cloud storage, and hosting.</p> <p>Classified as BaaS (Backend as a Service), Firebase allows developers to focus on building the front end of their applications while leveraging Firebase's backend infrastructure.</p> <p>Some of the key features of Firebase include:</p> <ul> <li>Authentication: A service that provides easy-to-use authentication methods, including email/password, social media logins, and more.</li> <li>Cloud Firestore: A flexible, scalable database for mobile, web, and server development.</li> <li>Cloud Storage: A service for storing and serving user-generated content, such as photos and videos.</li> <li>Hosting: A web hosting service for deploying web apps and static content.</li> <li>Cloud Functions: A serverless framework that allows developers to run backend code in response to events triggered by Firebase features and HTTPS requests.</li> <li>Analytics: A free app measurement solution that provides insights on app usage and user engagement.</li> <li>Crashlytics: A real-time crash reporting tool that helps developers track, prioritize, and fix stability issues.</li> <li>Performance Monitoring: A service that helps developers gain insight into the performance characteristics of their apps.</li> </ul> <p>Firebase documentation</p>"},{"location":"U06%20Connectivity%20and%20remote%20applications/U06.1%20Introduction%20to%20Firebase%20and%20Firestore/#cloud-firestore","title":"Cloud Firestore","text":"<p>Cloud Firestore is a NoSQL document database built for automatic scaling, high performance, and ease of application development. It is one of the primary database services offered by Firebase.</p> <p>Realtime Database vs. Cloud Firestore</p> <p>Cloud Firestore is different from the Firebase Realtime Database, which is another database service provided by Firebase. While both databases are NoSQL and designed for real-time data synchronization, they have different data models, querying capabilities, and scalability options. Realtime Database is suitable for applications with simple data models requiring simple lookups and low-latency synchronization with limited scalability.</p>"},{"location":"U06%20Connectivity%20and%20remote%20applications/U06.1%20Introduction%20to%20Firebase%20and%20Firestore/#firestore-data-model","title":"Firestore data model","text":"<p>Cloud Firestore stores data in documents, which are organized into collections. A database contains collections, which contain documents, which can contain subcollections and nested objects.</p> <p>Roughly comparing the Firestore data model with a traditional relational database model:</p> Relational model Firestore Database Database Table Collection Record / Row Document Attributes / Columns Document Keys <p>Each document contains a set of key-value pairs, where the keys are strings and the values can be various data types, including strings, numbers, booleans, arrays, maps, and timestamps.</p> <p>Each document is identified by a unique ID within its collection. The names of documents within a collection are unique. You can provide your own keys, such as user IDs, or you can let Cloud Firestore create random IDs for you automatically.</p> <p>An example of a Firestore document representing a user:</p> <pre><code>userID123 \n    |-- name: \"John Doe\"\n    |-- email: \"johndoe@mail.com\"\n    |-- age: 30\n    |-- isActive: true\n</code></pre> <p>A document can have nested objects, called maps. For example:</p> <pre><code>userID123 \n    |-- name:\n        |-- first: \"John\"\n        |-- last: \"Doe\"\n    |-- email: \"johndoe@mail.com\"\n    |-- age: 30\n    |-- isActive: true\n</code></pre> <p>Firestore and JSON</p> <p>The Firestore data model is similar to JSON . Both use key-value pairs and support nested structures. There are some differences (for example, documents support extra data types and are limited in size to 1 MB), but in general, you can treat documents as lightweight JSON records.</p>"},{"location":"U06%20Connectivity%20and%20remote%20applications/U06.1%20Introduction%20to%20Firebase%20and%20Firestore/#collections","title":"Collections","text":"<p>A collection is a group of documents. Collections do not store actual data; they are simply containers for documents. Each document within a collection must have a unique ID.</p> <p>For example, a collection named \"users\" might contain multiple documents, each representing a different user:</p> <pre><code>users (collection)\n    |-- userID123 (document):\n        |-- name: \"John Doe\"\n        |-- email: \"johndoe@mail.com\"\n    |-- userID456 (document):\n        |-- name: \"Jane Smith\"\n        |-- email: \"janesmith@mail.com\"\n        |-- age: 25\n    |-- userID789 (document):\n        |-- name: \"Alice Johnson\"\n        |-- phone: \"555-1234\"\n</code></pre> <p>Firestore is schemaless, meaning that documents within the same collection can have different fields and data types. This flexibility allows developers to evolve their data models over time without requiring complex migrations. However, it's a good idea to use the same fields and data types across multiple documents, so that you can query the documents more easily.</p> <p>A collection contains documents and nothing else. It can't directly contain raw fields with values, and it can't contain other collections. </p> <p>You do not need to \"create\" or \"delete\" collections. After you create the first document in a collection, the collection exists. If you delete all of the documents in a collection, it no longer exists.</p> <p>In Flutter, you can reference a collection using the <code>collection</code> method of the <code>FirebaseFirestore</code> instance:</p> <pre><code>final usersCollectionRef = db.collection(\"users\");\n</code></pre> <p>You also can reference a specific document within a collection using the <code>doc</code> method:</p> <pre><code>final userDocRef = db.collection(\"users\").doc(\"userID123\");\n</code></pre> <p>Or <pre><code>final userDocRef = usersCollectionRef.doc(\"userID123\");\n</code></pre></p>"},{"location":"U06%20Connectivity%20and%20remote%20applications/U06.1%20Introduction%20to%20Firebase%20and%20Firestore/#subcollections","title":"Subcollections","text":"<p>A subcollection is a collection that exists within a document. Subcollections allow you to create hierarchical data structures in Firestore. For example, you might have a \"posts\" subcollection within each user document to store the posts created by that user:</p> <pre><code>users (collection)\n    |-- userID123 (document):\n        |-- name: \"John Doe\"\n        |-- email: \"johndoe@mail.com\"\n        |-- posts (subcollection):\n            |-- postID1 (document):\n                |-- title: \"My first post\"\n                |-- content: \"Hello, world!\"\n            |-- postID2 (document):\n                |-- title: \"Another post\"\n                |-- content: \"This is another post.\"\n    |-- userID456 (document):\n        |-- name: \"Jane Smith\"\n        |-- email: \"janesmith@mail.com\"\n        |-- posts (subcollection):\n            |-- postID3 (document):\n                |-- title: \"Jane's post\"\n                |-- content: \"This is Jane's post.\"\n</code></pre> <p>To get a reference to an specific post (subcollection) in Flutter, you can chain the <code>collection</code> method after referencing the parent document:</p> <pre><code>final postDocRef = db\n.collection(\"users\")\n.doc(\"userID123\")\n.collection(\"posts\")\n.doc(\"postID1\");\n</code></pre> <p>Notice the alternating pattern of collections and documents. Your collections and documents must always follow this pattern. You cannot reference a collection in a collection or a document in a document.</p> <p>Documents in subcollections can contain subcollections as well, allowing you to further nest data. You can nest data up to 100 levels deep.</p> <p>Deleting a document does not delete its subcollections!</p> <p>When you delete a document, any subcollections within that document are not deleted automatically. You must delete subcollections and their documents separately if needed.</p> <p>Firestore data model documentation</p>"},{"location":"U06%20Connectivity%20and%20remote%20applications/U06.1%20Introduction%20to%20Firebase%20and%20Firestore/#data-types","title":"Data types","text":"<p>The supported data types in Firestore documents are shown in the next table:</p> Data Type Description Sort order Type String Textual data UTF-8 encoded byte order Integer 64-bit, signed integer values Numeric order Floating Point Number 64-bit, IEEE-754 floating point values Numeric order Boolean true or false values false &lt; true Date and Time Timestamps with millisecond precision Chronological order Null Represents a null value None Array An ordered list of values By element values Map A nested object containing key-value pairs By keys first, then by values Geographical Point A latitude/longitude pair By latitude, then by longitude Bytes Binary data By byte values Reference A reference to another document By path <p>An array cannot contain another array as an element.</p> <p>When a query involves a field with values of mixed types, Cloud Firestore uses a deterministic ordering based on the internal representations. The following list shows the order:</p> <ol> <li>Null values</li> <li>Boolean values</li> <li>Integer and floating-point values, sorted in numerical order</li> <li>Date values</li> <li>Text string values</li> <li>Byte values</li> <li>Cloud Firestore references</li> <li>Geographical point values</li> <li>Array values</li> <li>Vector embeddings</li> <li>Map values</li> </ol> <p>Firestore data types documentation</p>"},{"location":"U06%20Connectivity%20and%20remote%20applications/U06.2%20Using%20Firestore/","title":"Unit 6.2 Using Firestore","text":"<p>To show how to use Firestore in a Flutter application, we are going to create a simple TODO list app that allows users to add, view, update, and delete TODO items stored in a Firestore database.</p>"},{"location":"U06%20Connectivity%20and%20remote%20applications/U06.2%20Using%20Firestore/#setting-up-firebase-for-flutter","title":"Setting up Firebase for Flutter","text":"<p>To use Firebase in your Flutter app, you need to set up a Firebase project and configure your Flutter app to connect to it. Follow these steps to get started:</p>"},{"location":"U06%20Connectivity%20and%20remote%20applications/U06.2%20Using%20Firestore/#create-a-firebase-account","title":"Create a Firebase Account","text":"<p>To get started with Firebase, you'll need to create a Firebase account. Follow these steps:</p> <ol> <li>Go to the Firebase website.</li> <li>Click on the \"Get Started\" button.</li> <li>Sign in with your Google account. If you don't have a Google account, you'll need to create one.</li> <li>Once signed in, you'll be directed to the Firebase console where you can create and manage your Firebase projects.</li> </ol>"},{"location":"U06%20Connectivity%20and%20remote%20applications/U06.2%20Using%20Firestore/#install-firebase-cli","title":"Install Firebase CLI","text":"<p>The Firebase CLI (Command Line Interface) is a tool that allows you to interact with Firebase services from your terminal.</p> <p>Installing the Firebase CLI depends on your operating system and if you want to install it via npm or other methods. The most common way is via npm.</p> <p>Follow the instructions from the official Firebase documentation to install the Firebase CLI on your system: Install the Firebase CLI</p> <p>Once installed, you can verify the installation logging to your Firebase account by running the following command in your terminal:</p> <pre><code>firebase login\n</code></pre> <p>This will open a browser window where you can sign in with your Google account. After signing in, you can return to the terminal to continue using the Firebase CLI. You can test that you are logged in by running:</p> <pre><code>firebase projects:list\n</code></pre> <p>This command will list all the Firebase projects associated with your account.</p>"},{"location":"U06%20Connectivity%20and%20remote%20applications/U06.2%20Using%20Firestore/#create-the-base-app","title":"Create the base app","text":"<p>The app we are going to do is a simple TODO list Flutter App. You can download the base project with the basic UI done from this link.</p> <p>After downloading the project, perform a <code>flutter pub get</code> to install the required dependencies.</p>"},{"location":"U06%20Connectivity%20and%20remote%20applications/U06.2%20Using%20Firestore/#create-a-firebase-project","title":"Create a Firebase Project","text":"<p>To create a new Firebase project, follow these steps:</p> <ol> <li>Go to the Firebase Console.</li> <li>Click on the \"Add project\" button.    </li> <li>Enter a name for your project and click \"Continue\".</li> <li>(Optional) Enable Gemini AI features for your project and click \"Continue\".</li> <li>(Optional) Enable Google Analytics for your project and configure the settings as desired.</li> </ol> <p>You will see a dashboard for your new project, where you can access various Firebase services and features.</p>"},{"location":"U06%20Connectivity%20and%20remote%20applications/U06.2%20Using%20Firestore/#add-firestore-to-your-project","title":"Add Firestore to Your Project","text":"<p>To add Firestore to your Firebase project, follow these steps:</p>"},{"location":"U06%20Connectivity%20and%20remote%20applications/U06.2%20Using%20Firestore/#step-1-create-a-firestore-database","title":"Step 1: Create a Firestore Database","text":"<ol> <li>In the Firebase Console, navigate to your project.</li> <li>In the left-hand menu, click on Build -&gt; Firestore Database.</li> <li>(Recommended) Open the documentation on the How do I get started? View the docs link.</li> <li>Click on the \"Create database\" button.</li> <li>Select the Standard edition and click \"Next\".    </li> <li>Choose a location (for example Europe) for your Firestore database and click \"Next\".    </li> <li>Select Start in test mode and click \"Enable\". This will allow you to read and write to the database for the next 30 days without any security rules.     <p>Warning: Make sure to set up proper security rules before deploying your application to production.</p> </li> </ol>"},{"location":"U06%20Connectivity%20and%20remote%20applications/U06.2%20Using%20Firestore/#step-2-install-the-required-command-line-tools","title":"Step 2: Install the required command line tools","text":"<p>The next step is to add Firebase to your app project.</p> <p>If you're logged in to the Firebase console, install the FlutterFire CLI by running the following command from any directory:</p> <pre><code>dart pub global activate flutterfire_cli\n</code></pre>"},{"location":"U06%20Connectivity%20and%20remote%20applications/U06.2%20Using%20Firestore/#step-3-configure-your-flutter-app-to-use-firebase","title":"Step 3: Configure your Flutter app to use Firebase","text":"<p>Then, from your Flutter project directory, run the following command to start the app configuration workflow:</p> <pre><code>flutterfire configure\n</code></pre> <ol> <li>The CLI will prompt you to select the Firebase project you created earlier.</li> <li>Then, select the platforms you want to configure (iOS, Android, Web, etc.).</li> <li>Confirm the configuration, and the CLI will generate the necessary configuration files for your Flutter app. It will create a <code>firebase_options.dart</code> file in your <code>lib</code> directory. This file contains the Firebase configuration for your app.</li> </ol> <p>Important</p> <p>After this initial running of <code>flutterfire configure</code>, you need to re-run the command any time that you:</p> <ul> <li>Start supporting a new platform in your Flutter app.</li> <li>Start using a new Firebase service or product in your Flutter app, especially if you start using sign-in with Google, Crashlytics, Performance Monitoring, or Realtime Database.</li> </ul> <p>Re-running the command ensures that your Flutter app's Firebase configuration is up-to-date and (for Android) automatically adds any required Gradle plugins to your app.</p>"},{"location":"U06%20Connectivity%20and%20remote%20applications/U06.2%20Using%20Firestore/#step-4-initialize-firebase-in-your-flutter-app","title":"Step 4: Initialize Firebase in your Flutter app","text":"<p>The next step is to initialize Firebase in your Flutter app.</p> <ol> <li>From your Flutter project directory, run the following command to install the core plugin:  <pre><code>flutter pub add firebase_core\n</code></pre></li> <li>From your Flutter project directory, run the following command to ensure that your Flutter app's Firebase configuration is up-to-date:  <pre><code>flutterfire configure\n</code></pre></li> <li>In your <code>lib/main.dart</code> file, import the Firebase core plugin and the configuration file you generated earlier:  <pre><code>import 'package:firebase_core/firebase_core.dart';\nimport 'firebase_options.dart';\n</code></pre></li> <li>Initialize Firebase in the <code>main</code> function before running the app:  <pre><code>Future&lt;void&gt; main() async {\nWidgetsFlutterBinding.ensureInitialized(); // Ensure Flutter bindings are initialized\nawait Firebase.initializeApp(\noptions: DefaultFirebaseOptions\n.currentPlatform, // Initialize Firebase with platform-specific options\n);\nrunApp(const MyApp());\n}\n</code></pre></li> <li>Rebuild your Flutter application:  <pre><code>flutter run\n</code></pre></li> </ol> <p>If the app runs without errors, Firebase has been successfully initialized in your Flutter app.</p>"},{"location":"U06%20Connectivity%20and%20remote%20applications/U06.2%20Using%20Firestore/#step-5-add-firebase-plugins","title":"Step 5: Add Firebase plugins","text":"<p>Firebase is based on a modular architecture, so you need to add the plugins for the Firebase services you want to use in your app. To use Firestore in your Flutter app, you'll need to add the Firestore plugin.</p> <p>From your Flutter project directory, run the following command to install the Firestore plugin:</p> <pre><code>flutter pub add cloud_firestore\n</code></pre> <ul> <li>The complete guide to setting up Firebase with Flutter</li> </ul> <p>Warning</p> <p>Firebase on Windows is not intended for production use cases, only local development workflows.</p> <p>If the app runs without errors, Firestore has been successfully initialized in your Flutter app.</p> <p>If you go to your Firebase Console, you should see that your app is connected to your Firebase project.</p> <p></p>"},{"location":"U06%20Connectivity%20and%20remote%20applications/U06.2%20Using%20Firestore/#create-the-data-model","title":"Create the Data Model","text":"<p>The data model for our TODO list app is simple. Each TODO item will have the following fields:</p> <ul> <li><code>id</code>: String. A unique identifier for the TODO item.</li> <li><code>title</code>: String. The title of the TODO item.</li> <li><code>description</code>: String. A description of the TODO item.</li> <li><code>isCompleted</code>: bool. A boolean indicating whether the TODO item is completed. The basic data model class in Dart would look like this:</li> </ul> <pre><code>// data/todo.dart\n\nclass Todo {\nfinal String? id;\nfinal String title;\nString? description;\nbool isCompleted;\n\nTodo({\nthis.id,\nrequired this.title,\nthis.description,\nthis.isCompleted = false,\n});\n\n}\n</code></pre> <p>We also need to add methods to convert the TODO item to and from a map.</p> <pre><code>// data/todo.dart\n\n// Convert a todo object into a Map object\nMap&lt;String, dynamic&gt; toMap() {\nreturn {\n'title': title,\n'description': description,\n'isCompleted': isCompleted,\n};\n}\n\n// Create a todo object from a Map object\n// Useful when retrieving data from Firestore and general APIs\n// Note: This method does not get the document id\nfactory Todo.fromMap(Map map) {\nreturn Todo(\ntitle: map['title'],\ndescription: map['description'] ?? '',\nisCompleted: map['isCompleted'] ?? false,\n);\n}\n</code></pre> <p>The first method, <code>toMap</code>, converts a <code>Todo</code> object into a <code>Map&lt;String, dynamic&gt;</code>. The second method, <code>fromMap</code>, creates a <code>Todo</code> object from a <code>Map</code>.</p> <p>This approach will allow us to serialize and deserialize data that cames form a JSON source, so it works also with general APIs.</p> <p>But it is also possible to create the methods to convert to/from Firestore documents directly, using the <code>DocumentSnapshot</code> class.</p> <pre><code>// data/todo.dart\n\nimport 'package:cloud_firestore/cloud_firestore.dart';\n\n// Create a todo object from a Firestore DocumentSnapshot\nfactory Todo.fromFirestore(DocumentSnapshot doc) {\nMap data = doc.data() as Map&lt;String, dynamic&gt;;\nreturn Todo(\nid: doc.id,\ntitle: data['title'],\ndescription: data['description'] ?? '',\nisCompleted: data['isCompleted'] ?? false,\n);\n}\n</code></pre> <p>This method has the advantage of directly getting the document ID from Firestore, which can be useful for updating or deleting documents later. We will use this method instead of <code>fromMap</code> when working with Firestore.</p> <p>DocumentSnapshot</p> <p>The <code>DocumentSnapshot</code> class represents a snapshot of a document in Firestore at a specific point in time. It contains the data of the document as well as metadata such as the document ID and whether the document exists.</p> <p>You can use the <code>data()</code> method to retrieve the data of the document as a map, and you can access the document ID using the <code>id</code> property.</p>"},{"location":"U06%20Connectivity%20and%20remote%20applications/U06.2%20Using%20Firestore/#database-connection","title":"Database connection","text":"<p>To connect to Firestore from your Flutter app, you can use the <code>FirebaseFirestore</code> class provided by the <code>cloud_firestore</code> plugin.</p> <pre><code>import 'package:cloud_firestore/cloud_firestore.dart';\n\nfinal _db = FirebaseFirestore.instance;\n</code></pre> <p>This code initializes a Firestore instance that you can use to interact with your Firestore database.</p>"},{"location":"U06%20Connectivity%20and%20remote%20applications/U06.2%20Using%20Firestore/#crud-operations","title":"CRUD Operations","text":"<p>To perform CRUD (Create, Read, Update, Delete) we are going to create the class <code>TodoDao</code>, inside the data folder that will handle all the operations with Firestore.</p> <pre><code>// data/todo_dao.dart\n\nimport 'package:cloud_firestore/cloud_firestore.dart';\nimport 'package:todos_flutter/data/todo.dart';\n\nclass TodoDao {\nfinal _db = FirebaseFirestore.instance;\n}\n</code></pre> <p>The first method we are going to create is the <code>getTodos</code> method, which retrieves all TODO items from the Firestore database.</p> <pre><code>// data/todo_dao.dart\n\n// Get a list of todos\nStream&lt;List&lt;Todo&gt;&gt; getTodos() {\nreturn _db\n.collection('todos') // Reference to 'todos' collection\n.snapshots() // Get real-time updates as a stream of QuerySnapshot\n.map(\n(snapshot) =&gt;\nsnapshot.docs.map((doc) =&gt; Todo.fromFirestore(doc)).toList(),\n);\n}\n</code></pre> <p>Here we are returning a <code>Stream</code> of <code>List&lt;Todo&gt;</code>, which allows us to listen for real-time updates to the TODO items in the Firestore database. Each time the database changes, the stream will emit a new list of TODO items.</p> <p>The <code>snapshots()</code> method returns a stream of <code>QuerySnapshot</code> objects, which we then map to a list of <code>Todo</code> objects using the <code>fromFirestore</code> factory constructor we defined earlier.</p> <p>To retrieve a songle Todo item by its ID, we can create the <code>getTodoById</code> method:</p> <pre><code>// data/todo_dao.dart\n\n//Get a single todo by its id\nStream&lt;Todo&gt; getTodoById(String id) {\nreturn _db\n.collection('todos')\n.doc(id)\n.snapshots()\n.map((doc) =&gt; Todo.fromFirestore(doc));\n}\n</code></pre> <p>Using <code>doc(id)</code>, we reference a specific document in the 'todos' collection. The <code>snapshots()</code> method returns a stream of <code>DocumentSnapshot</code> objects for that document, which we then map to a Todo object using the <code>fromFirestore</code> factory constructor.</p> <p>This method returns a <code>Stream&lt;Todo&gt;</code>, which allows us to listen for real-time updates to a single TODO item in the Firestore database.</p> <p>To add a new TODO item to the Firestore database, we can create the <code>addTodo</code> method:</p> <pre><code>// data/todo_dao.dart\n\n// Add a new todo\nFuture&lt;void&gt; addTodo(Map&lt;String, dynamic&gt; todoData) {\nreturn _db.collection('todos').add(todoData);\n}\n</code></pre> <p>This method takes a <code>Map&lt;String, dynamic&gt;</code> representing the TODO item data and adds it to the 'todos' collection in Firestore using the <code>add</code> method. The <code>add</code> method automatically generates a unique ID for the new document.</p> <p>The method returns a <code>Future&lt;void&gt;</code>, which completes when the TODO item has been successfully added to the database.</p> <p>To update an existing TODO item in the Firestore database, we can create the <code>updateTodo</code> method:</p> <pre><code>// data/todo_dao.dart\n\n// Update an existing todo\nFuture&lt;void&gt; updateTodo(String id, Map&lt;String, dynamic&gt; todoData) {\nreturn _db.collection('todos').doc(id).update(todoData);\n}\n</code></pre> <p>This method takes the ID of the TODO item to be updated and a map representing the updated TODO item data. It uses the <code>update</code> method to update the document with the specified ID in the 'todos' collection. It also returns a <code>Future&lt;void&gt;</code>, which completes when the TODO item has been successfully updated in the database.</p> <p>Finally, to delete a TODO item from the Firestore database, we can create the <code>deleteTodo</code> method:</p> <pre><code>// data/todo_dao.dart\n\n// Delete a todo\nFuture&lt;void&gt; deleteTodo(String id) {\nreturn _db.collection('todos').doc(id).delete();\n}\n</code></pre> <p>References:</p> <ul> <li>Add and update data</li> <li>Get data</li> <li>Get realtime updates</li> <li>Delete data</li> </ul>"},{"location":"U06%20Connectivity%20and%20remote%20applications/U06.2%20Using%20Firestore/#the-repository-pattern","title":"The repository pattern","text":"<p>At this point, we can use directly the <code>TodoDao</code> class to perform CRUD operations on our Firestore database. However, it is a good practice to use the repository pattern to abstract the data access layer from the rest of the application.</p> <p>In our case, we create a method for each CRUD operation in the <code>TodoRepository</code> class that internally calls the corresponding method in the <code>TodoDao</code> class. These methods are static, so we don't need to create an instance of the <code>TodoRepository</code> class to use them.</p> <pre><code>// data/todo_repository.dart\n\nimport 'package:todos_flutter/data/todo.dart';\nimport 'package:todos_flutter/data/todo_dao.dart';\n\nclass TodoRepository {\nstatic final TodoDao _todoDao = TodoDao();\n\n// Get all Todo items with an static method\nstatic Future&lt;Stream&lt;List&lt;Todo&gt;&gt;&gt; getAllTodos() async {\nreturn _todoDao.getTodos();\n}\n\n// Get a single Todo item by ID\nstatic Future&lt;Stream&lt;Todo&gt;&gt; getTodoById(String id) async {\nreturn _todoDao.getTodoById(id);\n}\n\n//Insert a new Todo item\nstatic Future&lt;void&gt; insertTodo(Todo todo) async {\n_todoDao.addTodo(todo.toMap());\n}\n\n//Update an existing Todo item\nstatic Future&lt;void&gt; updateTodo(Todo todo) async {\nif (todo.id != null) {\n_todoDao.updateTodo(todo.id!, todo.toMap());\n}\n}\n\n//Delete a Todo item by ID\nstatic Future&lt;void&gt; deleteTodo(String id) async {\n_todoDao.deleteTodo(id);\n}\n}\n</code></pre> <p>Note how, in the <code>insertTodo</code> and <code>updateTodo</code> methods, we convert the <code>Todo</code> object to a map using the <code>toMap</code> method before passing it to the <code>TodoDao</code> methods.</p>"},{"location":"U06%20Connectivity%20and%20remote%20applications/U06.2%20Using%20Firestore/#saving-new-todo-items","title":"Saving new TODO items","text":"<p>The steps to insert a new TODO item are as follows:</p> <ol> <li>The user clicks the \"Add\" button in the Todo List Screen.</li> <li>The app navigates to the Todo Edit Screen in \"save\" mode.</li> <li>The user fills in the TODO item details and clicks the \"Save\" button.</li> <li>The app creates a new <code>Todo</code> object with the provided details.</li> <li>The app calls the <code>insertTodo</code> method of the <code>TodoRepository</code> to save the new TODO item to Firestore.</li> <li>The app navigates back to the Todo List Screen.</li> </ol> <p>First, we are going to create the method to save the new TODO item in the <code>TodoProvider</code> class:</p> <pre><code>// ui/providers/todo_provider.dart\n\nimport 'package:todos_flutter/data/todo.dart';\nimport 'package:todos_flutter/data/todo_repository.dart';\n\nvoid saveTodo() {\nTodo todo = Todo(\ntitle: _title,\ndescription: _description,\nisCompleted: _isCompleted,\n);\nTodoRepository.insertTodo(todo);\n}\n</code></pre> <p>The values for the new TODO item are taken from the provider's private variables.</p> <p>In the <code>EditTodoScreen</code>, we call the <code>saveTodo</code> method when the user clicks the \"Save\" button:</p> <pre><code>// ui/screens/edit_todo_screen.dart\n\n...\nIconButton(\nicon: const Icon(Icons.save),\nonPressed: state.validateTodo()\n? () {\nif (state.id.isEmpty) {\nstate.saveTodo(); // Add this\nNavigator.pop(context);\n} else {\n// Update Todo\nNavigator.pop(context);\n}\n}\n: null,\n),\n...\n</code></pre> <p>The <code>onPressed</code> callback already has the logic to detect if the Todo is valid (has some characters in the title field) and if we are in \"save\" or \"update\" mode. If the <code>id</code> is empty (because the todo is new), we are in \"save\" mode, so we call the <code>saveTodo</code> method of the provider.</p> <p>The app navigates back to the Todo List Screen, but the new todo is not yet visible. However, if you go to the Firestore section of your Firebase Console, you should see the new TODO item added to the 'todos' collection after saving it from the app.</p> <p></p>"},{"location":"U06%20Connectivity%20and%20remote%20applications/U06.2%20Using%20Firestore/#retrieving-the-list-of-todo-items","title":"Retrieving the list of TODO items","text":"<p>To retrieve the list of TODO items from Firestore and display them in the Todo List Screen, we need to update the <code>TodoListProvider</code> class to use the <code>getAllTodos</code> method from the <code>TodoRepository</code>.</p> <p>First, we need some fields to represent the state: a Todo List to store the retrieved TODO items; an <code>isLoading</code> boolean to indicate if the data is being loaded; and a Stream Subscription to manage the stream of TODO items ang get real-time updates:</p> <pre><code>// ui/providers/todo_list_provider.dart\n\nimport 'dart:async';\nimport 'package:todos_flutter/data/todo.dart';\n\nclass TodoListProvider extends ChangeNotifier {\nfinal List&lt;Todo&gt; _todoList = [];\nList&lt;Todo&gt; get todoList =&gt; _todoList;\n\nbool _isLoading = false;\nbool get isLoading =&gt; _isLoading;\n\nStreamSubscription&lt;List&lt;Todo&gt;&gt;? _subscription;\n}\n</code></pre> <p>Next, the <code>setTodoList</code> method updates the TODO list and notify listeners:</p> <pre><code>// ui/providers/todo_list_provider.dart\n\nimport 'package:todos_flutter/data/todo_repository.dart';\n\n\nvoid setTodoList() {\n// if already subscribed, do nothing\nif (_subscription != null) return;\n\n// mark loading and notify UI\n_isLoading = true;\nnotifyListeners();\n\n// TodoRepository.getAllTodos() returns a Future&lt;Stream&lt;List&lt;Todo&gt;&gt;&gt;\nTodoRepository.getAllTodos()\n.then((stream) {\n_subscription = stream.listen(\n(List&lt;Todo&gt; todos) {\n_todoList.clear();\n_todoList.addAll(todos);\n\n// loading is complete\n_isLoading = false;\nnotifyListeners();\n},\nonError: (error) {\n// stop loading on error and notify\n_isLoading = false;\nnotifyListeners();\nprint('Error listening todos: $error');\n},\n);\n})\n.catchError((err) {\n_isLoading = false;\nnotifyListeners();\nprint('Failed to get todos stream: $err');\n});\n}\n</code></pre> <p>This methos first checks if there is already a subscription to the TODO stream. If not, it marks the loading state as true and notifies listeners.</p> <p>Then, it calls the <code>getAllTodos</code> method from the <code>TodoRepository</code>, which returns a <code>Future&lt;Stream&lt;List&lt;Todo&gt;&gt;&gt;</code>. When the future completes, we listen to the stream and update the <code>_todoList</code> with the retrieved TODO items. We also handle errors that may occur during the listening process.</p> <p>In the <code>TodoListScreen</code>, we call the <code>setTodoList</code> method after the first frame is rendered in the <code>initState</code> method:</p> <pre><code>// ui/screens/todo_list_screen.dart\n\n@override\nvoid initState() {\nsuper.initState();\nWidgetsBinding.instance.addPostFrameCallback((_) {\nProvider.of&lt;TodoListProvider&gt;(context, listen: false).setTodoList();\n});\n}\n</code></pre> <p>In the Scaffold body, we want to manage the <code>isLoading</code> and empty list states:</p> <pre><code>// ui/screens/todo_list_screen.dart\n\nlistState.isLoading\n? const Center(child: CircularProgressIndicator())\n: listState.todoList.isEmpty\n? const Center(child: Text('No TODOs available.'))\n: Center(\nchild: Center(\nchild: ListView.builder(\n...\n</code></pre> <p>Next, we update the <code>itemCount</code> of the <code>ListView.builder</code> to use the length of the <code>todoList</code> from the provider:</p> <pre><code>// ui/screens/todo_list_screen.dart\n\n...\nchild: ListView.builder(\nitemCount: listState.todoList.length, // Change to list items count\n...\n</code></pre> <p>Now, we update the <code>ListTile</code> parameters to show the TODO item details:</p> <pre><code>// ui/screens/todo_list_screen.dart\n\n...\nreturn ListTile(\nleading: Icon(\nlistState.todoList[index].isCompleted ? Icons.check_box : Icons.check_box_outline_blank,\ncolor: listState.todoList[index].isCompleted ? Colors.green : Colors.grey,\n),\ntitle: Text(\nlistState.todoList[index].title,\nstyle: const TextStyle(fontSize: 18),\n),\nsubtitle: Text(\nlistState.todoList[index].description ?? '',\nstyle: const TextStyle(fontSize: 14),\n),\n...\n</code></pre> <p>Finally, update the <code>onTap</code> callback to navigate to the <code>EditTodoScreen</code> in \"update\" mode: fisrt, we clear the todo provider state, then we set the todo ID to load, and navigate to the edit screen.</p> <pre><code>// ui/screens/todo_list_screen.dart\n\n...\nonTap: () {\ntodoState.clear();\n// Populate the TodoProvider with the tapped todo and open the edit screen\ntodoState.setId(listState.todoList[index].id ?? '');\nNavigator.push(\ncontext,\nMaterialPageRoute(\nbuilder: (context) =&gt; const EditTodoScreen(),\n),\n);\n},\n</code></pre> <p>Check that the list of TODO items is displayed correctly in the Todo List Screen. You should see the TODO items retrieved from Firestore, and any changes made to the database (such as adding, updating, or deleting TODO items) should be reflected in real-time in the app.</p>"},{"location":"U06%20Connectivity%20and%20remote%20applications/U06.2%20Using%20Firestore/#updating-todo-items","title":"Updating TODO items","text":"<p>To update an existing TODO item in Firestore, we need to implement the update functionality in the <code>TodoProvider</code> class and the <code>EditTodoScreen</code>. </p> <p>The steps to update a TODO item are as follows:</p> <ol> <li>In the Todo Edit Screen, the app gets the todo id from the provider and retrieves the TODO item details from Firestore using the <code>getTodoById</code> method of the <code>TodoRepository</code>.</li> <li>The app updates the UI fields with the retrieved TODO item details.</li> <li>The user modifies the TODO item details and clicks the \"Save\" button.</li> <li>The app creates a <code>Todo</code> object with the updated details.</li> <li>The app calls the <code>updateTodo</code> method of the <code>TodoRepository</code> to save the updated TODO item to Firestore.</li> <li>The app navigates back to the Todo List Screen.</li> </ol> <p>First, we create the <code>getTodoById</code> method in the <code>TodoProvider</code> class:</p> <pre><code>// ui/providers/todo_provider.dart\n\nvoid getTodoById(String id) async {\nStream&lt;Todo&gt; todo = await TodoRepository.getTodoById(id);\ntodo.listen((Todo t) {\n_title = t.title;\n_description = t.description ?? '';\n_isCompleted = t.isCompleted;\n_id = t.id ?? '';\nnotifyListeners();\n});\n}\n</code></pre> <p>As we are getting the TODO item as a stream, we listen to it and update the provider's private variables with the retrieved TODO item details.</p> <p>In the <code>EditTodoScreen</code>, we call the <code>getTodoById</code> method in the <code>initState</code> method:</p> <pre><code>// ui/screens/edit_todo_screen.dart\n\n@override\nvoid initState() {\nsuper.initState();\n// Initialize controllers empty; we'll populate them when provider notifies\n_titleController = TextEditingController();\n_descriptionController = TextEditingController();\n\n// Defer loading the todo until after the first frame so context is available safely\nWidgetsBinding.instance.addPostFrameCallback((_) {\nfinal state = Provider.of&lt;TodoProvider&gt;(context, listen: false);\nstate.getTodoById(state.id); // Get the todo by its id\n// If the provider already has values, set them immediately\n_titleController.text = state.title;\n_descriptionController.text = state.description;\n});\n}\n</code></pre> <p>Now, when you tap on a Todo item in the Todo List Screen, the app navigates to the Edit Todo Screen and retrieves the TODO item details from Firestore, populating the UI fields with the current values.</p> <p>To update the TODO item when the user clicks the \"Save\" button, we need to create the <code>updateTodo</code> method in the <code>TodoProvider</code> class:</p> <pre><code>// ui/providers/todo_provider.dart\n\nvoid updateTodo() {\nTodo todo = Todo(\nid: id,\ntitle: _title,\ndescription: _description,\nisCompleted: _isCompleted,\n);\nTodoRepository.updateTodo(todo);\n}\n</code></pre> <p>This method creates a <code>Todo</code> object with the updated details from the provider's private variables and calls the <code>updateTodo</code> method of the <code>TodoRepository</code> to save the updated TODO item to Firestore.</p> <p>Then, in the <code>EditTodoScreen</code>, we call the <code>updateTodo</code> method when the user clicks the \"Save\" button:</p> <pre><code>// ui/screens/edit_todo_screen.dart\n\nIconButton(\nicon: const Icon(Icons.save),\nonPressed: state.validateTodo()\n? () {\nif (state.id.isEmpty) {\nstate.saveTodo();\nNavigator.pop(context);\n} else {\nstate.updateTodo(); // Add this\nNavigator.pop(context);\n}\n}\n: null,\n),\n</code></pre> <p>Check that updating a TODO item works correctly. When you modify the details of a TODO item in the Edit Todo Screen and click the \"Save\" button, the changes should be saved to Firestore, and the updated TODO item should be reflected in real-time in the Todo List Screen.</p>"},{"location":"U06%20Connectivity%20and%20remote%20applications/U06.2%20Using%20Firestore/#deleting-todo-items","title":"Deleting TODO items","text":"<p>To delete a TODO item from Firestore, we need to implement the delete functionality in the <code>TodoProvider</code> class :</p> <pre><code>// ui/providers/todo_provider.dart\n\nvoid deleteTodo() {\nTodoRepository.deleteTodo(id);\n}\n</code></pre> <p>Then, call the <code>deleteTodo</code> method when the user clicks the \"Delete\" button in the <code>EditTodoScreen</code>:</p> <pre><code>// ui/screens/edit_todo_screen.dart\n\nIconButton(\nicon: const Icon(Icons.delete),\nonPressed: state.id.isNotEmpty\n? () {\nstate.deleteTodo(); // Add this\nNavigator.pop(context);\n}\n: null,\n),\n</code></pre> <p>Done! Now your app can perform CRUD operations on TODO items using Firestore as the backend database. You can add, retrieve, update, and delete TODO items, and the changes will be reflected in real-time in the app.</p>"},{"location":"U06%20Connectivity%20and%20remote%20applications/U06.2%20Using%20Firestore/#queries","title":"Queries","text":"<p>Firestore provides powerful querying capabilities that allow you to retrieve documents based on specific criteria. these queries can be used with <code>get()</code> for one-time retrieval or with <code>snapshots()</code> for real-time updates.</p> <p>For example, to retrieve only the completed TODO items, you can use the <code>where</code> method to filter the documents based on the <code>isCompleted</code> field:</p> <pre><code>final todosRef = db.collection('todos');\nfinal query = todosRef.where('isCompleted', isEqualTo: true);\n</code></pre> <p>After creating a query object, use the <code>get()</code> function to retrieve the results:</p> <pre><code>todosRef.where('isCompleted', isEqualTo: true).get().then( (querySnapshot) {\nfor (var doc in querySnapshot.docs) {\nprint(doc.data());\n}\n},\nonError: (e) =&gt; print(\"Failed to get completed todos: $e\"),\n);\n</code></pre> <p>The <code>where()</code> method takes three parameters: a field to filter on, a comparison operator, and a value. Cloud Firestore supports the following Flutter comparison operators:</p> <ul> <li><code>isLessThan</code></li> <li><code>isLessThanOrEqualTo</code></li> <li><code>isEqualTo</code></li> <li><code>isGreaterThan</code></li> <li><code>isGreaterThanOrEqualTo</code></li> <li><code>isNotEqualTo</code></li> <li><code>arrayContains</code></li> <li><code>arrayContainsAny</code></li> <li><code>whereIn</code></li> <li><code>whereNotIn</code></li> </ul> <p>Examples:</p> <pre><code>ageQuery = usersRef.where(\"age\", isGreaterThan: 18);\nstateQuery = citiesRef.where(\"state\", isEqualTo: \"CA\");\npopulationQuery = citiesRef.where(\"population\", isLessThanOrEqualTo: 100000);\nnotCapitals = citiesRef.where(\"capital\", isNotEqualTo: true);\nwestCoastcities = citiesRef.where(\"regions\", arrayContains: \"west_coast\");\ncities = citiesRef.where(\"country\", whereIn: [\"USA\", \"Japan\"]);\ncities2 = citiesRef.where(\"country\", whereNotIn: [\"USA\", \"Japan\"]);\n</code></pre>"},{"location":"U06%20Connectivity%20and%20remote%20applications/U06.2%20Using%20Firestore/#compound-queries","title":"Compound queries","text":"<p>You can combine constraints with a logical AND by chaining multiple equality operators (<code>==</code> or <code>array-contains</code>). However, you must create a composite index to combine equality operators with the inequality operators, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>!=</code>:</p> <pre><code>// state == \"CA\" AND name == \"San Francisco\"\nvar query = citiesRef\n.where(\"state\", isEqualTo: \"CA\")\n.where(\"name\", isEqualTo: \"San Francisco\");\n</code></pre> <p>To perform OR queries, use the <code>whereIn</code>, <code>whereNotIn</code>, or <code>arrayContainsAny</code> operators:</p> <pre><code>// state == \"CA\" OR state == \"WA\"\nvar query = citiesRef.where(\"state\", whereIn: [\"CA\", \"WA\"]);\n</code></pre> <p>Another way that involves different fields is to use the <code>Filter.or</code> method:</p> <pre><code>var query = db.collection(\"cities\").where(\nFilter.or(\nFilter(\"capital\", isEqualTo: true),\nFilter(\"population\", isGreaterThan: 1000000),\n),\n);\n</code></pre> <p>Queries reference: Query data in Cloud Firestore</p>"},{"location":"U06%20Connectivity%20and%20remote%20applications/U06.2%20Using%20Firestore/#order-and-limit-data","title":"Order and limit data","text":"<p>You can order the results of a query using the <code>orderBy</code> method. </p> <pre><code>var query = db.collection(\"todos\").orderBy(\"title\");\n</code></pre> <p>By default, the results are ordered in ascending order. To order in descending order, you can pass <code>descending: true</code> as a second parameter:</p> <pre><code>var query = db.collection(\"todos\").orderBy(\"title\", descending: true);\n</code></pre> <p>You can limit the number of results returned by a query using the <code>limit</code> method:</p> <pre><code>var query = db\n.collection(\"todos\")\n.orderBy(\"title\", descending: true)\n.limit(10);\n</code></pre> <p>You can combine <code>where</code>, <code>orderBy</code>, and <code>limit</code> methods to create complex queries:</p> <pre><code>var query = db\n.collection(\"todos\")\n.where(\"isCompleted\", isEqualTo: true)\n.orderBy(\"title\")\n.limit(5);\n</code></pre> <p>Order and limit reference: Order and limit data</p>"},{"location":"U06%20Connectivity%20and%20remote%20applications/U06.3%20Firebase%20authentication/","title":"Unit 6.3 Using Firebase Authentication","text":"<p>Firebase Authentication provides backend services, easy-to-use SDKs, and ready-made UI libraries to authenticate users to your app. It supports authentication using passwords, phone numbers, popular federated identity providers like Google, Facebook, and Twitter, and more.</p> <p>In this section, we will cover the basics of integrating Firebase Authentication into your Flutter app using the TODO app as an example.</p>"},{"location":"U06%20Connectivity%20and%20remote%20applications/U06.3%20Firebase%20authentication/#adding-firebase-authentication-to-your-app","title":"Adding Firebase Authentication to your app","text":"<p>To add Firebase Authentication to your Flutter app, follow these steps:</p> <ol> <li>Set up Firebase in your Flutter project: If you haven't already, set up Firebase in your Flutter project by following the instructions in the Firebase documentation. We have done it in previous sections.</li> <li>Add the Firebase Authentication package: Add the <code>firebase_auth</code> package to your <code>pubspec.yaml</code> file:    <pre><code>flutter pub add firebase_auth\n</code></pre></li> <li>Once added, run <code>flutter run</code> to rebuild your project with the new dependency.</li> <li>Go to the Firebase Console, select your project, and navigate to the \"Authentication\" section. Press the \"Get started\" button.</li> <li>Select the \"Sign-in method\" tab and enable the desired authentication methods (e.g., Email/Password, Google, etc.). In this example we are going to use Email/Password.  </li> </ol> <p>Now your app is ready to use Firebase Authentication. The next step should be to create a login/registration screen and implement the authentication logic. But we are going to usea Flutter package that provides pre-built authentication screens and logic to simplify the process.</p> <p>The <code>firebase_ui_auth</code> package offers a set of customizable UI components for Firebase Authentication. Intall it by doing:</p> <pre><code>flutter pub add firebase_ui_auth\n</code></pre>"},{"location":"U06%20Connectivity%20and%20remote%20applications/U06.3%20Firebase%20authentication/#implementing-authentication-with-firebase_ui_auth","title":"Implementing Authentication with firebase_ui_auth","text":"<p>The first step is to create a provider for the user data. In this provider we can access the user information from anywhere in the app and we canknow if the user is logged in or not.</p> <p>Create a new file <code>ui/providers/user_provider.dart</code> with the following content:</p> <pre><code>// ui/providers/user_provider.dart\n\nimport 'dart:async';\n\nimport 'package:firebase_auth/firebase_auth.dart' hide EmailAuthProvider;\nimport 'package:firebase_ui_auth/firebase_ui_auth.dart';\nimport 'package:flutter/material.dart';\n\nclass UserProvider with ChangeNotifier {\nfinal providers = [EmailAuthProvider()];\n\nUser? _currentUser;\nUser? get currentUser =&gt; _currentUser;\n\nStreamSubscription&lt;User?&gt;? _userSubscription;\n\nUserProvider() {\n// Initialize with the current user and start listening for changes\n_currentUser = FirebaseAuth.instance.currentUser;\nuserChanges(); // Start listening to user changes\n}\n\nvoid userChanges() {\n// Cancel any existing subscription before creating a new one\n_userSubscription?.cancel();\n_userSubscription = FirebaseAuth.instance.userChanges().listen((user) {\n_currentUser = user;\nnotifyListeners();\n});\n}\n\n@override\nvoid dispose() {\n_userSubscription?.cancel();\nsuper.dispose();\n}\n}\n</code></pre> <p>In the imports, note how we hide the <code>EmailAuthProvider</code> from <code>firebase_auth</code> to avoid conflicts with the one from <code>firebase_ui_auth</code>. This is the one we are going to use.</p> <p>As we are going to use only the email/password authentication method, we create a list with only that provider (<code>EmailAuthProvider()</code>).</p> <p>The <code>FirebaseAuth.instance.currentUser</code> method gives us the current user if logged in, or null if not.</p> <p>The <code>userChanges()</code> method listens for changes in the authentication state and updates the <code>_currentUser</code> variable accordingly and notifies listeners.</p> <p>The <code>dispose()</code> method cancels the subscription when the provider is disposed of to prevent memory leaks.</p> <p>Finalkly, we need a method to be called when the authentication state changes. This method is based on the one explained in the firebase_ui_auth documentation:</p> <pre><code>// ui/providers/user_provider.dart\n\nAuthStateChangeAction&lt;SignedIn&gt; authStateChangeAction() {\nreturn AuthStateChangeAction&lt;SignedIn&gt;((context, state) {\nNavigator.pushReplacement(\ncontext,\nMaterialPageRoute(\nbuilder: (context) =&gt; ProfileScreen(\nactions: [\nSignedOutAction((context) {\nNavigator.pop(context);\n}),\n],\n),\n),\n);\n});\n}\n</code></pre> <p>This method navigates to the <code>ProfileScreen</code> when the user signs in, and sets up an action to navigate back when the user signs out.</p> <p>To get the notification form this provider, we need to add it to the main app. Open <code>my_app.dart</code> and add the new provider to the <code>MultiProvider</code> widget:</p> <pre><code>// my_app.dart\n\nimport 'package:todos_flutter/ui/providers/user_provider.dart';\n\nreturn MultiProvider(\nproviders: [\nChangeNotifierProvider(create: (context) =&gt; TodoProvider()),\nChangeNotifierProvider(create: (context) =&gt; TodoListProvider()),\nChangeNotifierProvider(create: (context) =&gt; UserProvider()), // ADD THIS\n],\n</code></pre> <p>Now, we will add a button to the app bar in the <code>TodoListScreen</code> to allow users to sign in or out. </p> <p>Open <code>todo_list_screen.dart</code> and add the required dependencies:</p> <pre><code>// ui/screens/todo_list_screen.dart\n\nimport 'package:firebase_ui_auth/firebase_ui_auth.dart';\nimport 'package:todos_flutter/ui/providers/user_provider.dart';\n</code></pre> <p>Then, add an UserProvider variable to access the user data:</p> <pre><code>// ui/screens/todo_list_screen.dart\n\n@override\nWidget build(BuildContext context) {\nvar listState = Provider.of&lt;TodoListProvider&gt;(context);\nvar todoState = Provider.of&lt;TodoProvider&gt;(context);\nvar userProvider = Provider.of&lt;UserProvider&gt;(context); //Add this\n</code></pre> <p>In the AppBar widget, add an IconButton to handle sign-in and sign-out actions. The button will display a different icon based on the user's authentication state. We can also show the user's display name or email when logged in:</p> <pre><code>// ui/screens/todo_list_screen.dart\n\nactions: [\n// Profile button\nIconButton(\nicon: userProvider.currentUser == null\n? Icon(Icons.person_outline)\n: Row(\nchildren: [\nText(userProvider.currentUser?.email ?? ''),\nIcon(Icons.person),\n],\n),\n</code></pre> <p>We can know if the user is logged in or not by checking if <code>userProvider.currentUser</code> is null. If it is null, we show the <code>person_outline</code> icon, otherwise we show the user's email and the <code>person</code> icon.</p> <p>Finally, on the <code>onPressed</code> event of the AppBar button actions button, we check if the user is logged in or not. If not, we navigate to the <code>SignInScreen</code>, otherwise we navigate to the <code>ProfileScreen</code> with a sign-out action that navigates back to the previous screen when the user signs out:</p> <pre><code>// ui/screens/todo_list_screen.dart\n\nonPressed: () {\nuserProvider.currentUser == null\n? Navigator.push(\ncontext,\nMaterialPageRoute(\nbuilder: (context) =&gt; SignInScreen(\nproviders: userProvider.providers,\nactions: [userProvider.authStateChangeAction()],\n),\n),\n)\n: Navigator.push(\ncontext,\nMaterialPageRoute(\nbuilder: (context) =&gt; ProfileScreen(\nactions: [\nSignedOutAction((context) {\nNavigator.pop(context);\n}),\n],\n),\n),\n);\n},\n</code></pre> <p>Time to check the behavior of the app. Run the app and press the profile button in the app bar. You should see the sign-in screen and be able to register a new user or sign in with an existing one. Once signed in, you should see your email in the app bar. You can also sign out from the profile screen.</p> <p>Check the Firebase Console to see the registered users in the \"Authentication\" section. Each user is assigned a unique user ID (UID) by Firebase.</p> <p></p> <p>Task</p> <p>Modify the app to wrap the <code>SignInScreen</code> and <code>ProfileScreen</code> with <code>Scaffold</code> widgets to provide a consistent app bar and navigation experience.</p>"},{"location":"U06%20Connectivity%20and%20remote%20applications/U06.3%20Firebase%20authentication/#associating-user-data-with-todo-items","title":"Associating user data with TODO items","text":"<p>To associate TODO items with specific users, we need to change the way they are stored in Firestore. Now, we have this schema:</p> <pre><code>todos (collection)   \n   |-- todoId (document)\n      |-- title: string\n      |-- description: string\n      |-- isCompleted: boolean   \n</code></pre> <p>The new schema will be:</p> <pre><code>users (collection)   \n   |-- userId (document)\n      |-- todos (collection)\n         |-- todoId (document)\n            |-- title: string\n            |-- description: string\n            |-- isCompleted: boolean   \n</code></pre> <p>There are various ways to implement this change. We will modify the <code>TodoDao</code> methods to include the user ID when accessing the TODO items. After that, we will modify the providers to pass the user ID to the DAO methods and update the UI when the authentication state changes.</p> <p>First, modify the <code>getTodos</code> method in <code>todo_dao.dart</code> to include the user ID:</p> <pre><code>// data/todo_dao.dart\n\nStream&lt;List&lt;Todo&gt;&gt; getTodos(String userId) {\nreturn _db\n.collection('users') // Reference to 'users' collection\n.doc(userId) // Reference to the current user's document\n.collection('todos') // Reference to 'todos' collection\n.snapshots() // Get real-time updates as a stream of QuerySnapshot\n.map(\n(snapshot) =&gt;\nsnapshot.docs.map((doc) =&gt; Todo.fromFirestore(doc)).toList(),\n);\n}\n</code></pre> <p>Modify also the <code>addTodo</code> method:</p> <pre><code>// data/todo_dao.dart\n\nFuture&lt;void&gt; addTodo(String userId, Map&lt;String, dynamic&gt; todoData) {\nprint('Adding todo for user: $userId');\nreturn _db\n.collection('users')\n.doc(userId) // Reference to the current user's document\n.collection('todos')\n.add(todoData);\n}\n</code></pre> <p>Now, modify the repository methods to include the user ID:</p> <pre><code>// data/todo_repository.dart\n\nstatic Future&lt;Stream&lt;List&lt;Todo&gt;&gt;&gt; getAllTodos(String userId) async {\nreturn _todoDao.getTodos(userId);\n}\n\nstatic Future&lt;void&gt; insertTodo(String userId, Todo todo) async {\n_todoDao.addTodo(userId, todo.toMap());\n}\n</code></pre> <p>The next step is to modify the <code>todo_list_provider.dart</code> <code>setTodoList</code> method to pass the user ID when fetching the TODO items and update the Todo list when the authentication state changes:</p> <pre><code>// ui/providers/todo_list_provider.dart\n\nvoid setTodoList() {\nfinal uid = FirebaseAuth.instance.currentUser?.uid;\n\n// If there's no signed-in user, cancel any existing subscription and\n// clear the list so the UI shows an empty state.\nif (uid == null) {\n_subscription?.cancel();\n_subscription = null;\n_todoList.clear();\n_isLoading = false;\nnotifyListeners();\nreturn;\n}\n\n// If already subscribed, cancel first so we re-subscribe for the new user.\n_subscription?.cancel();\n_subscription = null;\n\n_isLoading = true;\nnotifyListeners();\n\n// TodoRepository.getAllTodos() returns a Future&lt;Stream&lt;List&lt;Todo&gt;&gt;&gt;\nTodoRepository.getAllTodos(uid).then((stream) {\n_subscription = stream.listen(\n(List&lt;Todo&gt; todos) {\n_todoList.clear();\n_todoList.addAll(todos);\n\n_isLoading = false;\nnotifyListeners();\n},\nonError: (error) {\n_isLoading = false;\nnotifyListeners();\n// ignore: avoid_print\nprint('Error listening todos: $error');\n},\n);\n}).catchError((err) {\n_isLoading = false;\nnotifyListeners();\n// ignore: avoid_print\nprint('Failed to get todos stream: $err');\n});\n}\n</code></pre> <p>Finally, modify the <code>todo_list_screen.dart</code> to call <code>setTodoList()</code> whenever the authentication state changes. To do this, we can use a VoidCallback that listens for changes in the <code>UserProvider</code> and calls <code>setTodoList()</code> accordingly. We need to change the <code>initState()</code> and <code>dispose()</code> methods as follows:</p> <pre><code>// ui/screens/todo_list_screen.dart\n\nclass _TodoListScreenState extends State&lt;TodoListScreen&gt; {\nlate VoidCallback _userListener; // Listener for UserProvider changes\n\n@override\nvoid initState() {\nsuper.initState();\n//Load the list of TODOs from the provider when the widget is mounted\nWidgetsBinding.instance.addPostFrameCallback((_) {\ncontext.read&lt;TodoListProvider&gt;().setTodoList();\n\n// Register a listener on UserProvider to reload the todo list when the\n// authentication state changes (sign-in / sign-out / user updates).\nfinal userProvider = context.read&lt;UserProvider&gt;();\n_userListener = () {\n// When user changes, refresh the todo list for the new user (or empty)\ncontext.read&lt;TodoListProvider&gt;().setTodoList();\n};\nuserProvider.addListener(_userListener);\n});\n}\n\n@override\nvoid dispose() {\n// Remove the listener from UserProvider to avoid leaks. Use try/catch in\n// case the provider was removed earlier in the tree.\ntry {\nfinal userProvider = context.read&lt;UserProvider&gt;();\nuserProvider.removeListener(_userListener);\n} catch (_) {\n// ignore: no-op\n}\n\nsuper.dispose();\n}\n...\n</code></pre> <p>We need to do the same for the TodoProvider methods that access individual TODO items. Modify the <code>saveTodo</code> method in <code>todo_provider.dart</code> to include the user ID:</p> <pre><code>void saveTodo() {\nfinal uid = FirebaseAuth.instance.currentUser?.uid;\nif (uid == null) return;\n\nTodo todo = Todo(\ntitle: _title,\ndescription: _description,\nisCompleted: _isCompleted,\n);\nTodoRepository.insertTodo(uid!, todo);\n}\n</code></pre> <p>Run the app again. Now, when you sign in, you should see an empty TODO list for the new user. You can add TODO items, and they will be associated with that user. When you sign out and sign in with another user, you will see a different TODO list.</p> <p>Next, we are going to modify the <code>getTodoById</code> and <code>updateTodo</code> methods in the <code>todo_dao.dart</code> file to include the user ID as well:</p> <pre><code>// data/todo_dao.dart\n\nStream&lt;Todo&gt; getTodoById(String userId, String id) {\nreturn _db\n.collection('users')\n.doc(userId)\n.collection('todos')\n.doc(id)\n.snapshots()\n.map((doc) =&gt; Todo.fromFirestore(doc));\n}\n\nFuture&lt;void&gt; updateTodo(String userId, String id, Map&lt;String, dynamic&gt; todoData) {\nreturn _db\n.collection('users')\n.doc(userId)\n.collection('todos')\n.doc(id)\n.update(todoData);\n}\n</code></pre> <p>We need to change the repository methods too:</p> <pre><code>// data/todo_repository.dart\n\nstatic Future&lt;Stream&lt;Todo&gt;&gt; getTodoById(String userId, String id) async {\nreturn _todoDao.getTodoById(userId, id);\n}\n\n//Update an existing Todo item\nstatic Future&lt;void&gt; updateTodo(String userId, Todo todo) async {\nif (todo.id != null) {\n_todoDao.updateTodo(userId, todo.id!, todo.toMap());\n}\n}\n</code></pre> <p>Finally, update the <code>TodoProvider</code> methods to pass the user ID:</p> <pre><code>// ui/providers/todo_provider.dart\n\nvoid getTodoById(String id) async {\nfinal uid = FirebaseAuth.instance.currentUser?.uid;\nif (uid == null) return;\n\nStream&lt;Todo&gt; todo = await TodoRepository.getTodoById(uid, id);\ntodo.listen((Todo t) {\n_title = t.title;\n_description = t.description ?? '';\n_isCompleted = t.isCompleted;\n_id = t.id ?? '';\nnotifyListeners();\n});\n}\n\nvoid updateTodo() {\nfinal uid = FirebaseAuth.instance.currentUser?.uid;\nif (uid == null) return;\n\nTodo todo = Todo(\nid: id,\ntitle: _title,\ndescription: _description,\nisCompleted: _isCompleted,\n);\nTodoRepository.updateTodo(uid, todo);\n}\n</code></pre> <p>Finally, we will do the same for the delete operation:</p> <pre><code>// data/todo_dao.dart\n\nFuture&lt;void&gt; deleteTodo(String userId, String id) {\nreturn _db\n.collection('users')\n.doc(userId)\n.collection('todos')\n.doc(id)\n.delete();\n}\n</code></pre> <p>And in the repository:</p> <pre><code>// data/todo_repository.dart\n\nstatic Future&lt;void&gt; deleteTodo(String userId, String id) async {\n_todoDao.deleteTodo(userId, id);\n}\n</code></pre> <p>And finally, in the <code>todo_provider.dart</code>:</p> <pre><code>// ui/providers/todo_provider.dart\n\nvoid deleteTodo() {\nfinal uid = FirebaseAuth.instance.currentUser?.uid;\nif (uid == null) return;\n\nTodoRepository.deleteTodo(uid, id);\n}\n</code></pre> <p>Run the app again. Now you should be able to delete TODO items as well.</p>"},{"location":"U06%20Connectivity%20and%20remote%20applications/U06.3%20Firebase%20authentication/#additional-ui-changes","title":"Additional UI changes","text":"<p>As a last detail, we can modify the <code>TodoListScreen</code> to show a message when none user is logged in, adding a ternary operator at the beginning of the <code>body</code> property:</p> <pre><code>// ui/screens/todo_list_screen.dart\n\nbody: userProvider.currentUser == null\n? const Center(child: Text('Please sign in to view your TODOs.'))\n: listState.isLoading\n? const Center(child: CircularProgressIndicator())\n: listState.todoList.isEmpty\n? const Center(child: Text('No TODOs available.'))\n: Center(\n// existing ListView.builder code\n</code></pre> <p>We also should hide the <code>FloatingActionButton</code> when no user is logged in:</p> <pre><code>// ui/screens/todo_list_screen.dart\n\nfloatingActionButton: userProvider.currentUser != null\n? FloatingActionButton(\nonPressed: () {\nnewTodo(todoState, context);\n},\nchild: const Icon(Icons.add),\n)\n: null,\n</code></pre> <p>Run the app one last time. Now, when no user is logged in, you should see a message prompting you to sign in to view your TODOs, and the FloatingActionButton should be hidden.</p>"},{"location":"U06%20Connectivity%20and%20remote%20applications/U06.3%20Firebase%20authentication/#secure-your-firestore-data","title":"Secure your Firestore data","text":"<p>To ensure that each user's TODO items are private and secure, we need to set up Firestore security rules. These rules will restrict access to the data based on the authenticated user's ID.</p> <p>In the Firebase Console, navigate to the \"Firestore Database\" section and select the \"Rules\" tab. Replace the existing rules with the following:</p> <pre><code>rules_version = '2';\n\nservice cloud.firestore {\n  match /databases/{database}/documents {\n    // Allow only authenticated content owners access\n    match /users/{userId} {\n      allow read, write: if request.auth != null &amp;&amp; request.auth.uid == userId\n      // Match any document in the 'todos' subcollection\n      match /todos/{todoId} {\n        // Allow read and write access only to the authenticated user\n        allow read, write: if request.auth != null &amp;&amp; request.auth.uid == userId;\n      }\n    }\n  }\n}\n</code></pre> <p>Rerun your app and test the authentication and data access. Each user should only be able to see and modify their own TODO items.</p>"},{"location":"U06%20Connectivity%20and%20remote%20applications/U06.4%20Analytics%20and%20Crashlytics/","title":"Unit 6.4 Analytics and Crashlytics","text":"<p>Analytics and Crashlytics are two powerful tools provided by Firebase that help developers monitor and improve their applications. Analytics provides insights into user behavior, while Crashlytics helps track and resolve app crashes.</p> <p>We will implement both Firebase Analytics and Crashlytics in our TODO app.</p>"},{"location":"U06%20Connectivity%20and%20remote%20applications/U06.4%20Analytics%20and%20Crashlytics/#firebase-analytics","title":"Firebase Analytics","text":"<p>Firebase Analytics is an app measurement solution that provides insights on app usage and user engagement. It helps developers understand how users interact with their app, which features are most popular, and how to improve user retention.</p>"},{"location":"U06%20Connectivity%20and%20remote%20applications/U06.4%20Analytics%20and%20Crashlytics/#adding-firebase-analytics-to-your-app","title":"Adding Firebase Analytics to Your App","text":"<p>To add Firebase Analytics to your Android app, follow these steps:</p> <ol> <li> <p>Add the Firebase Analytics dependency: Execute the following command in your terminal to add the Firebase Analytics library to your project:</p> <pre><code>flutter pub add firebase_analytics\n</code></pre> </li> <li> <p>Go to the Firebase Console to view the analytics data for your app. Go to Analytics &gt; Dashboard and click on Enable Google Analytics for your project if you haven't done so already. You may need to configure some settings for Google Analytics.</p> </li> </ol>"},{"location":"U06%20Connectivity%20and%20remote%20applications/U06.4%20Analytics%20and%20Crashlytics/#creating-analytics-events","title":"Creating analytics events","text":"<p>There are several events that you can log in your TODO app to gain insights into user behavior. Some of them are collected automatically by Firebase Analytics, such as:</p> <ul> <li><code>app_update</code>: triggered when the app is updated to a new version.</li> <li><code>first_open</code>: logged the first time a user opens the app after installation.</li> <li><code>in_app_purchase</code>: automatically captured when an in-app purchase occurs (if configured).</li> <li><code>screen_view</code>: records transitions between different screens or pages in the app.</li> <li><code>session_start</code>: marks the beginning of a new user session.</li> </ul> <p>There are also other predefined events that you can log manually, such as:</p> <ul> <li><code>app_open</code>: when a user opens the app.</li> <li><code>add_to_cart</code>: when a user adds an item to their shopping cart.</li> <li><code>login</code>: when a user logs into the app.</li> <li><code>share</code>: when a user shares content from the app.</li> <li><code>sign_up</code>: when a user signs up for an account.</li> <li><code>view_item</code>: when a user views a specific item or product.  </li> </ul> <p>The list of predefined events can be found in the Firebase documentation.</p> <p>As an example, in our TODO app, we are going to log general events as follows:</p> <ul> <li>In the main.dart file, add the import and initialize Firebase Analytics:</li> </ul> <pre><code>import 'package:firebase_analytics/firebase_analytics.dart';\n\nFuture&lt;void&gt; main() async {\nWidgetsFlutterBinding.ensureInitialized(); // Ensure Flutter bindings are initialized\nawait Firebase.initializeApp(\noptions: DefaultFirebaseOptions.currentPlatform, // Initialize Firebase with platform-specific options\n);\n\n//Firebase analytics\nfinal FirebaseAnalytics analytics = FirebaseAnalytics.instance;\n</code></pre> <p>Ensure that initialization is done after <code>Firebase.initializeApp()</code>.</p> <p>This is enough to start logging automatic events in your app. But we are also going to log some custom events. For example, we can log an event when the app is opened:</p> <pre><code>// main.dart\n\nawait analytics.logAppOpen();\n</code></pre> <p>We can also add parameters as a map:</p> <pre><code>// main.dart\n\nawait analytics.logAppOpen(\nparameters: {'timestamp': DateTime.now().toIso8601String()},\n);\n</code></pre> <p>This adds a timestamp parameter to the <code>app_open</code> event.</p> <p>We can also log events for custom actions. For example, if we want to track when a user adds a new task, we can log an event in the place where the task is added:</p> <pre><code>// edit_todo_screen.dart\n\nclass _EditTodoScreenState extends State&lt;EditTodoScreen&gt; {\n\nlate FirebaseAnalytics _analytics;\n\n@override\nvoid initState() {\n// Existing initialization code...\n\n_analytics = FirebaseAnalytics.instance;\n}\n\n// Save button pressed\nif (state.id.isEmpty) {\nstate.saveTodo();\nanalytics.logEvent(\nname: 'todo_saved',\nparameters: {\n'timestamp': DateTime.now().toIso8601String(),\n},\n);\nNavigator.pop(context);\n}\n...\n</code></pre> <p>This logs a <code>todo_saved</code> event with a timestamp parameter whenever a new task is saved.</p> <p>Warning</p> <p>The name of the custom events must be alphanumeric and can include underscores. They must not exceed 40 characters in length. For instance, <code>todo_saved</code> is valid, but <code>todo saved</code> is not.</p> <p>We can also add a navigatorsObserver to our MaterialApp widget to automatically log screen views:</p> <pre><code>// my_app.dart\n\nfinal FirebaseAnalytics _analytics = FirebaseAnalytics.instance;\n\n...\n\nchild: MaterialApp(\n// Previous properties...\nnavigatorObservers: [\nFirebaseAnalyticsObserver(analytics: _analytics)\n],\n...\n</code></pre>"},{"location":"U06%20Connectivity%20and%20remote%20applications/U06.4%20Analytics%20and%20Crashlytics/#firebase-crashlytics","title":"Firebase Crashlytics","text":"<p>Firebase Crashlytics is a real-time crash reporting tool that helps developers track, prioritize, and fix stability issues in their apps. It provides detailed reports on crashes, including stack traces and device information, making it easier to identify and resolve issues.</p>"},{"location":"U06%20Connectivity%20and%20remote%20applications/U06.4%20Analytics%20and%20Crashlytics/#adding-firebase-crashlytics-to-your-app","title":"Adding Firebase Crashlytics to Your App","text":"<p>he first step to add Firebase Crashlytics to your Flutter app is to add the necessary dependency. You can do this by running the following command in your terminal:</p> <pre><code>flutter pub add firebase_crashlytics\n</code></pre> <p>Next, run again the config command to ensure all Firebase dependencies are properly configured:</p> <pre><code>flutterfire configure\n</code></pre> <p>To enable Crashlytics in your app, you need to import the Firebase Crashlytics package and initialize it. You can do this in your <code>main.dart</code> file:</p> <pre><code>// main.dart\nimport 'package:firebase_crashlytics/firebase_crashlytics.dart';\n\nFuture&lt;void&gt; main() async {\nWidgetsFlutterBinding.ensureInitialized();\nawait Firebase.initializeApp(\noptions: DefaultFirebaseOptions.currentPlatform,\n);\n\n// Pass all uncaught errors from the framework to Crashlytics\nFlutterError.onError = FirebaseCrashlytics.instance.recordFlutterError;\n\nrunApp(MyApp());\n}\n</code></pre> <p>Done. Now, Firebase Crashlytics is set up to capture uncaught errors in your app.</p> <p>You can test Crashlytics by forcing a crash in your app, for example, commenting a line in wich a provider is added on your MultiProvider widget.</p> <p>But there is a better way to test it, by using the following code snippet:</p> <pre><code>FirebaseCrashlytics.instance.crash();\n</code></pre> <p>This will immediately crash the app and send a crash report to Firebase Crashlytics.</p>"},{"location":"U06%20Connectivity%20and%20remote%20applications/U06.5%20Connectivity/","title":"Unit 6.5 Connectivity","text":"<p>For now, our apps are able to store and retrieve data from a remote database. However, they do not handle changes in network connectivity. In this unit, we will learn how to detect changes in network connectivity and respond accordingly.</p>"},{"location":"U06%20Connectivity%20and%20remote%20applications/U06.5%20Connectivity/#checking-connectivity-status","title":"Checking connectivity status","text":"<p>we will use the <code>connectivity_plus</code> package to check the network connectivity status of the device. This package allows us to determine whether the device is connected to a Wi-Fi network, mobile data, or is offline.</p> <p>The following table shows which values are supported per platform:</p> <p></p> <p>To test connectivity we will create a project with a single screen that displays the current connectivity status.</p> <p>Add the dependency for <code>connectivity_plus</code>:</p> <pre><code>flutter pub add connectivity_plus\n</code></pre> <p>Now, we can create a simple app that checks the connectivity status and displays it on the screen:</p> <pre><code>import 'package:flutter/material.dart';\nimport 'package:connectivity_plus/connectivity_plus.dart';\n\nvoid main() {\nrunApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\nconst MyApp({super.key});\n\n@override\nWidget build(BuildContext context) {\nreturn MaterialApp(\nhome: ConnectivityScreen(),\n);\n}\n}\n\nclass ConnectivityScreen extends StatefulWidget {\nconst ConnectivityScreen({super.key});\n\n@override\nState&lt;ConnectivityScreen&gt; createState() =&gt; _ConnectivityScreenState();\n}\n\nclass _ConnectivityScreenState extends State&lt;ConnectivityScreen&gt; {\nString _connectionStatus = 'Unknown';\nfinal Connectivity _connectivity = Connectivity();\n\n@override\nvoid initState() {\nsuper.initState();\n_checkConnectivity();\n}\n\nFuture&lt;void&gt; _checkConnectivity() async {\nfinal List&lt;ConnectivityResult&gt; connectivityResult = await _connectivity.checkConnectivity();\nprint('Connectivity Result: $connectivityResult');\nsetState(() {\nif (connectivityResult.contains(ConnectivityResult.mobile)) {\n_connectionStatus = 'Connected to Mobile Network';\n} else if (connectivityResult.contains(ConnectivityResult.wifi)) {\n_connectionStatus = 'Connected to WiFi';\n//For Android, when both mobile and Wi-Fi are turned on system will return Wi-Fi only\n} else if (connectivityResult.contains(ConnectivityResult.ethernet)) {\n_connectionStatus = 'Connected to Ethernet';\n} else if (connectivityResult.contains(ConnectivityResult.vpn)) {\n_connectionStatus = 'Connected via VPN';\n// Note for iOS and macOS:\n// There is no separate network interface type for [vpn].\n// It returns [other] on any device (also simulator)\n} else if (connectivityResult.contains(ConnectivityResult.bluetooth)) {\n_connectionStatus = 'Connected via Bluetooth';\n} else if (connectivityResult.contains(ConnectivityResult.other)) {\n_connectionStatus = 'Connected via Other Network';\n} else if (connectivityResult.contains(ConnectivityResult.none)) {\n_connectionStatus = 'No Internet Connection';\n} else {\n_connectionStatus = 'No Internet Connection';\n}\n});\n}\n\n@override\nWidget build(BuildContext context) {\nreturn Scaffold(\nappBar: AppBar(\ntitle: Text('Connectivity Status'),\n),\nbody: Center(\nchild: Text(\n'Connection Status: $_connectionStatus',\nstyle: TextStyle(fontSize: 20),\n),\n),\nfloatingActionButton: FloatingActionButton(\nonPressed: _checkConnectivity,\nchild: Icon(Icons.refresh),\n),\n);\n}\n}\n</code></pre> <p>The code of the _checkConnectivity method is based on the example provided in the connectivity_plus documentation.</p> <p>Try changing the connectivity of your device (turning Wi-Fi and mobile data on and off) and see how the app responds each time you push the refresh button.</p> <p>We also can listen for connectivity changes in real-time by subscribing to the connectivity stream:</p> <pre><code>class _ConnectivityScreenState extends State&lt;ConnectivityScreen&gt; {\nString _connectionStatus = 'Unknown';\nfinal Connectivity _connectivity = Connectivity();\n\nStreamSubscription&lt;List&lt;ConnectivityResult&gt;&gt;? subscription;\n\n@override\nvoid initState() {\nsuper.initState();\n\nsubscription = Connectivity().onConnectivityChanged.listen((List&lt;ConnectivityResult&gt; result) {\nprint('Connectivity Changed: $result');\nsetState(() {\nif (result.contains(ConnectivityResult.mobile)) {\n_connectionStatus = 'Connected to Mobile Network';\n} else if (result.contains(ConnectivityResult.wifi)) {\n_connectionStatus = 'Connected to WiFi';\n} else if (result.contains(ConnectivityResult.ethernet)) {\n_connectionStatus = 'Connected to Ethernet';\n} else if (result.contains(ConnectivityResult.vpn)) {\n_connectionStatus = 'Connected via VPN';\n} else if (result.contains(ConnectivityResult.bluetooth)) {\n_connectionStatus = 'Connected via Bluetooth';\n} else if (result.contains(ConnectivityResult.other)) {\n_connectionStatus = 'Connected via Other Network';\n} else if (result.contains(ConnectivityResult.none)) {\n_connectionStatus = 'No Internet Connection';\n} else {\n_connectionStatus = 'No Internet Connection';\n}\n});\n});\n}\n\n@override\nvoid dispose() {\nsubscription?.cancel();\nsuper.dispose();\n}\n\n// Rest of the code...\n</code></pre> <p>Now, your app should automatically update the connectivity status whenever there is a change in the network connection.</p>"},{"location":"U07%20Introduction%20to%20game%20engines/U07.1%20Introduction%20to%20Game%20Engines/","title":"Unit 7.1 Introduction to Game Engines","text":"<p>In this unit, we will explore the concept of game engines, their significance in game development, and how they streamline the process of creating interactive experiences. We will also look at some popular game engines used in the industry today.</p>"},{"location":"U07%20Introduction%20to%20game%20engines/U07.1%20Introduction%20to%20Game%20Engines/#what-is-a-game-engine","title":"What is a Game Engine?","text":"<p>A game engine is a software framework designed to facilitate the development of video games. It provides developers with a suite of tools and features that simplify the process of creating, rendering, and managing game content. Game engines typically include components for graphics rendering, physics simulation, audio management, input handling, and more.</p>"},{"location":"U07%20Introduction%20to%20game%20engines/U07.1%20Introduction%20to%20Game%20Engines/#history-of-game-engines","title":"History of Game Engines","text":"<p>The concept of game engines dates back to the early days of video gaming. In the 1980s and 1990s, game developers began creating reusable code libraries to streamline the development process. As games became more complex, the need for comprehensive frameworks led to the emergence of dedicated game engines.</p> <p>In the late 1990s, engines like id Tech 1 (used in games like Doom and Quake), Build Engine (used in Duke Nukem 3D) and Unreal Engine 1 (used in Unreal Tournament) set the stage for modern game development. These engines provided developers with powerful tools to create immersive 3D environments and complex gameplay mechanics.</p> <p>In the 2000s, engines became the standard for game development, with companies like Epic Games releasing Unreal Engine 2 and Unreal Engine 3, and Valve developing the Source Engine. These engines introduced advanced graphics capabilities, improved physics simulations, and more robust development tools, enabling the creation of highly detailed and interactive game worlds.</p> <p>The emergence of Unity in 2005 marked a significant milestone in game engine history. Unity's user-friendly interface and cross-platform capabilities made it accessible to indie developers and hobbyists, democratizing game development.</p> <p>In the 2010s, game engines became available to everyone, with engines like Unreal Engine 4 and Unity 5 offering free versions for small developers. This era also saw the rise of mobile gaming, with engines like Cocos2d-x and Godot catering to mobile platforms.</p>"},{"location":"U07%20Introduction%20to%20game%20engines/U07.1%20Introduction%20to%20Game%20Engines/#key-features-of-game-engines","title":"Key Features of Game Engines","text":"<p>Game engines typically offer a range of features that facilitate game development, including:</p> <ul> <li>Graphics Rendering: Game engines provide tools for rendering 2D and 3D graphics, including support for shaders, lighting, and textures.</li> <li>Physics Simulation: Many engines include physics engines that simulate real-world physics, such as collision detection, rigid body dynamics, and fluid dynamics.</li> <li>Audio Management: Game engines often include audio systems for managing sound effects, music, and spatial audio.</li> <li>Input Handling: Engines provide support for various input devices, such as keyboards, mice, game controllers, and touchscreens.</li> <li>Scripting and Programming: Game engines typically support scripting languages (e.g., Lua, Python) or programming languages (e.g., C++, C#) to allow developers to create custom gameplay mechanics and logic.</li> <li>Asset Management: Game engines often include tools for managing game assets, such as models, textures, animations, and audio files.</li> <li>Level Design Tools: Many engines provide visual editors for designing game levels and environments.</li> <li>Cross-Platform Support: Many game engines support multiple platforms, allowing developers to create games that can run on various devices, such as PCs, consoles, and mobile devices.</li> <li>Networking: Some game engines include built-in support for multiplayer networking, enabling developers to create online multiplayer games.</li> <li>Artificial Intelligence: Game engines may provide tools for implementing AI behaviors, such as pathfinding and decision-making.</li> </ul>"},{"location":"U07%20Introduction%20to%20game%20engines/U07.1%20Introduction%20to%20Game%20Engines/#popular-game-engines","title":"Popular Game Engines","text":"<p>Some of the most widely used game engines in the industry today include:</p> <ul> <li>Unreal Engine: Developed by Epic Games, Unreal Engine is known for its high-fidelity graphics and robust toolset. It is widely used for AAA game development and supports a variety of platforms, including PC, consoles, and mobile devices. Uses a visual scripting system called Blueprints, making it accessible to non-programmers, but also supports C++ for more advanced development.</li> <li>Unity: Unity is a versatile and user-friendly engine that caters to both indie developers and large studios. It supports 2D and 3D game development and offers a vast asset store for developers to access pre-made assets and tools. The programming is primarily done in C#.</li> <li>Godot: An open-source game engine that has gained popularity for its flexibility and ease of use. Godot supports both 2D and 3D game development and has a dedicated community of developers. The programing language used is GDScript, which is similar to Python, but also supports C# and VisualScript.</li> <li>CryEngine: Known for its stunning graphics capabilities, CryEngine is used in games like Crysis and offers advanced rendering features and physics simulations. The primary programming language is C++, but it also supports Lua for scripting.</li> <li>Cocos2d-x: A popular engine for mobile game development, Cocos2d-x is lightweight and optimized for performance on mobile devices. The primary programming language is C++, but it also supports Lua and JavaScript.</li> <li>GameMaker Studio: A user-friendly engine that is ideal for 2D game development. It features a drag-and-drop interface and a scripting language called GameMaker Language (GML) for more advanced functionality.</li> <li>GDevelop: An open-source, cross-platform game engine designed for 2D game development. It features a visual programming interface and supports scripting in JavaScript.</li> </ul>"},{"location":"U07%20Introduction%20to%20game%20engines/U07.1%20Introduction%20to%20Game%20Engines/#godot-engine","title":"Godot Engine","text":"<p>Godot is an open-source game engine that has gained popularity for its flexibility and ease of use. It supports both 2D and 3D game development and has a dedicated community of developers. Godot uses its own scripting language called GDScript, which is similar to Python, but also supports C# and VisualScript.</p> <p>For this course we will be using the Godot Engine due to its accessibility, robust features, and supportive community. It is an excellent choice for both beginners and experienced developers looking to create engaging games.</p>"},{"location":"U07%20Introduction%20to%20game%20engines/U07.1%20Introduction%20to%20Game%20Engines/#installing-godot-engine","title":"Installing Godot Engine","text":"<p>Godot Engine does not require installation in the traditional sense. You can download the executable file for your operating system from the official Godot website. Once downloaded, simply run the executable to start using Godot.</p> <p>We will use the Godot Engine version 4.5.1 for this course. There are also a version for .NET developing, but we will use the standard version.</p> <p>The Godot Documentation can be found at: Godot Documentation</p>"},{"location":"U07%20Introduction%20to%20game%20engines/U07.1%20Introduction%20to%20Game%20Engines/#the-godot-interface","title":"The Godot interface","text":""},{"location":"U07%20Introduction%20to%20game%20engines/U07.1%20Introduction%20to%20Game%20Engines/#the-project-manager","title":"The Project Manager","text":"<p>When you first open Godot, you will see the Project Manager, where you can create new projects or open existing ones. From here, you can manage your projects, access templates, and configure settings.</p> <p></p> <p>You can also go to the Asset Library to download free assets and plugins created by the Godot community. The first time you go to this tab you'll see a \"Go Online\" button. For privacy reasons, the Godot project manager does not access the internet by default. To change this click the \"Go Online\" button. You can change this option later in the settings.</p> <p></p>"},{"location":"U07%20Introduction%20to%20game%20engines/U07.1%20Introduction%20to%20Game%20Engines/#the-editor-interface","title":"The Editor Interface","text":"<p>Once you create or open a project, you will be taken to the Godot Editor interface. The main components of the editor include:</p> <ul> <li>Top Toolbar: Located at the top of the interface, it contains buttons for common actions such as saving, running the project, and accessing settings:</li> <li>Main Menu: Located at the top of the interface, it provides access to various tools and options for managing your project.</li> <li>Workspace Panels: In the center. You can switch between different workspaces, such as 2D, 3D, Script, and Asset Library.</li> <li>Movie Maker Panel: Located on the right side, it contains tools for creating and managing scenes, nodes, and resources.</li> </ul> <p></p> <ul> <li>Scene tabs: Below the top toolbar, you will find tabs for different open scenes. You can switch between scenes by clicking on the tabs.</li> </ul> <p></p> <ul> <li>Viewport: The central area of the interface where you can view and edit your game scenes. The viewport changes depending on whether you are in 2D or 3D mode.</li> </ul> <p></p> <p>On both sides of the viewport sit the docks. And at the bottom of the window lies the bottom panel:</p> <ul> <li>Scene Dock: Located on the left side, it shows the hierarchy of nodes in the current scene. You can use this dock to add, remove, and organize nodes.   </li> <li>FileSystem Dock: Located on the left side, it displays the files and folders in your project. You can use this dock to manage your project assets. </li> <li>Inspector Dock: Located on the right side, it displays the properties of the selected node or resource. You can use this dock to modify the attributes of nodes and resources.   </li> <li>Bottom Panel: Located at the bottom of the interface, it contains various tabs for debugging, output, animation and other tools.     </li> </ul>"},{"location":"U07%20Introduction%20to%20game%20engines/U07.1%20Introduction%20to%20Game%20Engines/#workspaces","title":"Workspaces","text":"<p>Godot provides different workspaces tailored for specific tasks in game development. You can switch between these workspaces using the buttons in the top toolbar:</p> <ul> <li>2D Workspace: Used for creating and editing 2D game scenes. The viewport displays a 2D grid where you can place and manipulate 2D nodes.</li> <li>3D Workspace: Used for creating and editing 3D game scenes. The viewport displays a 3D environment where you can place and manipulate 3D nodes.</li> <li>Script Workspace: Used for writing and editing scripts. The viewport displays the script editor, where you can write code for your game.</li> <li>Asset Library Workspace: Used for browsing and downloading assets and plugins from the Godot Asset Library.</li> <li>Game Workspace: Used for running and testing your game. The viewport displays the game window where you can interact with your game.</li> </ul> <p>In the Script workspace, you can use the integrated class reference to look up information about Godot's built-in classes and functions. This can be accessed from the \"Search Help\" menu in the top toolbar.</p>"},{"location":"U07%20Introduction%20to%20game%20engines/U07.1%20Introduction%20to%20Game%20Engines/#integrating-godot-with-vs-code","title":"Integrating Godot with VS Code","text":"<p>To enhance your coding experience, you can integrate Godot with Visual Studio Code (VS Code). This allows you to use VS Code as your primary code editor while working on Godot projects.</p> <p>The fisrt step is to install the godot-tools (Geequlim) extension from the VS Code marketplace. This extension provides features such as syntax highlighting, code completion, and debugging support for Godot scripts.</p> <p></p> <p>Go to the extensions settings and enter the path of your Godot 4 executable file:</p> <p></p> <p>Go to the extension details and copy the Exec flags for Godot:</p> <p><code>{project} --goto {file}:{line}:{col}</code></p> <p>Now, go to Godot and open the Editor Settings from the top menu Editor -&gt; Editor Settings. In the settings window, navigate to Text Editor -&gt; External. Enable the Use External Editor option and paste the copied exec flags into the Exec Flags field. Finally, set the Exec Path to the path of your VS Code executable.</p> <p></p> <p>Now, when you open a script from Godot, it will launch VS Code with the selected script file.</p> <p>Other plugins that you can use in VSCode for Godot development are:</p> <ul> <li>godot-vscode-theme: A theme inspired by the Godot editor.</li> <li>Error Lens: Displays errors and warnings inline in the code editor.</li> </ul> <p>Task</p> <p>Search information about another game engine different from Godot, describing its main features and characteristics:</p> <ul> <li>Name and developer.</li> <li>License and pricing.</li> <li>Types of games it is used for (2D, 3D, RPG, educational, mobile, VR, etc.).</li> <li>Programming languages supported.</li> <li>Notable games developed with that engine.</li> <li>Community and resources available for learning.</li> <li>Advantages and disadvantages compared to other game engines.</li> </ul>"},{"location":"U08%20Videogames%20development/U08.1%20Introduction%20to%20GDScript/","title":"Unit 8.1 Introduction to GDScript","text":"<p>GDScript is a high-level, object-oriented, imperative, and gradually typed programming language created by Godot. It uses an indentation-based syntax similar to languages such as Python. Its goal is to optimize and tightly integrate with the Godot Engine, allowing great flexibility for the creation and integration of content.</p> <p>Official documentation</p> <p>Step by step tutorials</p> <p>Before continuing with this section, it is recommended to go through the Step by step tutorials in the Godot documentation, which will show you how to manage the Godot interface and create simple projects using GDScript.</p>"},{"location":"U08%20Videogames%20development/U08.1%20Introduction%20to%20GDScript/#the-first-script","title":"The first script","text":"<p>Let\u2019s take the script from Creating your first script in the Godot documentation.</p> <pre><code>extends Sprite2D\n\nvar speed = 400\nvar angular_speed = PI\n\nfunc _process(delta):\nrotation += angular_speed * delta\n\nvar velocity = Vector2.UP.rotated(rotation) * speed\n\nposition += velocity * delta\n</code></pre> <p>This script is associated with a Sprite2D node, which is why the first line, <code>extends Sprite2D</code>, inherits the functions (methods) and properties (variables) of the Sprite2D class. For example, the variables <code>rotation</code> and <code>position</code> are properties of the class, accessible from the Inspector (right panel).</p> <p>Next, we have two variables defined with the keyword <code>var</code>: <code>speed</code> and <code>angular_speed</code>. We will talk more about variables later.</p> <p>Finally, we have the <code>_process</code> function. A function is a block of code that has a name and can be called, which means its code can be executed every time we write its name. The code of GDScript functions is nested using indentation. In our example, the code consists of the following lines:</p> <pre><code>rotation += angular_speed * delta\n\nvar velocity = Vector2.UP.rotated(rotation) * speed\n\nposition += velocity * delta\n</code></pre> <p><code>_process</code> is a function already defined in the system, which means we can change its contents, but it has a special meaning. This particular function is executed every frame, about 60 times per second, which allows character movement, effects, key input reading, etc.</p> <p>The <code>_process</code> function has a parameter, <code>delta</code>, which is the time that has passed since the last frame. This parameter is a variable usually used to make changes occur at the same speed regardless of the <code>frame rate</code> or <code>fps</code> (frames per second). In our code, we multiply it by <code>rotation</code> and <code>position</code> so that the rotation speed is consistent.</p>"},{"location":"U08%20Videogames%20development/U08.1%20Introduction%20to%20GDScript/#comments","title":"Comments","text":"<p>Anything from a <code>#</code> to the end of the line is ignored and considered a comment.</p> <pre><code># This is a single-line comment\n</code></pre> <p>Multi-line comments can be created using <code>\"\"\"</code> (three consecutive quotes) at the beginning and end of a block of text. Keep in mind that this creates a string, so it will not be removed when the script is compiled.</p> <pre><code>\"\"\" This is\n a multi-line\n comment\n\"\"\"\n</code></pre>"},{"location":"U08%20Videogames%20development/U08.1%20Introduction%20to%20GDScript/#variables","title":"Variables","text":"<p>Variables are symbolic names that contain a value. For example:</p> <pre><code>var life = 100\n</code></pre> <p>means that we are creating (using the keyword <code>var</code>) a variable called life with the value <code>100</code>.</p> <p>Variables can be read:</p> <pre><code>var life = 100\nprint(life)\n</code></pre> <p>This will print the value <code>100</code>, which is stored in the variable <code>life</code>.</p> <p>We can also modify the contents of a variable once it has been created using the assignment operator (<code>=</code>). The right-hand side is always evaluated first and then assigned to the variable on the left-hand side:</p> <pre><code>var life = 100 # life has the value 100\nlife = 50 # life now has the value 50\n\nvar damage = 10\nlife = life - damage # Now life has the value 40 (50 - 10)\n</code></pre> <p>Variables have a type, which is the kind of data they store. The basic GDScript types are:</p> <ul> <li><code>null</code>: <code>null</code> is an empty data type that contains no information and cannot be assigned any other value.</li> <li><code>bool</code>: Short for \u201cboolean\u201d, it can only be <code>true</code> or <code>false</code>.</li> <li><code>int</code>: Short for \u201cinteger\u201d, it stores whole numbers (positive and negative).</li> <li><code>float</code>: Stores real numbers, including decimals, which are indicated with a dot (<code>.</code>).</li> <li><code>String</code>: A string of characters, enclosed in double quotes (<code>\"</code>).</li> </ul> <p>Type assignment is done automatically, depending on the value assigned. In addition, if the value of a variable changes to a different type, the type of the variable also changes.</p> <p>Examples:</p> <pre><code>var a = true # bool\nvar b = 5 # int\nvar c = 4.5 # float\nvar message = \"Welcome\" # String\nmessage = 5 # Now message is int\n</code></pre> <p>We can also explicitly declare the type of a variable using a colon (<code>:</code>):</p> <pre><code>var a: bool = true\nvar b: int = 5\nvar c: float = 4.5\nvar message: String = \"Welcome\"\n</code></pre> <p>This is known as static typing. It's recommended when we want to ensure that a variable always has the same type. If we try to assign a value of a different type, an error will occur.</p>"},{"location":"U08%20Videogames%20development/U08.1%20Introduction%20to%20GDScript/#casting","title":"Casting","text":"<p>When we work with static typing, we may need to convert a variable from one type to another. This is called casting.</p> <p>We can cast a variable by using the operator as followed by the desired type:</p> <pre><code>var a: int = 5\nvar b: float = a as float # b is now 5.0\nvar c: String = a as String # c is now \"5\"\n</code></pre> <p>Casting between object types results in the same object if the value is of the same type or a subtype of the cast type.</p> <pre><code>var my_node2D: Node2D\nmy_node2D = $Sprite2D as Node2D # Casts the Sprite2D node to Node2D type\nmy_node2D2 = $Button as Node2D # Results in 'null' since a Button is not a subtype of Node2D.\n</code></pre>"},{"location":"U08%20Videogames%20development/U08.1%20Introduction%20to%20GDScript/#operators","title":"Operators","text":"<p>The most common mathematical operators are:</p> <pre><code>x + y # addition\nx - y # subtraction\nx * y # multiplication\nx / y # division\nx % y # modulus, the result is the remainder of the integer division of x by y. Example: 8 % 3 = 2\n-x # negation\nx ** y # exponentiation, x raised to the power of y\n</code></pre> <p>The assignment operator <code>=</code> assigns to the variable on the left the resulting value of the operation on the right.</p> <pre><code>x = y # x equals y\nx += y # x = x + y\nx -= y # x = x - y\nx *= y # x = x * y\nx /= y # x = x / y\n</code></pre>"},{"location":"U08%20Videogames%20development/U08.1%20Introduction%20to%20GDScript/#constants","title":"Constants","text":"<p>Constants are variables that cannot change while the script is running. Using the keyword <code>const</code> allows you to give a name to a constant value. If you try to assign a value to a constant after declaring it, you will get an error.</p> <p>It is recommended to use constants whenever a value should not change. Example:</p> <pre><code>const height: int = 200\n\nfunc _ready():\nheight = 300\n</code></pre> <p>This code produces the error \"Cannot assign a new value to a constant\".</p>"},{"location":"U08%20Videogames%20development/U08.1%20Introduction%20to%20GDScript/#enums","title":"Enums","text":"<p>Enums (enumerations) are a way to define a set of named integer constants. They are useful for representing a collection of related values in a readable way.</p> <pre><code>enum Direction { UP, DOWN, LEFT, RIGHT }\nvar dir = Direction.UP\n</code></pre> <p>It is the same that:</p> <pre><code>const UP = 0\nconst DOWN = 1\nconst LEFT = 2\nconst RIGHT = 3\nvar dir = UP\n</code></pre> <p>You can give a name to the enum. This is equivalent to defining a class with static constants.</p> <pre><code>enum State {\nIDLE,\nRUNNING,\nJUMPING,\nATTACKING\n}\nvar current_state = State.IDLE\nprint(current_state) # Prints 0\nprint(State.keys()) # Prints [IDLE, RUNNING, JUMPING, ATTACKING]\nprint(State.values()) # Prints [0, 1, 2, 3]\n</code></pre>"},{"location":"U08%20Videogames%20development/U08.1%20Introduction%20to%20GDScript/#functions","title":"Functions","text":"<p>A function is a piece of code associated with a symbolic name that can be executed at any time by writing the function\u2019s name.</p> <p>The body of the function is defined by indentation to the right.</p> <p>Example:</p> <pre><code>func welcomeMessage():\n    var message = \"Welcome\"\n    print(message)\n\nwelcomeMessage() # Prints Welcome\n</code></pre> <p>In this example, the function name is <code>welcomeMessage</code>. It is followed by parentheses, inside which we write the parameters (in this case, there are none). The body of the function is the next two lines. Finally, the instruction <code>welcomeMessage()</code> executes the function, printing the message.</p> <p>Tip</p> <p>Functions are easy to distinguish from variables: functions always have parentheses at the end of their name, while variables do not.</p> <p>Functions can have 0, 1, or more parameters, to which we can pass values that will be used inside the function:</p> <pre><code>func welcomeMessage(name):\n    var message = \"Welcome \" + name\n    print(message)\n\nwelcomeMessage(\"Mary\") # Prints Welcome Mary\n</code></pre> <p>In this example, the <code>+</code> operator concatenates (joins) the two strings.</p> <p>Another example:</p> <pre><code>func addition(a, b):\n    var result = a + b\n    return result\n\naddition(5, 6) # Prints 11\n</code></pre> <p>The keyword <code>return</code> in a function returns the specified value and ends the execution of the function. If a function has no <code>return</code> instruction, it ends when it finishes and returns <code>null</code>.</p> <p>When we need to define a function but it has no body, we must write the keyword <code>pass</code>:</p> <pre><code>func empty_function():\npass\n</code></pre> <p>Similar to variables, functions can also have a type. This type indicates the type of value that the function will return. If the function does not return any value, its type is <code>void</code>.</p> <pre><code>func addition(a: int, b: int) -&gt; int:\nvar result: int = a + b\nreturn result\n</code></pre>"},{"location":"U08%20Videogames%20development/U08.1%20Introduction%20to%20GDScript/#system-functions","title":"System functions","text":"<p>Godot has some predefined functions that we can use in our scripts. Their names usually start with <code>_</code>. The most important ones are:</p> <ul> <li><code>_init()</code>: Called once when the script starts executing. It runs before <code>_ready()</code>. It belongs to the <code>Object</code> class.</li> <li><code>_enter_tree()</code>: Called when the node enters the scene tree. It is executed before <code>_ready()</code>. It belongs to the <code>Node</code> class.</li> <li><code>_ready()</code>: Called when the node is \u201cready\u201d, that is, when both the node and its children have entered the scene tree. It is executed once at the beginning. It is usually used to initialize variables. It belongs to the <code>Node</code> class.</li> <li><code>_process(delta)</code>: Called every frame. The <code>delta</code> argument is the time elapsed since the last frame (in seconds). It is used to implement the game loop in each scene.</li> <li><code>_physics_process(delta)</code>: Called every physics processing frame. Similar to <code>_process</code>, but used for objects that have physical behavior (gravity, forces, etc.).</li> <li><code>_exit_tree()</code>: Called when the node is removed from the scene tree. It is used to clean up resources or stop processes related to the node.</li> </ul> <p></p>"},{"location":"U08%20Videogames%20development/U08.1%20Introduction%20to%20GDScript/#flow-control","title":"Flow control","text":""},{"location":"U08%20Videogames%20development/U08.1%20Introduction%20to%20GDScript/#conditional-operators","title":"Conditional operators","text":"<p>These are operators whose result is <code>true</code> or <code>false</code>:</p> <pre><code>x == y # true if x and y are equal\nx != y # true if x and y are different\nx &lt; y # true if x is less than y\nx &gt; y # true if x is greater than y\nx &lt;= y # true if x is less than or equal to y\nx &gt;= y # true if x is greater than or equal to y\nnot x # negation of the value of x, true or false\n!x # same as not x\n</code></pre> <p>We can combine multiple conditions using the operators <code>and</code> (<code>&amp;&amp;</code>) and <code>or</code> (<code>||</code>).</p> <pre><code>x and y # true if both x and y are true\nx &amp;&amp; y # same as x and y\nx or y # true if either value is true\nx || y # same as x or y\n</code></pre> <p>Examples:</p> <pre><code>var a = 5\nvar b = 2\nvar c = 3\n\na == b # false\na != c # true\na == b + c # true\na &lt; b # false\nc &gt; b # true\na &lt;= b + c # true\n!(a == b) # true\na &gt; b and b &lt; c # true\na &gt; b &amp;&amp; b &gt;= c # false\na &gt; b or b &lt; c # true\na &gt; b || b &gt;= c # true\na &lt; b or b &gt;= c # false\nnot (a &lt; b or b &gt;= c) # true\n</code></pre>"},{"location":"U08%20Videogames%20development/U08.1%20Introduction%20to%20GDScript/#ifelse","title":"if/else","text":"<p>Simple conditions are created using the <code>if</code>/<code>else</code> syntax.</p> <p>The most basic syntax is:</p> <pre><code>if condition:\n    code block\n</code></pre> <p>In the condition, expressions like those seen in the previous section are used, whose result must be <code>true</code> or <code>false</code>. If the result is <code>true</code>, the <code>if</code> code block is executed. If the result is <code>false</code>, nothing is executed and the program continues.</p> <p>Example:</p> <pre><code>var a = 5\nvar b = 6\n\nif a &lt; b:\n   print(\"a is less than b\")\n</code></pre> <p>We can use the keyword <code>else</code> to specify the code that will be executed if the condition is <code>false</code>:</p> <pre><code>if condition:\n    code block A\nelse:\n    code block B\n</code></pre> <p>Example:</p> <pre><code>var a = 5\nvar b = 6\n\nif a &lt; b:\n   print(\"a is less than b\")\nelse:\n   print(\"a is greater than or equal to b\")\n</code></pre> <p>If we have more than two conditions, we can evaluate those that do not meet the first one by adding <code>elif</code> statements:</p> <pre><code>var a = 5\nvar b = 6\n\nif a &lt; b:\n   print(\"a is less than b\")\nelif a &gt; b:\n    print(\"a is greater than b\")\nelse:\n   print(\"a and b are equal\")\n</code></pre>"},{"location":"U08%20Videogames%20development/U08.1%20Introduction%20to%20GDScript/#match","title":"match","text":"<p>The <code>match</code> statement is similar to the <code>switch</code> statement in other programming languages. It allows you to compare a value against multiple possible cases and execute the corresponding code block for the matching case.</p> <pre><code>match x:\n1:\nprint(\"Number one!\")\n2:\nprint(\"Number two!\")\n_:\nprint(\"Any other number\") # Default case\n</code></pre>"},{"location":"U08%20Videogames%20development/U08.1%20Introduction%20to%20GDScript/#while-loops","title":"<code>while</code> loops","text":"<p>Loops are used to execute the same action while a condition is met.</p> <p>The simplest loop is <code>while</code>:</p> <pre><code>while (condition):\n    instructions\n</code></pre> <p>For example:</p> <pre><code>var n = 0 # Initialize the counter variable n to 0\n\n# This loop prints the numbers from 0 to 9\nwhile (n &lt; 10):\n    print(n)\n    n += 1\n</code></pre>"},{"location":"U08%20Videogames%20development/U08.1%20Introduction%20to%20GDScript/#for-loops","title":"<code>for</code> loops","text":"<p><code>for</code> loops are mainly used to iterate over an array:</p> <pre><code>var names = [\"John\", \"Marta\", \"Samantha\", \"Jimmy\"]\n\nfor name in names: \n    print(name) # Prints all the names in the array\n</code></pre> <p>In the previous example, we have an array called names, which we iterate over with <code>for name in names</code>; the variable name takes the value of each element in the names array.</p>"},{"location":"U08%20Videogames%20development/U08.1%20Introduction%20to%20GDScript/#arrays","title":"Arrays","text":"<p><code>arrays</code> are sequences of variables or objects.</p> <p>We can create an empty array or one with elements:</p> <pre><code>var numbers = [] # Array with no elements\nvar fruits = ['apple', 'orange', 'banana'] # Array with 3 elements\n</code></pre> <p>We can read the value of an element using its index. The first element has index 0:</p> <pre><code>var fruits = ['apple', 'orange', 'banana']\nprint(fruits[0]) # Prints apple\nprint(fruits[2]) # Prints banana\n</code></pre> <p>Using the <code>.size()</code> method we get the number of elements in an array:</p> <pre><code>var fruits = ['apple', 'orange', 'banana']\nprint(fruits.size()) # Prints 3\nprint(fruits[fruits.size() - 1]) # Prints the last element\n</code></pre> <p>We can use the value of <code>size</code> to iterate over the array:</p> <pre><code>var fruits = ['apple', 'orange', 'banana']\nfor i in range(fruits.size()):\n    print(fruits[i]) # Prints all the fruits\n</code></pre> <p>Arrays can grow automatically each time we add an element. We can do this with the <code>append</code> function:</p> <p><pre><code>var fruits = ['apple', 'orange', 'banana']\nfruits.append('tomato')\nprint(fruits.size()) # Prints 4\nprint(fruits[fruits.size() - 1]) # Prints tomato\n</code></pre> Since Godot 4.0, GDScript also supports typed arrays. To create a typed array, we use the syntax <code>Array&lt;Type&gt;</code>:</p> <pre><code>var int_array: Array[int] = [1, 2, 3]\nvar string_array: Array[String] = [\"apple\", \"banana\", \"cherry\"]\nint_array.append(4) # Valid\nstring_array.append(\"date\") # Valid\nint_array.append(\"five\") # Error: Cannot add a String to an Array[int]\n</code></pre>"},{"location":"U08%20Videogames%20development/U08.1%20Introduction%20to%20GDScript/#dictionaries","title":"Dictionaries","text":"<p>Dictionaries are collections of key-value pairs, where each key is unique and is used to access its corresponding value.</p> <p>We can create an empty dictionary or one with elements:</p> <pre><code>var empty_dict = {} # Empty dictionary\nvar person = {'name': 'John', 'age': 30, 'city': 'New York'} # Dictionary with 3 key-value pairs\n</code></pre> <p>We can read the value associated with a key:</p> <pre><code>var person = {'name': 'John', 'age': 30, 'city': 'New York'}\nprint(person['name']) # Prints John\nprint(person['age']) # Prints 30\n</code></pre> <p>To add a new key-value pair, we can use the assignment operator:</p> <pre><code>var person = {'name': 'John', 'age': 30}\nperson['city'] = 'New York' # Adds a new key-value pair\nprint(person['city']) # Prints New York\n</code></pre> <p>The key can be string, integer, or any other type.</p> <p>Since Godot 4.4, GDScript also supports typed dictionaries. To create a typed dictionary, we use the syntax <code>Dictionary&lt;KeyType, ValueType&gt;</code>:</p> <pre><code>var dict: Dictionary[String, int] = {'one': 1, 'two': 2}\ndict['three'] = 3 # Valid\ndict['four'] = 'four' # Error: Cannot add a String value to a Dictionary[String, int]\n</code></pre>"},{"location":"U08%20Videogames%20development/U08.1%20Introduction%20to%20GDScript/#classes","title":"Classes","text":"<p>By default, all script files are unnamed classes. In this case, you can only reference them using the file's path, using either a relative or an absolute path:</p> <pre><code>var my_script = load(\"res://path/to/your_script.gd\").new()\n</code></pre> <p>You can give a name to a class using the <code>class_name</code> keyword at the top of the script file:</p> <pre><code>class_name Enemy extends Node2D\n\nvar health = 100\n\nfunc take_damage(amount):\nhealth -= amount\n</code></pre> <p>You can optionally use the <code>@icon</code> annotation to assign an icon to the class in the Godot editor:</p> <pre><code>@icon(\"res://path/to/icon.png\")\nclass_name Enemy extends Node2D\n</code></pre> <p>Now, you can create instances of the class using its name directly:</p> <pre><code>var enemy = Enemy.new()\nenemy.take_damage(20)\nprint(enemy.health) # Prints 80\n</code></pre> <p>Named classes are globally accessible throughout the project, without needing to load them using their file path.</p> <p>public vs. private</p> <p>By default, all variables and functions in GDScript are public, meaning they can be accessed from outside the class. To denote that a variable or function is private (accessible only within the class), you can prefix its name with an underscore (<code>_</code>):</p>"},{"location":"U08%20Videogames%20development/U08.1%20Introduction%20to%20GDScript/#class-constructors","title":"Class constructors","text":"<p>A class can have a constructor function named <code>_init()</code>, which is called when an instance of the class is created. You can define parameters for the constructor to initialize the instance with specific values:</p> <pre><code>class_name Enemy extends Node2D\nvar health: int\nfunc _init(initial_health: int = 100):\nhealth = initial_health\n</code></pre>"},{"location":"U08%20Videogames%20development/U08.1%20Introduction%20to%20GDScript/#built-in-classes","title":"Built-in classes","text":"<p>GDScript includes many built-in classes that provide useful functionality for game development. Some commonly used built-in classes are:</p> <ul> <li><code>Node</code>: The base class for all nodes in the scene tree. Provides functionality for managing child nodes, signals, and more.</li> <li><code>Vector2</code>: Represents a 2D vector with <code>x</code> and <code>y</code> components. Useful for positions, directions, and velocities in 2D space.</li> <li><code>Vector3</code>: Represents a 3D vector with <code>x</code>, <code>y</code>, and <code>z</code> components. Useful for positions, directions, and velocities in 3D space.</li> <li><code>Color</code>: Represents a color with red, green, blue, and alpha components.</li> <li><code>Rect2</code>: Represents a rectangle in 2D space, defined by its position and size.</li> <li><code>Transform2D</code>: Represents a 2D transformation, including translation, rotation, and scaling.</li> <li><code>Transform3D</code>: Represents a 3D transformation, including translation, rotation, and scaling.</li> <li><code>Quaternion</code>: Represents a quaternion, used for rotations in 3D space.</li> <li><code>Sprite2D</code>: A node that displays a 2D image (texture) in the scene.</li> <li><code>KinematicBody2D</code>: A node used for 2D physics-based movement and collision detection.</li> <li><code>Area2D</code>: A node that detects when other bodies enter or exit its area, useful for triggers and zones.</li> <li><code>Timer</code>: A node that can be used to create timed events and delays in your game logic.</li> <li><code>AudioStreamPlayer</code>: A node that plays audio streams, such as sound effects and music.</li> <li><code>AnimationPlayer</code>: A node that manages and plays animations for various properties of nodes.</li> </ul> <p>You can find more information about built-in classes in the Godot documentation.</p>"},{"location":"U08%20Videogames%20development/U08.1%20Introduction%20to%20GDScript/#signals","title":"Signals","text":"<p>Signals are a messaging system used in Godot to allow nodes to communicate with each other. They are similar to events or callbacks in other programming languages.</p> <p>Signals are defined in a class and can be emitted (triggered) when a specific event occurs. Other nodes can connect to these signals and define functions (callbacks) that will be executed when the signal is emitted.</p> <p>Example of defining and emitting a signal:</p> <pre><code># player.gd\n\nclass_name Player extends Node2D\n\nsignal health_changed\n\nvar health: int = 100\n\nfunc take_damage(amount: int):\nhealth -= amount\nhealth_changed.emit(health) # Emit the signal when health changes\n</code></pre> <p>This can be connected to another node:</p> <pre><code># ui.gd\n\nclass_name UI extends Control\n\nfunc _ready():\nvar player = get_node(\"/root/Player\")\nplayer.connect(\"health_changed\", self, \"_on_health_changed\")\n\nfunc _on_health_changed(new_health: int):\nprint(\"Player health changed to: \" + str(new_health))\n</code></pre>"},{"location":"U08%20Videogames%20development/U08.2%20Basic%20movement/","title":"Unit 8.2 Basic movement","text":"<p>In this section, we will explore the fundamental concepts of basic movement in videogame development. Understanding how to implement character movement is crucial for creating engaging and interactive games.</p>"},{"location":"U08%20Videogames%20development/U08.2%20Basic%20movement/#player-scene-setup","title":"Player scene setup","text":"<p>To begin, create in the filesystem panel a new folder named <code>Player</code>. Inside this folder, create a new folder named <code>Sprites</code>. Import the sprite named <code>Idle_000.png</code> into the <code>Sprites</code> folder. </p> <p></p> <p>Create a new CharacterBody2D scene and save it as <code>Player.tscn</code> in the <code>Player</code> folder.</p> <p>Create inside the Player a new Sprite2D node as a child of the CharacterBody2D node. Assign the <code>Idle_000.png</code> sprite to the Texture property of the Sprite2D node.</p> <p>Create a new CollisionShape2D node as a child of the CharacterBody2D node. In the Shape property of the CollisionShape2D node, create a new RectangleShape2D and adjust its size to fit the sprite.</p> <p>Scale the CharacterBody2D node to <code>0.3</code> in both the X and Y axes to make the player smaller. Do that in the Transform -&gt; Scale section of the Player main node.</p> <p></p>"},{"location":"U08%20Videogames%20development/U08.2%20Basic%20movement/#game-basic-setup","title":"Game basic setup","text":"<p>Before creating the first scene, we need to set up some basic game settings. Go to Project &gt; Project Settings and in the Display &gt; Window section, set the Width to <code>1024</code> and the Height to <code>576</code>.</p> <p>Also, under the Stretch options, set Mode to <code>canvas_items</code> and Aspect to <code>keep</code>. This ensures that the game scales consistently on different sized screens.</p> <p></p> <p>Go to the Input Map tab and add the following actions with their corresponding key bindings:</p> <ul> <li><code>move_right</code>: Right Arrow, D</li> <li><code>move_left</code>: Left Arrow, A</li> <li><code>move_up</code>: Up Arrow, W</li> <li><code>move_down</code>: Down Arrow, S</li> <li><code>jump</code>: Space</li> <li><code>attack</code>: Control</li> </ul> <p></p>"},{"location":"U08%20Videogames%20development/U08.2%20Basic%20movement/#main-scene-setup","title":"Main scene setup","text":"<p>For now, we will create a simple main scene with only the player character. Create a new scene with a Node2D as the root node and save it as <code>Main.tscn</code> in the <code>res://</code> folder.</p> <p>Import the Player scene into the Main scene by dragging and dropping the <code>Player.tscn</code> file from the filesystem panel into the scene tree, or with the Instance Child Scene button.</p>"},{"location":"U08%20Videogames%20development/U08.2%20Basic%20movement/#basic-movement","title":"Basic movement","text":"<p>In this section, we will implement basic movement for the player character using GDScript.</p>"},{"location":"U08%20Videogames%20development/U08.2%20Basic%20movement/#basic-movement-script","title":"Basic movement script","text":"<p>Attach a new script to the CharacterBody2D node of the Player scene and name it <code>Player.gd</code>. Open the script and add the following code to implement basic movement:</p> <pre><code>extends CharacterBody2D\n\nvar speed = 200\n\nfunc _process(delta):\nif Input.is_action_pressed(\"move_right\"):\nposition.x += speed * delta\nif Input.is_action_pressed(\"move_left\"):\nposition.x -= speed * delta\nif Input.is_action_pressed(\"move_down\"):\nposition.y += speed * delta\nif Input.is_action_pressed(\"move_up\"):\nposition.y -= speed * delta\n</code></pre> <p>Run the game starting from the Main scene (or set it as the main scene). You should be able to move the player character using the arrow keys or WASD keys.</p> <p>Basically, this code checks for input actions and updates the player's position accordingly. The <code>speed</code> constant determines how fast the player moves. The <code>delta</code> parameter ensures that the movement is consistent regardless of the frame rate.</p> <p>Info</p> <p><code>delta</code> is the time elapsed since the last frame, which helps in making movement smooth and frame-rate independent.</p> <p>To check with different speeds, you can add a <code>@export</code> annotation to the <code>speed</code> variable and change its value from the editor:</p> <pre><code>@export var speed = 200\n</code></pre>"},{"location":"U08%20Videogames%20development/U08.2%20Basic%20movement/#moving-with-movetoward","title":"Moving with <code>move.toward()</code>","text":"<p>Instead of change the position directly, we can use the <code>move_toward()</code> function to move the player smoothly towards a target position. Update the <code>_process</code> function as follows:</p> <pre><code>func _process(delta):\nvar target_position = position\n\nif Input.is_action_pressed(\"move_right\"):\ntarget_position.x += speed * delta\nif Input.is_action_pressed(\"move_left\"):\ntarget_position.x -= speed * delta\nif Input.is_action_pressed(\"move_down\"):\ntarget_position.y += speed * delta\nif Input.is_action_pressed(\"move_up\"):\ntarget_position.y -= speed * delta\n\nposition = position.move_toward(target_position, speed * delta)\n</code></pre> <p>This method moves the player towards the <code>target_position</code> at the specified speed, resulting in smoother movement.</p>"},{"location":"U08%20Videogames%20development/U08.2%20Basic%20movement/#moving-with-lerp","title":"Moving with lerp","text":"<p>Another way to achieve smooth movement is by using linear interpolation (lerp). Update the <code>_process</code> function as follows:</p> <pre><code>func _process(delta):\nvar target_position = position\n\nif Input.is_action_pressed(\"move_right\"):\ntarget_position.x += speed * delta\nif Input.is_action_pressed(\"move_left\"):\ntarget_position.x -= speed * delta\nif Input.is_action_pressed(\"move_down\"):\ntarget_position.y += speed * delta\nif Input.is_action_pressed(\"move_up\"):\ntarget_position.y -= speed * delta\n\nposition = position.lerp(target_position, 1.0)\n</code></pre> <p>The method <code>lerp()</code> interpolates between the current position and the target position based on a weight factor (in this case, <code>1.0</code> for full interpolation). You can adjust the weight factor to control the smoothness of the movement.</p>"},{"location":"U08%20Videogames%20development/U08.2%20Basic%20movement/#moving-with-tween","title":"Moving with <code>tween</code>","text":"<p>Tweens provide another way to create smooth transitions. It creates a transition between the current position and the target position over a specified duration. Here's some examples:</p> <pre><code>func _ready() -&gt; void:\nvar tween = create_tween()\ntween.tween_property(self, \"position:x\", position.x + 200, 1)\n# This will move the player 200 pixels to the right over 1 second\n</code></pre> <p>We can add transitions and easing to the movement as well:</p> <pre><code>func _ready() -&gt; void:\nvar tween = create_tween()\ntween.tween_property(self, \"position:x\", position.x + 200, 1).set_trans(Tween.TRANS_ELASTIC).set_ease(Tween.EASE_OUT)\n# This will move the player 200 pixels to the right over 1 second with elastic easing\n</code></pre> <p>We can chain multiple tweens together:</p> <pre><code>func _ready() -&gt; void:\nvar tween = create_tween().set_parallel(true) # Enable parallel execution\ntween.tween_property(self, \"position:x\", position.x + 200, 1)\ntween.tween_property(self, \"position:y\", position.y + 100, 1)\ntween.set_parallel(false) # Disable parallel execution\n</code></pre> <p>We can make tweens for another properties too, as the alpha channel of the modulate color or the rotation:</p> <pre><code>func _ready() -&gt; void:\nvar tween = create_tween()\ntween.tween_property(self, \"modulate:a\", 0.0, 2.0)\n# This will fade out the player over 2 seconds\n</code></pre> <p>The rotation:</p> <pre><code>func _ready() -&gt; void:\nvar tween = create_tween()\ntween.tween_property(self, \"rotation_degrees\", rotation + 90, 1.0)\n# This will rotate the player 90 degrees over 1 second\n</code></pre> <p>The scale:</p> <pre><code>func _ready() -&gt; void:\nvar tween = create_tween()\ntween.tween_property(self, \"scale\", Vector2(2, 2), 1.0)\n# This will scale the player to double size over 1 second\n</code></pre> <p>References:</p> <ul> <li>Tween documentation</li> <li>Tween cheat sheet</li> </ul>"},{"location":"U08%20Videogames%20development/U08.2%20Basic%20movement/#move_and_slide","title":"move_and_slide()","text":"<p>For more complex movement, especially when dealing with physics and collisions, we can use the <code>move_and_slide()</code> method. This method is particularly useful for characters that need to interact with the environment, such as walking on platforms or sliding down slopes.</p> <p>Important</p> <p>To use <code>move_and_slide()</code>, the player character must be a CharacterBody2D node.</p> <pre><code>extends CharacterBody2D\n\n@export var speed: float = 300.0\n\nfunc _physics_process(delta: float) -&gt; void:\n# Get the input direction and handle the movement/deceleration.\nvar horizontal := Input.get_axis(\"move_left\", \"move_right\")\nif horizontal:\nvelocity.x = horizontal * speed\nelse:\nvelocity.x = move_toward(velocity.x, 0, speed)\n\nvar vertical := Input.get_axis(\"move_up\", \"move_down\")\nif vertical:\nvelocity.y = vertical * speed\nelse:\nvelocity.y = move_toward(velocity.y, 0, speed)\n\nvelocity = velocity.normalized() * speed # Ensure consistent speed in all directions\nmove_and_slide()\n</code></pre> <p>speed and velocity</p> <p>In this code, <code>speed</code> is the maximum speed of the player, while <code>velocity</code> is a built-in property of <code>CharacterBody2D</code> that represents the current movement speed and direction of the character.</p> <p>To simulate pyhsics in a platform environment, you can add gravity and jumping mechanics as follows:</p> <pre><code>extends CharacterBody2D\n\n@export var speed: float = 300.0\n@export var jump_velocity: float = -400.0\n\nfunc _physics_process(delta: float) -&gt; void:\n# Add the gravity.\nif not is_on_floor():\nvelocity += get_gravity() * delta\n\n# Handle jump.\nif Input.is_action_just_pressed(\"jump\") and is_on_floor():\nvelocity.y = jump_velocity\n\nvar horizontal := Input.get_axis(\"move_left\", \"move_right\")\nif horizontal:\nvelocity.x = horizontal * speed\nelse:\nvelocity.x = move_toward(velocity.x, 0, speed)\n\nmove_and_slide()\n</code></pre> <p>Info</p> <ul> <li><code>get_gravity()</code> retrieves the gravity value defined in the project settings, which affects the vertical movement of the character.</li> <li><code>is_on_floor()</code> checks if the character is currently on the ground, which is essential for implementing jumping mechanics.</li> </ul> <p>To prevent the charcater from falling off the screen, add to the Main scene a new StaticBody2D node as a child of the root node. Add a CollisionShape2D node as a child of the StaticBody2D node and set its shape to a RectangleShape2D that covers the bottom of the screen. Name it <code>Floor</code>.</p> <p></p> <p>The <code>move_and_slide()</code> method is intended to simplify the collision response in the common case where you want one body to slide along the other. It is especially useful in platformers or top-down games. It moves the body based on velocity. If the body collides with another, it will slide along the other body (by default only on floor) rather than stop immediately.</p> <p>It could be a good idea to flip the player sprite when moving left. You can do this by modifying the scale of the Sprite2D node based on the movement direction:</p> <pre><code>func _physics_process(delta: float) -&gt; void:\n#Flip horizontally\nif horizontal != 0:\nscale.x = scale.y * horizontal\n</code></pre> <p>Question</p> <p>What happens if you use an analog gamepad? Probably the flip will not work as expected, because the horizontal input might be a value between -1 and 1, not just -1, 0, or 1. How can you fix it? Hint: use the <code>ceil()</code> function.</p>"},{"location":"U08%20Videogames%20development/U08.2%20Basic%20movement/#move_and_collide","title":"move_and_collide()","text":"<p>For scenarios where you need to handle collisions more explicitly, you can use the <code>move_and_collide()</code> method. This method moves the character and returns information about any collision that occurs during the movement.</p> <p>In your Player script, change move_and_slide() to move_and_collide() as follows:</p> <pre><code>    var collision = move_and_collide(velocity * delta)\nif collision:\nprint(\"Collided with: \", collision.get_collider())\n</code></pre> <p>You can see how the character collides with the floor and prints the collider information to the output console, but it won't slide along the floor like with <code>move_and_slide()</code>. This method is useful when you need to handle specific collision responses manually.</p> <p>To add sliding behavior, you can modify the velocity based on the collision normal:</p> <pre><code>    var collision = move_and_collide(velocity * delta)\nif collision:\nvar normal = collision.get_normal()\nvelocity = velocity.slide(normal)\n</code></pre> <p><code>move_and_collide()</code> moves the body along the vector motion. It returns a <code>KinematicCollision2D</code> object if a collision occurs, or null if no collision occurs. This object contains information about the collision, such as the collider, collision point, and normal.</p> <p>The next table shows when is better to use each method:</p> Method Use Case <code>move_and_slide()</code> Best for characters that need to interact with the environment, such as walking on platforms or sliding down slopes. It automatically handles sliding along surfaces. Ideal for platformers. <code>move_and_collide()</code> Best for scenarios where you need to handle collisions explicitly and want to control the response to collisions manually. It provides detailed collision information. A ball bouncing off walls is a good example."},{"location":"U08%20Videogames%20development/U08.2%20Basic%20movement/#moving-physics-bodies","title":"Moving physics bodies","text":"<p>To show how to move physics bodies, create a new scene with a RigidBody2D as the root node and save it as <code>Bird.tscn</code>, inside a new folder named <code>Enemies</code>. Add inside a Sprite2D node and a CollisionShape2D node as children of the RigidBody2D node. Assign a bird sprite to the Texture property of the Sprite2D node and set the shape of the CollisionShape2D node to a CapsuleShape2D that fits the sprite.</p> <p></p> <p>Instantiate the Bird scene into the Main scene. Play the game. You will see how the bird falls due to gravity and collides with the floor. Now, you can change the RigidBody2D properties in the inspector to modify its behavior, such as mass, friction, and bounce. Add a PhysicsMaterial2D to the Physics Material Override property of the RigidBody2D node to adjust friction and bounce more easily. Mark also the <code>Lock Rotation</code> property (inside <code>Deactivation</code>) to prevent the bird from rotating when colliding.</p> <p>Add a script to the RigidBody2D node to make the bird move horizontally:</p> <pre><code>extends RigidBody2D\n\n@export var speed: float = 200.0\n\nfunc _physics_process(delta: float) -&gt; void:\n# Apply a constant horizontal velocity\nlinear_velocity.x = speed\n</code></pre> <p>This add a constant horizontal velocity to the bird, making it move to the right while still being affected by gravity and collisions.</p> <p>Instead of setting the <code>linear_velocity</code> directly, you can apply forces to the RigidBody2D to achieve movement. Here's an example of how to do that:</p> <pre><code>extends RigidBody2D\n\n@export var force_magnitude: float = -500.0\n\nfunc _physics_process(delta: float) -&gt; void:\n# Apply a constant force to the right\napply_central_force(Vector2(force_magnitude, 0))\n</code></pre> <p>To see how forces affect the RigidBody2D, you can set the Gravity Scale property to <code>0</code> in the inspector, so the bird won't fall due to gravity.</p> <p>Other methods to move a RigidBody2D are:</p> <ul> <li><code>apply_central_impulse(impulse: Vector2)</code>: Applies an instantaneous change in velocity (impulse) at the center of mass of the body.</li> <li><code>apply_force(force: Vector2, position: Vector2)</code>: Applies a force at a specific position on the body.</li> <li><code>apply_impulse(impulse: Vector2, position: Vector2)</code>: Applies an instantaneous change in velocity (impulse) at a specific position on the body.</li> <li><code>apply_torque(torque: float)</code>: Applies a torque (rotational force) to the body.</li> <li><code>apply_torque_impulse(torque_impulse: float)</code>: Applies an instantaneous change in angular velocity (torque impulse) to the body.</li> </ul> <p>Differences between forces and impulses</p> <ul> <li>Forces are applied continuously over time, affecting the body's acceleration.</li> <li>Impulses are applied instantaneously, causing an immediate change in velocity.</li> </ul> <p>If the RigidBody2D is the player character, we can move it based on player input as follows:</p> <pre><code>extends RigidBody2D\n\n@export var speed: float = 500.0\n\nfunc _physics_process(_delta: float) -&gt; void:\nvar input_vector := Vector2(\nInput.get_axis(\"move_left\", \"move_right\"),\nInput.get_axis(\"move_up\", \"move_down\")\n).normalized()\n\napply_central_force(input_vector * speed)\n</code></pre> <p>Try applying impulses instead of forces and changing the gravity scale to <code>0</code> to see how it affects the movement.</p> <p>The next script simulates a platformer character using a RigidBody2D, with horizontal movement and jumping (with gravity):</p> <pre><code>extends RigidBody2D\n\n@export var speed: float = 5000.0\n@export var jump_impulse: float = -800.0\n\nfunc _physics_process(_delta: float) -&gt; void:\nvar input_vector := Vector2(\nInput.get_axis(\"move_left\", \"move_right\"),\n0\n).normalized()\n\napply_central_force(input_vector * speed)\n\nif Input.is_action_just_pressed(\"jump\"):\napply_central_impulse(Vector2(0, jump_impulse))\n</code></pre> <p>To detect if is on the floor, you can use raycasts or area2D nodes with collision shapes to check for ground contact before allowing jumps.</p>"},{"location":"U08%20Videogames%20development/U08.3%20Animations/","title":"Unit 8.3 Animations","text":"<p>In this unit, we will explore the fundamentals of 2D animations with Godot Engine. Animations are essential for bringing characters and environments to life in video games. First, we will use the node <code>AnimatedSprite2D</code> to create simple frame-by-frame animations. Then, we will delve into the <code>AnimationPlayer</code> node, which allows for more complex animations, including property animations and timelines.</p>"},{"location":"U08%20Videogames%20development/U08.3%20Animations/#animatedsprite2d","title":"AnimatedSprite2D","text":"<p>The <code>AnimatedSprite2D</code> node is used to create frame-by-frame animations using a sprite sheet or individual frames. We are going to create a simple character animation using <code>AnimatedSprite2D</code> for a collectable coin.</p> <ol> <li>Create a new scene and add a <code>Node2D</code> as the root node. Rename it to \"Coin\".</li> <li>Import the coin images from the assets provided.</li> <li>Add an <code>AnimatedSprite2D</code> node as a child of the \"Coin\" node.</li> <li>Create a new <code>SpriteFrames</code> resource by clicking on the \"Frames\" property in the Inspector.</li> <li>Double-click the <code>SpriteFrames</code> resource to open the editor. In the <code>SpriteFrames</code> editor, add a new animation and name it (e.g., \"coin\").</li> <li>Import the coins sprite sheet into the animation by dragging and dropping them into the frames list. You can also import individual frames if you have them as separate images.</li> <li>In the SpriteFrames editor, click on the Add frames from sprite sheet button and select the coin sprite sheet. Push the button Auto Slice to automatically slice the sprite sheet into individual frames. Then select all the frames and click on the Add button to add them to the animation.</li> <li>Set the animation speed (fps) and loop properties as needed. Provided this is the default animation, press the \"Autoplay on Load\" checkbox. Press the play button to preview the animation.</li> </ol> <p></p>"},{"location":"U08%20Videogames%20development/U08.3%20Animations/#animationplayer","title":"AnimationPlayer","text":"<p>Qith the node AnimationPlayer, we can create more complex animations that can animate multiple properties of different nodes over time. </p> <p>Let's create a simple animation that changes the size of a sprite.</p> <ol> <li>Create a new scene and add a <code>Node2D</code> as the root node. Rename it to \"Heart\".</li> <li>Import the heart image from the assets provided.</li> <li>Add a <code>Sprite2D</code> node as a child of the \"Heart\" node and set the texture to the heart image.</li> <li>Add an <code>AnimationPlayer</code> node as a child of the \"Heart\" node.</li> <li>In the <code>AnimationPlayer</code> node, create a new animation and name it (e.g., \"pulse\").</li> <li>With the \"pulse\" animation selected, click on the \"Add Track\" button and choose \"Property Track\".</li> <li>Select the <code>Sprite2D</code> node and choose the \"scale\" property to animate.</li> <li>Move the timeline cursor to the desired time (e.g., 0.5 seconds) and set a keyframe for the scale property: right-click on the scale property in the Inspector and select \"Insert Keyframe\".</li> <li>Change the scale value to make the heart larger (e.g., (1.5, 1.5)) and set another keyframe.</li> <li>Move the timeline cursor to the end of the animation (e.g., 1 second) and set the scale back to its original value (e.g., (1, 1)) and set a final keyframe.</li> <li>Adjust the animation length and playback settings as needed. Press the \"Autoplay on Load\" and the Loop checkboxes.</li> <li>Press the play button to preview the animation.</li> </ol> <p></p>"},{"location":"U08%20Videogames%20development/U08.3%20Animations/#player-animations","title":"Player animations","text":"<p>Now, it's time to make the player character more dynamic by adding animations for different states such as running, attacking, and jumping. We will use the <code>AnimationPlayer</code> node to create these animations.</p> <ol> <li>Open the player scene and select the root node (e.g., \"Player\").</li> <li>Add all the sprites for the idle animation in the sprites folder.</li> <li>Add an <code>AnimationPlayer</code> node as a child of the \"Player\" node.</li> <li>Create a new animation for the idle state and name it \"run\". Add keyframes to animate the player's running pose.</li> <li>Click on the \"Add Track\" button and choose \"Property Track\" -&gt; Sprite2D -&gt; texture.</li> <li>Add keyframes each 0.1 seconds and add the corresponding texture for each frame of the idle animation. Adjust the animation length to 0.9 seconds.Press the \"Autoplay on Load\" and the Loop checkboxes.</li> <li>Play the scene to preview the running animation and make the necessary adjustments.</li> </ol> <p></p> <p>Repeat the same process for the next animations: jump, fall, throw, damage and dead.</p> <p>The jump animation must use the jump sprites for when the player is jumping upwards. The fall animation must use the fall sprites for when the player is falling downwards. For the damage animation, you can use the first sprites of the dead animation.</p> <p>All these animations will not have the Loop property activated.</p> <p>The next step is to activate the animations according to the player's state in the script attached to the player node.</p> <p>The first animation will be the throwing animation when the player pushes the attack action button.</p>"},{"location":"U08%20Videogames%20development/U08.3%20Animations/#animationtree","title":"AnimationTree","text":"<p>The AnimationTree node is a powerful tool for managing complex animation states and blending between them. We will use it for transitions between our animation and to simplify the code in the player script.</p> <p>The automatic transitions we need are:</p> <ul> <li>From throw to run</li> <li>From damage to run</li> <li>From dead to End</li> </ul> <p>Add the AnimationTree node as a child of the player node. In the AnimationTree properties, set the Animation Player to the AnimationPlayer node we created earlier.</p> <p>In the Tree Root property, select \"Animation Node State Machine\". The AnimationTree editor will open with 2 default states: \"Start\" and \"End\".</p> <p>Add the run animation. Add a Immediate Transition from \"Start\" to \"run\".</p> <p>Add the throw animation. Add a At end Transition from \"throw\" to \"run\".</p> <p>In the player script, add these lines at the beginning to reference the animation tree and the animation state:</p> <pre><code>@onready var anim_tree = $AnimationTree\n@onready var anim_state = anim_tree.get(\"parameters/playback\")\n</code></pre> <p>In the _physics_process function, add the code to travel form the current animation to the throw one:</p> <pre><code>if Input.is_action_just_pressed(\"attack\"):\nanim_state.travel(\"throw\")\n</code></pre> <p>Play the game and test the throwing animation. The player should return to the running animation automatically after the throw animation ends.</p> <p>In the AnimationTree editor, add the rest of the animations: jump, fall, damage and dead. Create the At End transitions from damage to run and from dead to End.</p> <p>The AnimationTree will be something like this:</p> <p></p> <p>To control the jump and fall animations, we will check the vertical velocity of the player. To switch to the run animation when the player is on the ground, we will use the is_on_floor() method.</p> <pre><code># Handle jump code\n\nif velocity.y &lt; -0.1:\nanim_state.travel(\"jump\")\nif velocity.y &gt; 0.1:\nanim_state.travel(\"fall\")\nif (is_on_floor()):\nanim_state.travel(\"run\")\n</code></pre> <p>Warning</p> <p>Make sure you are using the <code>move_and_slide()</code> method.</p> <p>Check the jump and fall animations by making the player jump and fall. </p> <p>Question</p> <p>What if we want to add a throwing animation when the character is in the air? Simply, add the throwing in the air sprites, create the animation and create a state in the script for when the character \"is jumping\". Play the required animation when the player is in the air and presses the attack button.</p> <p>The remaining two animations, dead and damage, will be triggered in the section related to collisions.</p>"},{"location":"U08%20Videogames%20development/U08.4%20Nodes%20and%20scenes%20instancing/","title":"Unit 8.4 Nodes and scenes instancing","text":"<p>In this unit, we will see how to create nodes and reusable scenes and instantiate them in other scenes using Godot Engine. </p>"},{"location":"U08%20Videogames%20development/U08.4%20Nodes%20and%20scenes%20instancing/#nodes","title":"Nodes","text":"<p>We can reference nodes that are in the scene tree in various ways. The first way is to declare them as member of the script and initialize them in the <code>_ready()</code> function using the <code>get_node()</code> method.</p> <pre><code>extends Node2D\n\nvar player: Node2D\n\nfunc _ready():\nplayer = get_node(\"Player\")\n</code></pre> <p>If the node is not a direct child of the current node, we can use the relative path to access it.</p> <pre><code>extends Node2D\n\nvar enemy: Node2D\nvar camera: Camera2D\n\nfunc _ready():\nenemy = get_node(\"Enemies/Enemy1\")\ncamera = get_node(\"../Camera2D\")\n</code></pre> <p>A shorter way to access nodes is to use the <code>$</code> operator.</p> <pre><code>extends Node2D\n\nvar player: Node2D\nvar enemy: Node2D\n\nfunc _ready():\nplayer = $Player\nenemy = $Enemies/Enemy1\n</code></pre> <p>You can also acces the nodes and initialize them directly when declaring them as member variables using the <code>@onready</code> annotation.</p> <pre><code>extends Node2D\n\n@onready var player: Node2D = $Player\n</code></pre> <p>You can create nodes dynamically using the <code>Node.new()</code> method and adding them to the scene tree using the <code>add_child()</code> method.</p> <pre><code>func _ready():\nvar sprite = Sprite2D.new()\nadd_child(sprite)\n</code></pre> <p>To delete a node and free its memory, use the <code>queue_free()</code> method.</p> <pre><code>sprite.queue_free()\n</code></pre>"},{"location":"U08%20Videogames%20development/U08.4%20Nodes%20and%20scenes%20instancing/#scenes-instancing","title":"Scenes instancing","text":"<p>Scenes in Godot are reusable collections of nodes that can be instantiated in other scenes. This allows for modular and organized game development.</p> <p>To instance a scene, first, you need to load it using the <code>load()</code> or <code>preload()</code> functions and then create an instance of it using the <code>instance()</code> method.</p> <pre><code>var enemyScene = preload(\"res://scenes/Enemy.tscn\") # Preload the scene\n\nfunc _ready():\nvar enemy_instance = enemyScene.instantiate() # Create an instance of the scene\nadd_child(enemy_instance) # Add the instance to the scene tree\n</code></pre> <p>Note</p> <p><code>load()</code> is used to load a resource at runtime, while <code>preload()</code> loads the resource at compile time, which can improve performance.</p> <p>The advantage of loading or preloading scenes this way is that you can create multiple instances of the same scene easily at runtime. The scenes loaded this way are called Packed Scenes.</p>"},{"location":"U08%20Videogames%20development/U08.4%20Nodes%20and%20scenes%20instancing/#example-instancing-platforms","title":"Example: Instancing platforms","text":"<p>Let's create a simple example where we instance platforms in a scene. The first step is to create the platform scene.</p> <ol> <li>Create a new scene and add a <code>StaticBody2D</code> node as the root. Rename it to \"Platform\".</li> <li>Add a <code>Sprite2D</code> node as a child of the \"Platform\" node and set its texture to a platform image.</li> <li>Add a <code>CollisionShape2D</code> node as a child of the \"Platform\" node and set its shape to a rectangle that matches the platform size.</li> <li>Mark thew \"One Way Collision\" property of the <code>CollisionShape2D</code> node to allow the player to jump through the platform from below.</li> <li>Save the scene as <code>Platform.tscn</code> in the <code>scenes</code> folder.</li> </ol> <p>StaticBody2D</p> <p><code>StaticBody2D</code> nodes are used for objects that do not move but can interact with other physics bodies. They are ideal for platforms, walls, and floors.</p> <p>Once done the scene, check it in the main scene. Test if the player can jump and land on the platform. Adjust the platform position as needed. You can also adjust the player's jump force and gravity in the player script to make the jumping feel better.</p> <p>For this example we are going to instantiate platforms at 2 different heights. As we want to do an Endless Runner type of game, we want the platforms to be instantiated from the right side of the screen and move to the left side. When they go out of the screen, we will delete them to free memory.</p> <p></p> <p>We want the platforms to move to the left side of the screen, so we will create a new script called <code>Platform.gd</code> and attach it to the <code>Platform</code> scene.</p> <pre><code>extends StaticBody2D\n\nvar speed = 400\n\nfunc _process(delta: float) -&gt; void:\nposition = position.move_toward(Vector2(position.x - speed, position.y), speed * delta)\n\nif position.x &lt;= -200:\nqueue_free() # self destroy\n</code></pre> <p>This script also deletes the platform when it goes out of the screen with the <code>queue_free()</code> method.</p> <p>Now, we are going to instantiate the platforms in the main scene at a random time interval. Add to the main scene 2 timers and name them <code>LowPlatformTimer</code> and <code>UpPlatformTimer</code>. Set their <code>Wait Time</code> properties to <code>1</code> and <code>1.5</code> seconds respectively, and check the <code>Autostart</code> and <code>One Shot</code> properties.</p> <p>Timers</p> <p>A <code>Timer</code> node is used to create time-based events in Godot. It can be set to trigger after a specified duration, either once or repeatedly. It's main properties are: - Wait Time: The duration in seconds before the timer times out. - Autostart: If checked, the timer starts automatically when the scene is loaded. - One Shot: If checked, the timer will only time out once and then stop. It also has a signal called <code>timeout()</code> that is emitted when the timer reaches zero.  </p> <p>Connect the signal <code>timeout()</code> of both timers to the main scene script. In the timeout functions, we will instance the platforms at different heights.</p> <pre><code># main.gd\nextends Node2D\n\nvar platform = preload(\"res://Objects/Platforms/large_platform.tscn\")\n\n@onready var lowPlatformTimer = $LowPlatformTimer\n@onready var upPlatformTimer = $UpPlatformTimer\n\nvar lowPlatformY = 378\nvar upPlatformY = 171\n\nfunc _on_low_platform_timer_timeout() -&gt; void:\nprint(\"Timer out\")\nvar platform_instance = platform.instantiate()\nplatform_instance.position = Vector2(get_viewport_rect().size.x + 200, lowPlatformY) # Start at the right side of the screen\nadd_child(platform_instance)\n\nlowPlatformTimer.wait_time = randf_range(1.5, 3)\nlowPlatformTimer.start()\n\n\nfunc _on_up_platform_timer_timeout() -&gt; void:\nvar platform_instance = platform.instantiate()\nplatform_instance.position = Vector2(get_viewport_rect().size.x + 200, upPlatformY) # Start at the right side of the screen\nadd_child(platform_instance)\n\nupPlatformTimer.wait_time = randf_range(2, 4)\nupPlatformTimer.start()\n</code></pre> <p>In this script, we preload the <code>Platform.tscn</code> scene and instance it in the <code>timeout</code> functions of both timers. The platforms are positioned at different heights and start from the right side of the screen. The timers are restarted with a random wait time to create variability in platform spawning.</p> <p>Check the game and adjust the platform speed, spawn rates, y positions, and player jump settings to achieve the desired gameplay feel.</p>"},{"location":"U08%20Videogames%20development/U08.4%20Nodes%20and%20scenes%20instancing/#instancing-enemies-and-rewards","title":"Instancing enemies and rewards","text":"<p>For instantiating enemies, the process is similar to platforms. We will use the bird scene created in the previous unit.</p> <p>Set the gravity scale of the bird to 0 in the <code>RigidBody2D</code> node to prevent it from falling.</p> <p>First, create the bird script to move the birds to the left and delete them when they go out of the screen.</p> <pre><code>extends RigidBody2D\n\n@export var speed: float = 700.0\n\nfunc _process(delta: float) -&gt; void:\nposition = position.move_toward(Vector2(position.x - speed, position.y), speed * delta)\n\nif position.x &lt;= -100:\nqueue_free() # self destroy\n</code></pre> <p>In the main scene, preload the bird scene and create a timer to spawn the birds at random intervals.</p> <pre><code># main.gd\nvar bird = preload(\"res://Bird/bird.tscn\")\n\n@onready var birdTimer = $BirdTimer\n\nvar birdYCoords = [465, 268, 60]\n\nfunc _on_bird_timer_timeout() -&gt; void:\nvar bird_instance = bird.instantiate()\nbird_instance.position = Vector2(get_viewport_rect().size.x + 100, birdYCoords.pick_random())\nadd_child(bird_instance)\n\nbirdTimer.wait_time = randf_range(1, 2)\nbirdTimer.start()\n</code></pre> <p>The <code>birdYCoords</code> array contains different y positions for the birds to spawn at.</p> <p>We can proceed similarly for rewards like coins or power-ups. Create a scene for the coin, add a script to move it to the left, and instance it in the main scene using a timer.</p>"},{"location":"U08%20Videogames%20development/U08.4%20Nodes%20and%20scenes%20instancing/#instancing-kunais","title":"Instancing kunais","text":"<p>The last step will be instancing weapons when the player attacks. We will create a simple kunai scene that will be instanced when the player attacks.</p> <p>Kunai</p> <p>A kunai is a traditional Japanese tool that is often depicted as a throwing weapon in popular culture, especially in ninja-themed media.</p> <p>Create the scene inside the player's folder. Add a <code>RigidBody2D</code> node as the root and rename it to \"Kunai\". Add a <code>Sprite2D</code> node as a child and set its texture to a kunai image. Add a <code>CollisionShape2D</code> node as a child and set its shape, a <code>CapsuleShape2D</code>, to match the kunai size. Save the scene as <code>kunai.tscn</code>.</p> <p></p> <p>Preload the kunai scene in the player script and instance it when the player attacks.</p> <pre><code># player.gd\nvar kunai = preload(\"res://Player/kunai.tscn\")\n\nfunc _physics_process(delta: float) -&gt; void:\n# Previous code...\n\nif Input.is_action_just_pressed(\"attack\"):\nanim_state.travel(\"throw\")\nget_tree().create_timer(0.2).timeout.connect(throw_kunai) # Add this line\n\nmove_and_slide()\n\nfunc throw_kunai() -&gt; void:\nvar kunai_instance = kunai.instantiate()\nkunai_instance.position.x = position.x + 90\nkunai_instance.position.y = position.y\nkunai_instance.set_as_top_level(true)\nadd_child(kunai_instance)\n</code></pre> <p>The <code>get_tree().create_timer(0.2).timeout.connect(throw_kunai)</code> line creates a timer that calls the throw_kunai function after a delay of 0.2 seconds.</p> <p>The <code>set_as_top_level(true)</code> method is used to ensure that the kunai's position is not affected by the player's transformations and it is related to the global coordinate system.</p> <p>To actually throw the kunai, we need to add a script to the kunai scene that applies an impulse to it when it is instanced.</p> <pre><code># kunai.gd\nextends RigidBody2D\n\n@export var xForce: float = 700\n@export var yForce: float = -300\n\n# Called when the node enters the scene tree for the first time.\nfunc _ready() -&gt; void:\napply_impulse(Vector2(xForce, yForce))\n</code></pre> <p>A last detail is to restrict the movement of the character so he can't go out the limits of the screen. We can do this by clamping the player's position in the <code>_physics_process</code> function.</p> <pre><code>func _physics_process(delta: float) -&gt; void:\n# Previous code...\n\nmove_and_slide()\nposition.x = clamp(position.x, 0, get_viewport_rect().size.x)\n</code></pre>"},{"location":"U08%20Videogames%20development/U08.4%20Nodes%20and%20scenes%20instancing/#add-a-delay-to-the-kunai-throw","title":"Add a delay to the kunai throw","text":"<p>To add a delay to the kunai throw, we use a timer that calls the <code>throw_kunai</code> function after a short delay when the attack action is triggered. This simulates the time it takes for the player to perform the throwing animation before the kunai is actually thrown.</p> <p>Add a new Timer node to the Player scene and name it <code>AttackDelay</code>. Set its <code>Wait Time</code> property to <code>0.2</code> seconds, and check the <code>One Shot</code> property. </p> <p>In the script, modify the attack input handling to the next way:</p> <p>```gdscript     if Input.is_action_just_pressed(\"attack\") and !isDead:             if $AttackDelay.time_left &lt;= 0:             $AttackDelay.start()             anim_state.travel(\"throw\")             get_tree().create_timer(0.2).timeout.connect(throw_kunai)</p>"},{"location":"U08%20Videogames%20development/U08.4%20Nodes%20and%20scenes%20instancing/#references","title":"References","text":"<ul> <li>Godot Documentation: Instancing Scenes</li> </ul>"},{"location":"U08%20Videogames%20development/U08.5%20Collisions/","title":"Unit 8.5 Collisions","text":"<p>In this unit, we will explore how to implement collision detection and response in a videogame using the Godot Engine.</p> <p>First of all, we need to understand the concept of collision layers and masks.</p>"},{"location":"U08%20Videogames%20development/U08.5%20Collisions/#collision-layers-and-masks","title":"Collision Layers and Masks","text":"<p>Each physics body in Godot can be assigned to one or more collision layers. These layers determine which objects can collide with each other.</p> <p>Example: if object A is on layer 1 and object B is on layer 2, they will not collide.</p> <p>A collision mask specifies which layers an object will check for collisions against.</p> <p>Example: if object A is in layer 1 and has a collision mask that includes layer 2, it will detect collisions with object B that is on layer 2.</p> <p>Nodes that extend <code>CollisionObject2D</code> (like <code>Area2D</code>, <code>StaticBody2D</code>, <code>KinematicBody2D</code>, <code>RigidBody2D</code> and <code>CharacterBody2D</code>) have properties for setting collision layers and masks.</p> <p></p> <p>You can assign names to collision layers in the Project Settings under <code>General &gt; Layer Names &gt; 2D Physics</code>.</p> <p>A good practice is to place the player character in its own layer (e.g., \"Player\"), enemies in another layer (e.g., \"Enemies\"), and environment objects in a third layer (e.g., \"Environment\") to organize collision detection effectively.</p> <p></p> <p>For instance, in our game we can place the player in the \"Player\" layer (layer 1) and set its collision mask to detect collisions with layers 2 to 5.</p>"},{"location":"U08%20Videogames%20development/U08.5%20Collisions/#collision-shapes","title":"Collision Shapes","text":"<p>To detect collisions, physics bodies need to have collision shapes. Godot provides several built-in shape types, such as:</p> <ul> <li>RectangleShape2D</li> <li>CircleShape2D</li> <li>CapsuleShape2D</li> <li>ConvexPolygonShape2D</li> <li>ConcavePolygonShape2D</li> </ul>"},{"location":"U08%20Videogames%20development/U08.5%20Collisions/#detecting-collisions-on-a-kinematicbody2d-or-characterbody2d","title":"Detecting collisions on a KinematicBody2D or CharacterBody2D","text":"<p>When using a <code>KinematicBody2D</code>/<code>CharacterBody2D</code>, you can detect collisions during movement using the <code>move_and_collide()</code> or <code>move_and_slide()</code> methods.</p> <p>Example using <code>move_and_collide()</code>:</p> <pre><code>var collision = move_and_collide(velocity * delta)\nif collision:\nprint(\"Collided with: \", collision.get_collider().name)\n</code></pre> <p>Example using <code>move_and_slide()</code>:</p> <pre><code>move_and_slide()\nfor i in get_slide_collision_count():\nvar collision = get_slide_collision(i)\nprint(\"Collided with: \", collision.get_collider().name)\n</code></pre>"},{"location":"U08%20Videogames%20development/U08.5%20Collisions/#detecting-collisions-on-an-area2d-aginst-other-bodies","title":"Detecting collisions on an Area2D aginst other bodies","text":"<p>An <code>Area2D</code> node can detect when other bodies enter or exit its area using signals.</p> <p>The easiest way to detect collisions is to attach an Area2D node as a child of the object you want to detect collisions for.</p> <p>Add an Area2D node and a CollisionShape2D as its child to the Player. Set the shape to define the area. Make sure that the collision shape of the area is a bit larger that the player's collision shape. You can change the debug color of the collision shapes.</p> <p></p> <p>Do the same for the Bird scene.</p> <p>Now, the Area2D node of the player can detect the Area2D node of the bird when they overlap. To detect this, we can connect the <code>body_entered</code> signal of the Area2D node to a script attached to the player. But before, we will create groups to identify the objects.</p> <p>Go to the inspector of the Bird scene, Node &gt; Groups, and add a new global group called \"enemies\". Add the group to the Bird node. You'll see a new icon (a point inside a square) next to the node name.</p> <p>Next, select the Area2D node of the Player scene, go to the Node tab, and double-click on the <code>body_entered</code> signal. Connect it to the Player script. This will create a new function in the Player script named <code>_on_area2D_body_entered(body: Node2D)</code>. Inside this function, we can check if the body that entered the area belongs to the \"enemies\" group.</p> <p>Create alse the next groups we will use further:</p> <ul> <li>player (for the Player node)</li> <li>rewards (for the Coin node, etc.)</li> <li>weapons (for the Kunai node)</li> </ul> <p></p> <pre><code>func _on_area_2d_body_entered(body: Node2D) -&gt; void:\nif body.is_in_group(\"enemies\"):\nprint(\"Enemy entered\")\n</code></pre> <p>If this check works, you can implement the logic to handle the collision, such as reducing the player's health or ending the game. Create a variable to store the player's health and decrease it when colliding with an enemy.</p> <pre><code># player.gd\n@export var life = 3\n\nvar isDead = false\n\nfunc _on_area_2d_body_entered(body: Node2D) -&gt; void:\nprint(\"Body entered\")\nif body.is_in_group(\"enemies\"):\nlife -= 1\nprint(\"Life: \", life)\nif life &lt;= 0:\nanim_state.travel(\"dead\")\nisDead = true\nelse:\nanim_state.travel(\"damage\")\n</code></pre> <p>We also create a boolean variable <code>isDead</code> to prevent further actions when the player is dead.</p> <p>Check that everything works by running the game and colliding with the bird enemies. You can see how the dead animation doesn't play again once the player is dead. To solve that, we must add the <code>!isDead</code> check to the movement code.</p> <pre><code>func _physics_process(delta: float) -&gt; void:\nif Input.is_action_just_pressed(\"jump\") and is_on_floor() and !isDead:\nvelocity.y = jump_velocity\n\nif velocity.y &lt; -0.1 and !isDead:\nanim_state.travel(\"jump\")\nif velocity.y &gt; 0.1 and !isDead:\nanim_state.travel(\"fall\")\nif (is_on_floor()) and !isDead:\nanim_state.travel(\"run\")\n# Do the same for other movement and attack code...\n</code></pre> <p>When the birds collides the playyer it collides repeatly. To avoid this, we can disable the Area2D node of the bird when it collides with the player. To do this, we can connect the <code>body_entered</code> signal of the Area2D node of the bird to its script.</p> <pre><code># bird.gd\n\nfunc _on_area_2d_area_entered(area: Area2D) -&gt; void:\nif (area.is_in_group(\"player\")):\n$CollisionShape2D.set_deferred(\"disabled\", true)\n</code></pre> <p>The setDeferred() assigns a value to the given property at the end of the current frame. This is useful to avoid modifying the scene tree while it is being processed.</p> <p>For this to work, we need to add the player Area2D node to a group called \"player\".</p>"},{"location":"U08%20Videogames%20development/U08.5%20Collisions/#collisions-with-aread2d","title":"Collisions with Aread2D","text":"<p>To detect collisions with an Area2D node, you can use the <code>area_entered</code> and <code>area_exited</code> signals. These signals are emitted when another Area2D enters or exits the area.</p> <p>In our example, add an Area2D node to the Coin scene, with a CollisionShape2D as its child. Set the shape to a CircleShape2D that fits the coin. Assign the Area2D node of the Coin node to the \"rewards\" group.</p> <p>On the Player node, connect the <code>area_entered</code> signal of the Area2D node to the Player script. As we want to add points when collecting coins, we create a variable <code>points</code> to store the score.</p> <pre><code># player.gd\n\nvar points = 0\n\nfunc _ready() -&gt; void:\npoints = 0\n\n# Existing code...\n\nfunc _on_area_2d_area_entered(area: Area2D) -&gt; void:\nif area.is_in_group(\"rewards\"):\npoints += area.get_parent().pointsValue\nprint(\"Points: \", points)\n</code></pre> <p>The <code>get_parent()</code> method returns the parent node of the Area2D, which is the Coin node, because it has the script thtat holds the <code>pointsValue</code> variable.</p> <p>In the Coin script, we can define the <code>pointsValue</code> variable and remove the coin from the scene when collected.</p> <pre><code># coin.gd\n@export var pointsValue = 10\n\nfunc _on_area_2d_area_entered(area: Area2D) -&gt; void:\nif area.is_in_group(\"player\"):\nqueue_free()\n</code></pre>"},{"location":"U08%20Videogames%20development/U08.5%20Collisions/#collission-with-projectiles","title":"Collission with projectiles","text":"<p>To detect collisions with projectiles, we can use the same approach as with the Area2D node. For example, we can create a Kunai scene with a Area2D node and a CollisionShape2D as its child. Set the shape to a RectangleShape2D that fits the kunai. Add the group \"weapons\" to the Area2D node of the Kunai scene.</p> <p>Go to the Bird scene, and connect the <code>area_entered</code> signal of the Area2D node to the Bird script.</p> <pre><code># bird.gd\n\nvar dead = false\n\nfunc _physics_process(delta: float) -&gt; void:\n# Existing code\n\nif(dead):\nrotation += 10 * delta\n\nfunc _on_area_2d_body_entered(body: Node2D) -&gt; void:\nif(body.is_in_group(\"weapons\")):\napply_central_impulse(Vector2(500, -500))\n$CollisionShape2D.set_deferred(\"disabled\", true)\ndead = true\nget_tree().create_timer(1).timeout.connect(queue_free)\n</code></pre> <p>For this to work, we need to change the <code>_process()</code> method to <code>_physics_process()</code> to apply physics forces correctly. We also have added a <code>dead</code> variable to rotate the bird when it is hit by a kunai.</p> <p>When the kunai collides with the bird, we apply an impulse to make it fly away, disable its collision shape, set the <code>dead</code> variable to true to rotate it, and create a timer to remove the bird from the scene after 1 second.</p>"},{"location":"U08%20Videogames%20development/U08.5%20Collisions/#references","title":"References","text":"<ul> <li>Godot Documentation: Physics and collisions</li> </ul>"},{"location":"U08%20Videogames%20development/U08.6%20Camera%20and%20parallax/","title":"Unit 8.6 Camera and parallax","text":"<p>In this unit we will learn how to implement camera movement and parallax scrolling in a videogame using the Godot Engine.</p> <p>In our Endless Runner game, we will add a parallax effect to the background to create a sense of depth.</p>"},{"location":"U08%20Videogames%20development/U08.6%20Camera%20and%20parallax/#parallax","title":"Parallax","text":"<p>Parallax is a visual effect where background layers move at different speeds relative to the camera movement, creating an illusion of depth.</p> <p>To implement parallax in Godot, we can use the <code>Parallax2D</code> node. </p> <p>Info</p> <p><code>ParallaxBackground</code> and <code>ParallaxLayer</code> nodes are deprecated in Godot 4.x and should be replaced with <code>Parallax2D</code>.</p> <p>Set the next structure in the scene tree:</p> <p></p> <p>The Heaven layer will show the background sky that will not move. Place the sprites of the mountain, clouds, waves and grass in their sprite nodes inside their corresponding Parallax node. </p> <p>The mountain and the clouds are stand-alone textures, but for the waves and grass we need to set carefully the parallax repetition.</p> <p>Scale all the textures so they are placed correctly in the scene.</p> <p>The left part of the waves and grass textures must must be placed at the 0 position in the X axis, and the right part must scaled to fit the width of the game window (1024 pixels).</p> <p>Fro a game with static camera, like this one, we must only set the Repeat Size and Autoscroll properties of the ParallaxLayer nodes. Try with these values:</p> <ul> <li>Mountain: <ul> <li>Repeat Size X=1024. </li> <li>Autoscroll X= -10</li> </ul> </li> <li>Clouds: <ul> <li>Repeat Size X=1024. </li> <li>Autoscroll X= -20</li> </ul> </li> <li>Waves: <ul> <li>Repeat Size X=1283. </li> <li>Autoscroll X= -50</li> </ul> </li> <li>Grass: <ul> <li>Repeat Size X=1130. </li> <li>Autoscroll X= -400</li> </ul> </li> </ul> <p>As you can see, the repeat size means the point where the texture will start repeating, and the autoscroll value indicates the speed of movement of each layer. </p> <p></p>"},{"location":"U08%20Videogames%20development/U08.6%20Camera%20and%20parallax/#camera2d","title":"Camera2D","text":"<p>To this point we are using a static camera centered to fit the screen. But in many games, the camera follows the player character.</p> <p>Let's do some changes to our game only to illustrate this point.</p> <p>Add a <code>Camera2D</code> node to the main scene. Change it's transform position to Y=291. This will center the camera vertically in the screen.</p> <p>To follow the player, add the next code to the main scene script:</p> <pre><code>func _process(delta):\n$Camera2D.position.x = $Player.position.x\n</code></pre> <p>This code will update the camera's X position to match the player's X position every frame.</p> <p>Play the game. Probably you should adjust the background positions and sizes again to fit the new camera view.</p> <p>With this camera setup, the parallax ussually is set with the layers moving at different speeds based on the camera movement. Instead of adjusting the autoscroll property, we can set the Scroll Scale property of each ParallaxLayer node to define how much they move relative to the camera movement. For example:</p> <ul> <li>Mountain: Scroll Scale X=0.1</li> <li>Clouds: Scroll Scale X=0.2</li> <li>Waves: Scroll Scale X=0.5</li> <li>Grass: Scroll Scale X=1.0</li> </ul>"},{"location":"U08%20Videogames%20development/U08.6%20Camera%20and%20parallax/#references","title":"References","text":"<ul> <li>Godot Documentation: Camera2D</li> <li>Godot Documentation: Parallax 2D</li> </ul>"},{"location":"U08%20Videogames%20development/U08.7%20HUD/","title":"Unit 8.7 HUD","text":"<p>In this unit, we will learn how to create a Heads-Up Display (HUD) for our videogame using the Godot Engine.</p> <p>A HUD is an overlay that displays important information to the player, such as score, health, and other game stats.</p> <p>But first, let's take a look at the main components of the user interface (UI) in Godot.</p>"},{"location":"U08%20Videogames%20development/U08.7%20HUD/#user-interface-components-in-godot","title":"User Interface Components in Godot","text":"<p>User interface elements in Godot are created using <code>Control</code> nodes. Some commonly used <code>Control</code> nodes include:</p> <ul> <li>Content control nodes:</li> <li><code>Label</code>: Displays text on the screen. </li> <li><code>Button</code>: A clickable button.</li> <li><code>LineEdit</code>: A single-line input field for text.</li> <li><code>TextEdit</code>: A multi-line text input field.</li> <li>Layout controls:  </li> <li><code>VBoxContainer</code>: Arranges child nodes vertically.</li> <li><code>HBoxContainer</code>: Arranges child nodes horizontally.</li> <li><code>GridContainer</code>: Arranges child nodes in a grid format.</li> <li><code>MarginContainer</code>: Adds margins around its child nodes.</li> <li><code>CenterContainer</code>: Centers its child nodes.</li> <li><code>Panel</code>: A simple panel that can contain other UI elements.</li> <li>Others like <code>ScrollContainer</code>, <code>TabContainer</code>, <code>Popup</code> etc.</li> <li>Specialized controls:</li> <li><code>ProgressBar</code>: Displays a progress bar.</li> <li><code>TextureRect</code>: Displays an image or texture.</li> <li><code>Slider</code>: A slider control for selecting a value from a range.</li> <li><code>CheckBox</code>: A checkbox for binary choices.</li> <li>Others like <code>OptionButton</code>, <code>SpinBox</code>, <code>Tree</code>, etc.</li> </ul> <p>See all the <code>Control</code> nodes in the Godot UI tutorial: UI.</p>"},{"location":"U08%20Videogames%20development/U08.7%20HUD/#creating-the-hud-scene","title":"Creating the HUD Scene","text":"<p>First, create a new scene and add a <code>CanvasLayer</code> node as the root. This ensures that the HUD elements are drawn on top of the game scene. Rename it to \"HUD\".</p> <p>Add a <code>HBoxContainer</code> as a child of the <code>CanvasLayer</code> to arrange HUD elements horizontally. Adjust its anchors and margins to position it at the top of the screen.</p> <p>Add the following elements to the <code>HBoxContainer</code>: a <code>ProgressBar</code> to represent the player's health, an <code>VSeparator</code> and a <code>Label</code> to display the score.</p> <p>Rename the ProgressBar to \"LifeProgressBar\" and the Label to \"ScoreLabel\".</p> <p>Edit the next properties of the <code>LifeProgressBar</code> in the Inspector:</p> <ul> <li>Show Percent: off</li> <li>Min Value: 0</li> <li>Max Value: 3</li> <li>Step: 1 (to increment/decrement in whole numbers)</li> <li>Value: 3 (initial value)</li> <li>Layout &gt; Custom Minimum Size &gt; X: 120, Y: 40 (adjust to your texture size)</li> <li>Styles:</li> <li>Background: <code>StyleBoxEmpty</code> (to no show any background)</li> <li>Fill: <code>StyleBoxTexture</code> with the heart texture assigned.</li> <li>Axis Stretch: <code>Tile</code>.</li> </ul> <p>Edit the <code>VSeparator</code> properties:</p> <ul> <li>Theme Overrides &gt; Constants &gt; Separation: 200, Styles &gt; Separator: <code>StyleBoxEmpty</code> (to no show any separator)</li> </ul> <p>Edit the next properties of the <code>ScoreLabel</code> in the Inspector:</p> <ul> <li>Text: \"Score:\"</li> <li>Theme Overrides &gt; Fonts &gt; Font: assign the fonts you want with an appropiate size (e.g., 50).</li> </ul> <p></p>"},{"location":"U08%20Videogames%20development/U08.7%20HUD/#hud-script","title":"HUD Script","text":"<p>Attach a new script to the <code>HUD</code> node. This script will manage the HUD elements, updating the health and score as needed.</p> <pre><code># hud.gd\nextends CanvasLayer\n\nvar playerLife = 3\nvar playerScore = 0\n\nfunc _process(delta: float) -&gt; void:\n$HBoxContainer/LifeProgressBar.value = playerLife\n$HBoxContainer/ScoreLabel.text = \"Score: \" + str(playerScore)\n</code></pre> <p>The <code>str</code> function converts the score integer to a string for display.</p>"},{"location":"U08%20Videogames%20development/U08.7%20HUD/#integrating-the-hud-with-the-game","title":"Integrating the HUD with the Game","text":"<p>To integrate the HUD with the game, add the HUD scene as a child of the main game scene.</p> <p>In the player script, we can update the HUD variables when the player collects coins or takes damage. To do that, we need to get a reference to the HUD and player nodes, and update the <code>playerScore</code> and <code>playerLife</code> variables accordingly.</p> <pre><code># main.gd\n\n@onready var player = $Player\n@onready var hud = $HUD\n\nfunc _process(delta):\n# Update HUD\nhud.playerLife = player.life\nhud.playerScore = player.points\n</code></pre>"},{"location":"U08%20Videogames%20development/U08.7%20HUD/#ending-the-game","title":"Ending the Game","text":"<p>To end the game when the player's life reaches zero, we can add a check in the player script. When the life is zero, we can trigger a game over state and show a game over message on the HUD.</p> <p>Add a new CanvasLayer node to the Main scene for the Game Over message. Add a Panel node as a child of this CanvasLayer. Change its name to \"GameOverPanel\".</p> <p>Add a Label node as a child of the Panel to display the \"Game Over\" text. Add also two buttons for \"Restart\" and \"Quit\". </p> <p>You can change the style of the Panel and its children as you like, in the Theme Overrides section of the Inspector.</p> <p></p> <p>We can check the player's life in the <code>_process</code> function of the main script and call a function to show the Game Over panel when life reaches zero, after a short delay to show the death animation.</p> <pre><code># main.gd\nfunc _process(delta):\n# Existing code...\n\n#Check end of player life\nif player.life &lt;= 0:\nget_tree().create_timer(1.5).timeout.connect(end_game)\n\nfunc end_game():\ngameOverPanel.visible = true\nget_tree().paused = true\n</code></pre> <p>The <code>end_game</code> function makes the Game Over panel visible and pauses the game.</p> <p>Finally, connect the \"pressed\" signals of the Restart button to a <code>restart</code> function:</p> <pre><code>func restart():\nplayer.life = 3\nplayer.points = 0\nplayer.isDead = false\ngameOverPanel.visible = false\nget_tree().paused = false\nget_tree().reload_current_scene()\n</code></pre> <p>Important</p> <p>In order to the buttons to work when the game is paused, you need to set the Pause Mode property of the buttons to \"When Paused\" or \"Always\".</p>"},{"location":"U08%20Videogames%20development/U08.8%20Screens%20and%20globals/","title":"Unit 8.8 Screens and globals","text":"<p>In this unit, we will learn how to create different screens for our videogame using the Godot Engine, as well as how to manage global variables.</p>"},{"location":"U08%20Videogames%20development/U08.8%20Screens%20and%20globals/#start-screen","title":"Start Screen","text":"<p>Create a new scene and add a <code>Control</code> node as the root. Rename it to \"StartScene\".</p> <p>Add a Panel as a child of the <code>Control</code> and rename it to \"MainPanel\". </p> <p>Inside this panel, add the next nodes:</p> <ul> <li>ColorRect: Set the color you want for the background.</li> <li>TextureRect: Add a logo or title image for the game.</li> <li>Player: optionally, add a sprite or animation of the player character.</li> <li>Button: Rename it to \"PlayButton\" and set its text to \"Play\".</li> <li>Button: Rename it to \"CreditsButton\" and set its text to \"Credits\".</li> <li>Label: Rename it to \"MusicLabel\" and set its text to \"Music\".</li> <li>CheckButton: Rename it to \"MusicCheckButton\".</li> </ul> <p></p>"},{"location":"U08%20Videogames%20development/U08.8%20Screens%20and%20globals/#screen-change","title":"Screen change","text":"<p>To change to a new scene, we can use the next instruction:</p> <pre><code>get_tree().change_scene_to_file(\"res://path/to/scene.tscn\")\n</code></pre> <p>Let's make the transition from the Start Screen to the Game Scene when the Play button is pressed.</p> <p>Attach a script to the <code>StartScene</code> node and add the following code.</p> <p>Associate the PlayButton <code>pressed()</code> signal to the script:</p> <pre><code># start_scene.gd\nextends Control\n\nfunc _on_play_button_pressed() -&gt; void:\nget_tree().change_scene_to_file(\"res://MainScene/main.tscn\")\n</code></pre> <p>Set the StartScene as the main scene in the project settings to test it: Project -&gt; Project Settings -&gt; Application -&gt; Run -&gt; Main Scene.</p> <p>Now, if you play the game, you will see the Start Screen, and when you press the Play button, it will change to the Game Scene.</p> <p>Do the same for the Quit button of the Main Scene to return to the Start Screen.</p> <pre><code># main.gd\n\nfunc _on_quit_button_pressed() -&gt; void:\nget_tree().change_scene_to_file(\"res://StartScene/start_scene.tscn\")\n</code></pre>"},{"location":"U08%20Videogames%20development/U08.8%20Screens%20and%20globals/#panel-toggle","title":"Panel toggle","text":"<p>For our credits screen, we can use a Panel node that is hidden by default and is shown when the Credits button is pressed.</p> <p>Add a new Panel to the StartScene and rename it to \"CreditsPanel\". Inside this panel, add a Label with the credits text and a Button to close the panel.</p> <p>Add a RichTextLabel node to the CreditsPanel for better formatting of the credits text. This type of node allows you to use BBCode for text formatting, such as bold, italics, and different colors. You can view the BBCode reference in the Godot documentation.</p> <p>You can style the CreditsPanel and its children as you like using the Theme Overrides section of the Inspector.</p> <p></p> <p>For make the CreditsPanel appear and disappear, first, connect the CreditsButton <code>pressed()</code> signal and the Return button <code>pressed()</code> signal to the StartScene script. Then, add the next code to the StartScene script:</p> <pre><code># start_scene.gd\nextends Control\n\n@onready var mainPanel = $MainPanel\n@onready var creditsPanel = $CreditsPanel\n\nfunc _ready() -&gt; void:\nmainPanel.visible = true\ncreditsPanel.visible = false\n\nfunc _on_credits_button_pressed() -&gt; void:\nmainPanel.visible = false\ncreditsPanel.visible = true\n\nfunc _on_return_button_pressed() -&gt; void:\nmainPanel.visible = true\ncreditsPanel.visible = false\n</code></pre>"},{"location":"U08%20Videogames%20development/U08.8%20Screens%20and%20globals/#global-variables","title":"Global Variables","text":"<p>Global variables are useful to store information that needs to be accessed from different scenes, such as player settings, scores, or game states.</p> <p>In our example, we can use global variables to store the music setting (on/off) and access it from both the Start Screen and the Game Scene.</p> <p>Create a new script in the root directory and name it \"global.gd\". This script will hold our global variables.</p> <p>The content of the global.gd script will be:</p> <pre><code># global.gd\nextends Node\n\nvar musicOn: bool = true\n</code></pre> <p>In the Project Settings, go to the Globals tab. Add the <code>global.gd</code> script by clicking on the \"Add\" button. This will make the global variables accessible from any scene.</p> <p></p> <p>In the StartScene, connect the <code>toggled()</code> signal of the MusicCheckButton to the StartScene script.</p> <p>Now, we can modify the StartScene script to update the global music setting when the MusicCheckButton is toggled.</p> <pre><code># start_scene.gd\n\n@onready var global = $\"/root/Global\"\n\nfunc _on_music_check_button_toggled(toggled_on: bool) -&gt; void:\nglobal.musicOn=toggled_on\nprint(\"Music on: \", global.musicOn)\n</code></pre> <p>Check in the console that the global variable updates when you toggle the button.</p> <p>Finally, in the Game Scene, we can access the global music setting to play or stop the background music based on the player's choice. We will implement the music and sound effects in the next unit.</p>"},{"location":"U08%20Videogames%20development/U08.9%20Music%20and%20sounds/","title":"Unit 8.9 Music and sounds","text":"<p>In this unit, we will learn how to add music and sound effects to our videogame using the Godot Engine.</p>"},{"location":"U08%20Videogames%20development/U08.9%20Music%20and%20sounds/#audio-nodes-in-godot","title":"Audio Nodes in Godot","text":"<p>Godot provides several nodes to handle audio in your game. The most commonly used audio nodes are:</p> <ul> <li><code>AudioStreamPlayer</code>: Used to play sound effects. It can play a single audio stream.</li> <li><code>AudioStreamPlayer2D</code>: Similar to <code>AudioStreamPlayer</code>, but it has 2D spatialization, meaning the sound can be positioned in a 2D space.</li> <li><code>AudioStreamPlayer3D</code>: Similar to <code>AudioStreamPlayer2D</code>, but for 3D spatialization.</li> <li><code>AudioListener2D</code> and <code>AudioListener3D</code>: Used to manage the listener's position in 2D and 3D space respectively, affecting how spatialized audio is heard.</li> </ul>"},{"location":"U08%20Videogames%20development/U08.9%20Music%20and%20sounds/#adding-sound-effects","title":"Adding sound effects","text":"<p>To add sound effects to our game, we will use the <code>AudioStreamPlayer</code> node. Add an <code>AudioStreamPlayer</code> node as a child of the player character node in your scene for each sound you want to play (e.g., jump sound, coin collection sound).</p> <p>The most important property of the <code>AudioStreamPlayer</code> node are:</p> <ul> <li>Stream: Here you can load the audio file you want to play (e.g., WAV, OGG).</li> <li>Volume Db: Adjust the volume of the sound.</li> <li>Pitch Scale: Adjust the pitch (frequency) of the sound.</li> <li>Autoplay: If enabled, the sound will play automatically when the scene starts.</li> <li>Bus: Select the audio bus where the sound will be routed (default is \"Master\").</li> </ul> <p>To play a sound effect, you can use the <code>play()</code> method of the <code>AudioStreamPlayer</code> node. For example, to play a jump sound when the player jumps, you can add the following code to the player's script:</p> <pre><code># player.gd\n\n@onready var jumpSound = $JumpSound\n\n# Existing code\n\nif Input.is_action_just_pressed(\"jump\") and is_on_floor() and !isDead:\njumpSound.play()\nvelocity.y = jump_velocity\n</code></pre> <p>Repeat the process for other sound effects like coin collection, game over, etc.</p> <p>The same process can be followed to add sound effects to other game elements, such as enemies or obstacles.</p>"},{"location":"U08%20Videogames%20development/U08.9%20Music%20and%20sounds/#adding-background-music","title":"Adding background music","text":"<p>To add background music to your game, you can use another <code>AudioStreamPlayer</code> node. Add an <code>AudioStreamPlayer</code> node as a child of the Start and Main scene root nodes.</p> <p>To loop the background music, you must enable the Loop property of the music file in the FileSystem dock. Then, when you load the music file into the <code>AudioStreamPlayer</code> node, it will loop automatically.</p> <p>In the Start scene script, you can play the music depending on the value of hte global variable that indicates if the music is enabled or not:</p> <pre><code># start_scene.gd\n\n@onready var music = $Music\n\nfunc _ready() -&gt; void:\nmainPanel.visible = true\ncreditsPanel.visible = false\n\nif global.musicOn:\n$MainPanel/MusicCheckButton.button_pressed = true\nmusic.play()\nelse:\n$MainPanel/MusicCheckButton.button_pressed = false\n\nfunc _on_music_check_button_toggled(toggled_on: bool) -&gt; void:\nglobal.musicOn = toggled_on\nif global.musicOn == false:\nmusic.stop()\nelse:\nmusic.play()\n</code></pre> <p>In the Main scene script, you can start the music based on the global variable when the scene is ready (make sure that the <code>Autoplay</code> property is disabled):</p> <pre><code># main.gd\n\nfunc _ready(): gameOverPanel.visible = false\n\nif global.musicOn:\nmusic.play()\n</code></pre>"},{"location":"U08%20Videogames%20development/U08.9%20Music%20and%20sounds/#audio-buses","title":"Audio buses","text":"<p>You can manage the audio output of your game using audio buses. Audio buses allow you to group multiple audio sources and control their volume and effects collectively.</p> <p>By default, Godot has a \"Master\" bus that all audio nodes route to. You can create additional buses in the Audio tab of the Project Settings. For example, you can create separate buses for music and sound effects and adjust their volumes and effects independently.</p> <p></p> <p>Each <code>AudioStreamPlayer</code> node has a Bus property where you can select the bus to which the audio will be routed.</p>"},{"location":"U08%20Videogames%20development/U08.9%20Music%20and%20sounds/#references","title":"References","text":"<ul> <li>Godot Official Documentation - Audio</li> </ul>"}]}