{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Multimedia and mobile device programming - 2DAM","text":""},{"location":"U01/UD1/","title":"Unit 01. Introduction to Mobile Development","text":""},{"location":"U01/UD1/#1-mobile-devices","title":"1. Mobile Devices","text":"<p>We live in a hyper-connected society where we are permanently online thanks to mobile devices. These devices have evolved from being simple communication tools to becoming authentic personal assistants that help us in our daily lives.</p> <p>The evolution of mobile devices has been spectacular, from the first mobile phones that only allowed voice calls and SMS to the current smartphones, which are authentic pocket computers with which we can surf the internet, play multimedia content, play video games, take high-quality photos and videos, geolocate ourselves, etc.</p> <p>This evolution has been possible thanks to the development of hardware (processors, memory, screens, batteries, sensors, etc.) and software (operating systems and applications).</p> <p>IBM Simon</p> <p>The first true smartphone was the IBM Simon, manufactured in 1992 and distributed in the United States between 1994 and 1995.</p> <p></p>"},{"location":"U01/UD1/#11-types-of-mobile-devices","title":"1.1 Types of Mobile Devices","text":"<p>There are different types of mobile devices, the most common being:</p> <ul> <li> <p>Mobile Phones / Smartphones: They are the most common and popular. They have a touch screen and an operating system (Android, iOS) that allows the installation of applications (apps) that expand their functionalities.</p> </li> <li> <p>Tablets: They are devices with a screen size larger than that of a smartphone but smaller than that of a laptop. They are ideal for consuming multimedia content (videos, books, magazines, internet browsing) and are widely used in the educational field.</p> </li> <li> <p>Wearables: They are devices that can be worn on the body. The most common are smartwatches and smartbands (or activity bands). They are usually companions to the smartphone and are used to monitor physical activity, receive notifications, control music playback, etc.</p> </li> <li> <p>Cars (Smart/Connected Cars): Modern vehicles are now mobile computing platforms with internet access, operating systems, and app support, enabling connectivity with phones, other cars, and infrastructure.</p> </li> <li> <p>ChromeOS Devices (Chromebooks): These are lightweight, portable laptops and tablets that primarily rely on web and cloud-based applications, with added support for Android and Linux software.</p> </li> <li> <p>TVs (Smart TVs): Traditional televisions enhanced with integrated operating systems and internet connectivity, allowing users to stream content, browse the web, and interact with other smart devices.</p> </li> <li> <p>XR (Extended Reality): An umbrella term for immersive technologies, including:</p> <ul> <li>VR (Virtual Reality): Fully digital, immersive experiences using headsets.</li> <li>AR (Augmented Reality): Digital overlays on the real world, viewed via smartphones or glasses.</li> <li>MR (Mixed Reality): Advanced AR where digital and physical objects interact in real time.</li> </ul> </li> <li> <p>E-book readers: Devices designed specifically for reading digital books. They use electronic ink technology (e-ink), which mimics the appearance of paper and is much less tiring for the eyes than a conventional screen. Their autonomy is very high.</p> </li> </ul> <p></p>"},{"location":"U01/UD1/#12-characteristics-of-mobile-devices","title":"1.2 Characteristics of Mobile Devices","text":"<p>The main characteristics that define a mobile device are:</p> <ul> <li>Mobility: Its small size and weight, together with its wireless connectivity, allow it to be used anywhere.</li> <li>Wireless Connectivity: They can connect to the internet and other devices without cables, mainly through Wi-Fi and mobile data networks (3G, 4G, 5G). They also usually have other types of wireless connectivity such as Bluetooth, NFC, or GPS.</li> <li>Touch Screen: They are the main input and output element. Interaction is done through gestures (tap, double-tap, drag, pinch, etc.).</li> <li>Sensors: They incorporate numerous sensors that allow them to interact with the environment:<ul> <li>Accelerometer: Measures acceleration and tilt.</li> <li>Gyroscope: Measures orientation and rotation.</li> <li>Magnetometer: Digital compass that detects magnetic north.</li> <li>GPS: Determines the geographic location.</li> <li>Light Sensor: Adjusts screen brightness automatically.</li> <li>Proximity Sensor: Detects if the device is close to an object (e.g., turns off the screen during a call).</li> <li>Fingerprint Sensor / Face Recognition: For device unlocking and authentication.</li> </ul> </li> <li>Autonomy: They have a battery that allows them to operate for a certain time without being connected to the electrical grid. Autonomy is a key factor.</li> <li>Applications (Apps): Their functionality is extended by installing applications downloaded from official stores (Google Play, App Store) or other sources.</li> </ul>"},{"location":"U01/UD1/#13-hardware-of-a-mobile-device","title":"1.3 Hardware of a Mobile Device","text":""},{"location":"U01/UD1/#the-processor-and-the-soc","title":"The Processor and the SoC","text":"<p>A mobile device contains essentially the same hardware as a computer, but with a different architecture, as they are constrained by the device's smaller size. Therefore, when we talk about the processor in a mobile device, we must talk about the SoC or System on a Chip, an integrated circuit that combines different parts of the system, such as the CPU itself, the GPU (graphics processor), RAM, ROM, and USB or Wi-Fi controllers.</p> <p>It is worth highlighting the importance of the British company ARM Holdings in the world of mobile processors. It is the creator of the architecture of the same name, ARM (Advanced RISC Machines), a 32- and 64-bit RISC (Reduced Instruction Set Computer) architecture that is present in the majority of mobile devices.</p> <p></p>"},{"location":"U01/UD1/#ram-memory","title":"RAM Memory","text":"<p>The type of RAM memory found inside the SoC is dynamic (DRAM), which requires periodic refreshing and is very fast. To reduce energy consumption and minimize heating, this RAM is placed close to the CPU and GPU. This RAM is shared by both units.</p>"},{"location":"U01/UD1/#screens-on-mobile-devices","title":"Screens on Mobile Devices","text":"<p>One of the defining characteristics of smartphones is the screen, through which most of the interaction with the device takes place.</p> <p>There are primarily two types of technologies, with different variations and generations:</p> <ul> <li> <p>LCD or Inorganic: Liquid Crystal Display, which lets light pass through based on its polarity, just like computer monitors. For this, they have a backlight panel located behind the display, which can be made of fluorescent lights or LEDs. Within this type, we find TFT, LED, IPS, PLS, or Apple's Retina displays.</p> </li> <li> <p>OLED or Organic: These use organic materials that emit light by themselves when electricity is applied, meaning they do not need a backlight panel and can turn individual pixels on or off independently. These are thinner screens than LCDs, as they have fewer layers, with lower consumption, higher contrast, and greater brightness. Furthermore, this manufacturing technology allows panels to be flexible, leading to mobile phones with foldable or rollable screens. Within this family, we find AMOLED, Super AMOLED, or Dynamic AMOLED screens.</p> </li> </ul> <p></p> <p>Apart from the screen manufacturing technology, it is important to know some other characteristics about them.</p>"},{"location":"U01/UD1/#resolution-and-density","title":"Resolution and Density","text":"<p>The screen resolution refers to the number of pixels displayed on it and is determined by the number of pixels in the horizontal and vertical directions.</p> <p>From the resolution, we can determine the aspect ratio and the density of pixels per inch (ppi). This density is a measure that relates the size of the screen to its resolution. Two screens of different sizes with the same resolution will have different densities, and therefore, different image quality. Ideally, this density should be greater than 300 or 400 ppi.</p>"},{"location":"U01/UD1/#aspect-ratio","title":"Aspect Ratio","text":"<p>This is the relationship between the width and height of the screen. Traditionally, this ratio has followed the widescreen 16:9 format (for every 16 pixels in width, there are 9 in height). For example, the 1920x1080 format fulfills this proportion.</p> <p>However, a few years ago, the 18:9 (and even 19:9) ratio began to become popular, aimed at larger panels with almost no bezels. This ratio allows a device to be less wide than another with the same diagonal in a 16:9 format, thereby improving its ergonomics.</p> <p></p>"},{"location":"U01/UD1/#cameras","title":"Cameras","text":"<p>One of the components that is most often demanded in a mobile device is the photographic camera or cameras. These are mainly composed of:</p> <ul> <li>An optical block, which is relatively limited, although some devices allow for the connection of an external lens, and</li> <li>A sensor, composed of an array of photoreceptors, which translate light signals into electrical ones, thus obtaining the value for each point in the image.</li> </ul> <p>Over time, mobile devices have incorporated more cameras, besides the front and rear ones, so that currently we can find three, four, or even five cameras (telephoto, wide-angle, monochromatic, or even infrared).</p>"},{"location":"U01/UD1/#sensors","title":"Sensors","text":"<p>Mobile devices can incorporate a wide variety of sensors, with which we can obtain very diverse information from our environment. Among the sensors we can find in a mobile device, the following stand out:</p> <ul> <li> <p>GPS (Global Positioning System): Provides location services by using a continuous signal to GPS satellites, allowing it to show where on the planet we are. This device opens up a whole range of possibilities such as LBS or Location-Based Services.</p> </li> <li> <p>Accelerometer and Gyroscope: The gyroscope measures the device's movements thanks to angular acceleration, even allowing the detection of small rotations, making it very suitable for, for example, augmented reality applications. On the other hand, the accelerometer is less precise and allows detection of the device's position relative to the three axes: x, y, and z. With this, we can determine, for example, if the device is in a horizontal or vertical position, as well as detect turns, vibrations, tilt, or collisions.</p> </li> <li> <p>Light Sensor: Allows the detection of ambient light, so the device can adjust the screen brightness to adapt to different lighting conditions.</p> </li> <li> <p>Proximity Sensor: Allows the detection of the distance from the device to other objects through an infrared LED, and enables, for example, the screen to turn off when we bring it close to our face during a call.</p> </li> </ul> <p>In addition to these, we can find many others, such as biometric sensors (fingerprint or iris readers), magnetometer, barometer, capacitive sensors, infrared sensor, heart rate sensor, color spectrum sensor, or pedometer.</p> <p></p>"},{"location":"U01/UD1/#14-operating-systems-os","title":"1.4 Operating Systems (OS)","text":"<p>The OS is the most important software that manages the device's hardware and allows applications to run. The most common are:</p> <ul> <li> <p>Android: Developed by Google. It is the most used OS in the world. It is an open-source system, which allows manufacturers to adapt it to their devices.</p> </li> <li> <p>iOS: Developed by Apple. It is exclusively used on the company's devices (iPhone, iPad). It is a closed-source system, known for its security, performance, and integration with the Apple ecosystem.</p> </li> <li>Others: HarmonyOS (Huawei), etc.</li> </ul> <p></p>"},{"location":"U01/UD1/#15-applications-apps","title":"1.5 Applications (Apps)","text":"<p>Applications are programs designed to perform specific tasks on mobile devices. There are applications for almost everything: social networks, messaging, email, photography, music, video, maps, banking, news, games, etc.</p> <p>They are mainly downloaded from official stores:</p> <ul> <li> <p>Google Play Store (for Android).</p> </li> <li> <p>App Store (for iOS).</p> </li> </ul> <p>Mobile devices have countless uses, among which we can highlight:</p> <ul> <li>Communication: Calls, video calls, instant messaging (WhatsApp, Telegram), email, social networks (Instagram, TikTok, X - Twitter).</li> <li>Information: Internet browsing, reading news, consulting Wikipedia.</li> <li>Entertainment: Listening to music (Spotify), watching videos (YouTube, Netflix), playing games.</li> <li>Photography and Video: Taking photos, recording videos, editing them, and sharing them.</li> <li>Navigation and Maps: Geolocation, GPS navigation (Google Maps), searching for nearby places.</li> <li>E-commerce: Online shopping, banking applications, payment with the mobile phone (NFC).</li> <li>Productivity: Calendar, notes, document editing, task management.</li> <li>Health and Sports: Monitoring physical activity, counting steps, measuring heart rate.</li> </ul>"},{"location":"U01/UD1/#16-technologies-for-mobile-application-development","title":"1.6 Technologies for Mobile Application Development","text":"<p>Developing an application that runs natively on a specific operating system requires using its native technologies. However, to minimize the need for platform-specific development, several technologies exist that aim to enable cross-platform development in the broadest sense. These range from responsive web applications to compiled applications, including hybrid or progressive web applications (PWAs), each with its own advantages and disadvantages.</p> <p>Let's look at each of them, categorized by their distance from or closeness to native code.</p>"},{"location":"U01/UD1/#webapps-or-responsive-web-applications","title":"WebApps or Responsive Web Applications","text":"<p>These are applications based on web technologies: HTML, CSS, and JavaScript. They require only a web browser to run. Being \"responsive\" means their interface adapts to any device. For this type of application, no native code development is necessary, and they are entirely cross-platform because they run on the operating system's own web browser. Therefore, we have a single codebase that runs on all platforms. The main disadvantage is that they do not offer as good a user experience as native apps and do not allow access to all of the system's components.</p>"},{"location":"U01/UD1/#hybrid-applications","title":"Hybrid Applications","text":"<p>These use the trio of HTML, CSS, and JavaScript to build a website that is loaded within a WebView component\u2014essentially a browser without the navigation bar or other options\u2014giving it the appearance of a native application. This type of application can access some device features, like location or the accelerometer, through this component. Currently, the most popular framework for developing hybrid applications is Ionic, which allows development using other web frameworks like React, Angular, or Vue. </p>"},{"location":"U01/UD1/#progressive-web-applications-pwas","title":"Progressive Web Applications (PWAs)","text":"<p>Closer to native applications are Progressive Web Applications (PWAs), which are revolutionizing the current landscape. These applications incrementally enhance their functionalities based on the mobile device they run on, to leverage more potential. They can access hardware, work offline or with poor connectivity, and offer system notifications. There are numerous frameworks for PWA development, including React PWA Library, Angular PWA Framework, Vue PWA Framework, Ionic PWA Framework, Svelte, PWA Builder, and Polymer.</p> <p></p>"},{"location":"U01/UD1/#compiled-applications","title":"Compiled Applications","text":"<p>These are technologies that aim to use a single programming language to generate mobile applications into the native code of each platform. Some of the most widely used technologies in this category are:</p> <ul> <li> <p>React Native and NativeScript: They use JavaScript as their base programming language. However, instead of building interfaces with HTML, they use the framework's own components, which are compiled to native code, making the use of a WebView as an intermediary unnecessary.</p> </li> <li> <p>Flutter: Developed and maintained by Google, Flutter allows for cross-platform application development using the Dart language, which compiles to native code that runs entirely on the device. Flutter's way of working involves designing user interfaces using widgets, integrated directly into the code. Flutter comes with a set of predefined widgets, such as buttons, navigation bars, etc.</p> </li> <li> <p>Kotlin Multiplatform and Compose Multiplatform: With Kotlin Multiplatform, we can share code between various platforms (Android, iOS, web, etc.) using Kotlin as the programming language. This means we can write an application's logic once and reuse it on different platforms, reducing development time and effort. With Compose Multiplatform, a technology based on Jetpack Compose, we can create shared user interfaces for Android, iOS, desktop, and web using Kotlin. This facilitates the creation of consistent and reusable user interfaces across various platforms.</p> </li> </ul> <p>The Most Popular Development SDKs</p>"},{"location":"U01/UD1/#programming-for-ios","title":"Programming for iOS","text":"<p>To program for iOS (iPhone, iPad, Apple Watch, etc.), you\u2019ll need a mix of hardware, software, and knowledge. Here\u2019s a clear breakdown:</p> <p>Hardware</p> <ul> <li>Mac computer (MacBook, iMac, Mac Mini, etc.)   iOS development officially requires macOS.</li> <li>iOS device (optional but recommended)   You can test apps in the simulator, but real device testing is important.</li> </ul> <p>Software</p> <ol> <li> <p>Xcode (free, from the Mac App Store)</p> </li> <li> <p>Apple\u2019s official IDE (Integrated Development Environment).</p> </li> <li> <p>Includes editor, compiler, debugger, Interface Builder (UI designer), and the iOS Simulator.</p> </li> <li> <p>iOS SDK (comes with Xcode)</p> </li> <li> <p>Provides APIs, frameworks (UIKit, SwiftUI, Core Data, ARKit, etc.), and tools needed for building iOS apps.</p> </li> <li> <p>Apple Developer Account (optional at first, required for publishing)</p> </li> <li> <p>Free: lets you learn, run apps on simulator.</p> </li> <li>Paid (\\$99/year): required to publish to the App Store and to install apps on your physical iPhone.</li> </ol> <p>Programming Languages</p> <ul> <li>Swift Apple\u2019s modern language, recommended for all new projects.</li> <li>Objective-C older language, still used in legacy apps and some libraries.</li> </ul>"},{"location":"U01/UD1/#17-trends-and-future","title":"1.7 Trends and Future","text":"<p>The future of mobile devices points towards:</p> <ul> <li>5G Connectivity: Much higher speed and lower latency, enabling new applications.</li> <li>Folding screens and new formats.</li> <li>Augmented Reality (AR) and Virtual Reality (VR): More integrated into mobile devices.</li> <li>Artificial Intelligence (AI): Integrated into the device to improve photography, battery management, and personalize the user experience.</li> <li>More and better sensors.</li> <li>Greater integration with other devices (Internet of Things - IoT): Controlling the home, the car, etc., from the smartphone.</li> </ul>"},{"location":"U01/UD1/#2-introduction-to-android-development","title":"2. Introduction to Android development","text":"<p>As we saw previously, there are different technologies for mobile application development.</p> <p>In the next units, we will focus on native applications for the Android operating system, maintained by Google and based on the Linux kernel.</p>"},{"location":"U01/UD1/#21-origins-of-android","title":"2.1 Origins of Android","text":"<p>The origins of Android lie with the Palo Alto (California) company Android Inc., founded in 2003 by Andy Rubin. This company began by developing an operating system for digital cameras, but due to the sector's low profitability, they decided to pivot to mobile devices, a market then dominated by Symbian and Windows Mobile. In 2005, Google acquired Android Inc., and two years later, alongside the creation of the Open Handset Alliance\u2014a consortium of various technology companies aimed at developing open standards for mobile devices\u2014the first version of Android, Apple Pie, was announced. This version began to be incorporated into devices in 2008, and two years later, it captured nearly half of the market share.</p> <p></p>"},{"location":"U01/UD1/#22-the-android-operating-system","title":"2.2 The Android Operating System","text":"<p>Android is the most widely used operating system for mobile devices today. As we know, it is an operating system for touch-screen devices based on the Linux kernel and other open software standards.</p> <p>Android is developed as open source software, meaning both its source code and its issue tracker are accessible. The Android Open Source Project (https://source.android.com/) contains the Android source code, released under the Apache license.</p> <p>In June 2025, the latest version of Android, Android 16, was launched. Since its first version, it has continuously incorporated updates and new functionalities into the system. Furthermore, the ease it provides for application development has resulted in a large community of developers, whose work has produced over three million apps on the Google Play Store, the official Android application repository.</p>"},{"location":"U01/UD1/#23-characteristics","title":"2.3 Characteristics","text":"<p>Some of the most relevant characteristics of Android are:</p> <ul> <li>Adaptable to a wide variety of screen sizes and resolutions, with support for 2D and 3D graphics libraries based on OpenGL.</li> <li>Natively supports multi-touch screens.</li> <li>Offers local storage through a lightweight database, SQLite.</li> <li>Supports a wide range of connectivity technologies.</li> <li>Includes a web browser based on the WebKit rendering engine and the V8 JavaScript engine from Google Chrome.</li> <li>Native applications are programmed with Java or Kotlin and are compiled for the ART (Android Runtime) virtual machine.</li> <li>Incorporates support for a wide variety of multimedia formats and streaming.</li> <li>Supports a vast array of hardware devices and sensors.</li> <li>Features a very extensive catalog of applications through the Google Play service.</li> </ul>"},{"location":"U01/UD1/#24-android-versions","title":"2.4 Android Versions","text":"<p>Android has undergone a significant transformation since its first versions. As a summary, we will look at some characteristics of the most relevant updates.</p> <p>The system began its journey in 2008 with versions 1.0 and 1.1, which included apps like Gmail, Maps, Calendar, and YouTube. It was in version 1.5, Cupcake, that a version name was introduced, and a large number of interface improvements were included, such as the on-screen keyboard, which allowed devices to eliminate physical keyboards. Subsequently, with version 1.6, Donut, the system began to adapt to different screen sizes and resolutions.</p> <p>Versions 2.0 and 2.2 (Eclair and Froyo) introduced aspects like voice-guided navigation, real-time traffic information, and the bottom dock. Version 3.0, Honeycomb, was launched specifically for larger devices, like tablets, and in version 4.0, Ice Cream Sandwich, in 2011, this new interface, Holo, was unified for tablets and smartphones, thus entering the era of modern design.</p> <p>But the biggest change was yet to come with versions 5.0 and 5.1, Lollipop, in 2014. Google reinvented Android in what is perhaps the most important update to the system, introducing the Material Design standard\u2014a set of design specifications affecting the operating system, the web, and apps. With Material, flat color designs were introduced to give weight and depth to different interface elements using shadows, layers, or animations.</p> <p>Subsequent versions included some interface improvements, such as split-screen mode in Android 7.0/7.1 (Nougat) and the picture-in-picture floating window in Android 8/8.1 (Oreo). With Android 10, the dessert-based version code names were abandoned, and some aspects of the interface were reinvented regarding gestures and the navigation system.</p> <p>In Android 11, in 2020, substantial changes to privacy arrived, allowing users to grant apps temporary permissions to access location, camera, or microphone only when required, instead of permanently during installation.</p> <p>And in 2021, Android 12 arrived, representing the biggest update since Android 5.0, with the introduction of Material You, which allows for system design personalization to automatically adjust to the user's settings. This means, for example, that the theme's color palette adapts to the user's chosen wallpaper. Additionally, under the hood, it offers a simpler and more granular way to control how apps access our data through the new privacy dashboard.</p> <p>In August 2022, Android 13 (Tiramisu) appeared, evolving Material You and presenting improvements in security, audio, and integration with other Google products. Android 14 (Upside Down Cake), in October 2023, incorporated improvements in customization, privacy, and accessibility.</p> <p>In September 2024, the launch of Android 15 is expected, bringed improvements to the user interface, security, and performance.</p> <p>The last release is Android 16, in June 2025. Android 16's major updates include a new \"Material 3 Expressive\" UI with advanced animations and blur effects, a desktop mode for tablets, and an expanded Linux terminal to run full desktop applications. It also enhances privacy with features like Notification Cooldown and introduces improved media sharing via Bluetooth LE Audio.</p> <p></p> <p>Android versions</p>"},{"location":"U01/UD1/#25-android-architecture","title":"2.5 Android Architecture","text":"<p>The Android architecture is composed of a stack of layers, based on the Linux kernel, and is adapted to a wide variety of devices. The different components of the system are shown in the following figure:</p> <p></p> <p>Original at: https://developer.android.com/guide/platform</p> <p>We can see the following components:</p> <ul> <li> <p>System Applications: These form the base system and include the email client, calendar, SMS application, Maps, camera app, browser, contacts app, dialer, among others.</p> </li> <li> <p>Application Framework (Java API Framework): Offers applications access to all Android functions, as well as the ability to publish and securely offer their functionalities to others. All this is designed to simplify the reuse of system components and modular services. Among these services we can find:</p> <ul> <li>An enriched view system for building the user interface,</li> <li>A resource manager, to access application resources such as translations, images, or layout files,</li> <li>A notification manager, to display alerts in the status bar,</li> <li>An activity manager, to manage the application lifecycle and handle navigation,</li> <li>Content providers, so that applications can access data provided by other applications.</li> </ul> </li> <li> <p>C/C++ Libraries: These are libraries used by some system components, offered to developers through the Application Framework. Some of these libraries include the standard C library, 3D graphics libraries, multimedia libraries, or the SQLite database.</p> </li> <li> <p>Android Runtime: Includes the ART virtual machine itself and the core Java libraries. Apps run their own processes as instances of the ART virtual machine, following the process virtualization paradigm (similar to the JVM for PC). The executables for this virtual machine are in DEX format, a bytecode specifically designed for Android and optimized to occupy minimal memory space.</p> </li> <li> <p>Hardware Abstraction Layer (HAL): Consists of a series of library modules for the different hardware components of the device, such as the camera or sensors, and offers an interface to the upper layers to facilitate access to them.</p> </li> <li> <p>Linux Kernel: This is the foundation of the Android platform, providing it with basic system functionalities such as process management, memory management, networking, drivers, and security.</p> </li> </ul>"},{"location":"U01/UD1/#26-apps-for-android","title":"2.6 Apps for Android","text":"<p>Android applications are natively programmed in Kotlin or Java and are compiled by the Android SDK, along with data and resource files (interfaces, images, etc.), to generate an <code>.apk</code> file. This file contains the application itself and the information Android needs for its installation.</p> <p>Android implements the principle of least privilege in applications, which provides a certain level of security. This principle is based on:</p> <ul> <li>Android is a multi-user operating system, as it is based on Linux. The peculiarity is that for Android, each application is a different user.</li> <li>Each app has a user ID known only to the system, which establishes the necessary permissions for it to access its resources.</li> <li>Each process has its own virtual machine, so its code runs independently. In principle, each app will have its own process.</li> </ul> <p>With this, each application only has access to the components it needs. However, an application can share data with other applications and access system services, either by having two applications share the same user ID or by requesting user permission to access device data and resources (camera, microphone, Bluetooth connection, SD card, contacts, etc.).</p>"},{"location":"U01/UD1/#27-api-levels-compatibility-libraries-and-jetpack","title":"2.7 API Levels, Compatibility Libraries, and Jetpack","text":"<p>We have seen how different versions of Android introduce substantial changes in terms of operation and features. For developers, more than the version, we are interested in the API levels. These levels determine the compatibility of applications with Android versions. With each new version of the system, one or more API levels are introduced, which determine which device functionalities will be available to us.</p> <p>Info</p> <p>Android 16 is API level 36.</p> <p>When we start developing an Android application, we must consider which API functionalities we will need and establish the minimum level that our application will require. For example, if we develop an application that we want to follow Material Design standards, we must use a minimum API level 21, which was introduced in Android 5.0. Or if we desire functionalities present in Android 11 or 12, we must use API levels 30 and 31, respectively.</p> <p>To provide new functionalities or use equivalent functionalities in earlier versions of Android, Google launched a compatibility layer through Support Libraries. Currently, these libraries are integrated into Android Jetpack, a set of libraries that allows developers to focus on application logic and follow recommended practices, reducing boilerplate code and producing consistent code across different system versions.</p> <p>Jetpack Compose</p> <p>Traditionally, the design of native user interfaces has used XML files, which must be injected and manipulated from the source code.</p> <p>With Jetpack Compose, a more modern toolkit for interface development is introduced, following a declarative model. This means we describe the state of the interface, and Compose takes care of the rest, simplifying the code and making it more maintainable and reusable.</p>"},{"location":"U01/UD1/#3-android-studio","title":"3. Android Studio","text":"<p>Android Studio is the official IDE for Android development, based on JetBrains' IntelliJ IDE. Until 2014, Eclipse with the Android Development Tools (ADT) plugin was used.</p> <p>The main characteristics of Android Studio are:</p> <ul> <li>It is a cross-platform IDE (Windows, Linux, macOS)</li> <li>It is distributed under the Apache 2.0 license (free),</li> <li>It uses Gradle for building packages,</li> <li>It includes a series of templates for common application layouts,</li> <li>It allows Android-specific code refactoring,</li> <li>It offers support for development on different devices: smartphones, tablets, televisions, or wearables,</li> <li>It incorporates the Device Manager component, which allows creating and managing virtual Android devices to run, debug applications, or analyze performance, as well as linking physical devices to our development environment,</li> <li>It includes support for Google Cloud Platform, enabling integration with various Google services.</li> </ul>"},{"location":"U01/UD1/#31-device-manager","title":"3.1 Device Manager","text":"<p>The built-in Device Manager in Android Studio allows us to create and manage virtual Android devices, as well as link physical devices to our development environment.</p> <p>We must keep in mind that the architecture and system for which we develop our applications are different from those of our development machine, not to mention that we can also create applications for a wide range of devices.</p> <p>For testing and debugging applications, we can either directly connect a device to the machine and enable developer mode, or use virtualized devices. The advantage of virtualization is that we can test our applications with a wide range of devices and different configurations. The disadvantage is that we will have to create a virtual machine for each device we want to test, with the associated consumption of storage space and memory.</p>"},{"location":"U01/UD1/#32-android-studio-installation","title":"3.2 Android Studio installation","text":"<p>The best way of install Android Studio i to download the installer and follow the installation instructions. Once installed, Android Studio automatically checks for updates.</p> <p>But before start the installation, read carefully the system requirements.</p> <p>Download Android Studio</p> <p>Installation guide (with system requirements)</p> <p>Download and install Android Studio (Codelab)</p> <p>Task</p> <p>Install Android Studio</p>"},{"location":"U01/UD1/#33-genymotion-emulator-installation","title":"3.3 Genymotion emulator installation","text":"<p>Genymotion is a third-party Android emulator and virtual device management platform. It is a powerful alternative to the emulator that comes bundled with Android Studio (which is now based on the Android Emulator Hypervisor Driver for faster performance).</p> <p>While Android Studio's Device Manager is the official tool for creating and running Android Virtual Devices (AVDs), Genymotion is often favored by developers for its significantly faster performance, advanced features, and ease of use for specific testing scenarios.</p> <p>Additionally, Genymotion offers a cloud service that allows you to run emulators on remote servers. This is ideal for continuous integration/continuous deployment (CI/CD) pipelines, automated testing on a large scale, or accessing a powerful emulator from a less powerful local machine.</p> <p>As a drawback, if you use the free license of Genymotion, you won't have access to the latest Android version and to the pro widgets.</p> <p>Genymotion download</p> <p>Requirements and installation guides</p> <p>Task</p> <p>Install Genymotion Desktop and create and launch an Android Virtual Device with the latest API allowed.</p>"},{"location":"U01/UD1/#34-yout-first-android-app","title":"3.4 Yout first Android app","text":"<p>Once you have Android Studio installed, it's time to create your first Android app. The purpose of this section is to practice the basic use of IDE and emulators.</p> <p>Task</p> <ol> <li>Follow the guide at Create your first Android app codcelab</li> <li>Run the app on the Android Emulator. You can follow this codelab</li> <li>Close the Android emulator and start the Genymotion virtual device. Run your app on the Genymotion device.</li> <li>Connect your Android device and run the app on it. You can follow this codelab</li> </ol>"},{"location":"U01/UD1/#35-structure-of-an-android-project","title":"3.5 Structure of an Android project","text":"<p>Android Studio uses Gradle as the project build tool. Android projects are organized into modules, where each module will be a different application. This allows us to have multiple versions of our application for different types of devices (tablets, wearables, etc.) under the same project.</p> <p>Below, we see the structure generated in an Android project, from both the Project Files view in the side tool window and the Android view.</p> <p></p> <p>In the project files view, we can see the typical file structure of a Gradle project, with general application files in the root folder, as well as the specific folder for the application module (<code>app</code>). However, the Android view presents a more compact and simplified view of this information, organized into several main logical folders: <code>app</code> (which contains <code>manifests</code>, <code>kotlin+java</code>, and <code>res</code>), plus the <code>Gradle Scripts</code> folder.</p> <p>Let's see some of the most important elements of this organization:</p> <ul> <li>The Gradle build scripts, in Kotlin DSL format (<code>build.gradle.kts</code>). This includes both the general script located in the root (with information common to all modules) and the one specific to the application module (<code>app/build.gradle.kts</code>). In the Android view, both scripts are shown under <code>Gradle Scripts</code>, indicating whether it's the script for the project or the module.</li> <li>Inside the module folder (<code>app</code>) we find the <code>src</code> folder, which contains the application's source code (<code>app/src/main</code>). In the Android view, this is located in the <code>kotlin+java</code> folder and is displayed in package name format instead of showing the directory structure.</li> <li>The <code>app/src/main/res</code> folder, which will contain the application's resources (images, layouts, text strings, etc.). If we look at the detail, this folder contains many subfolders for the different types of resources. In the Android view, this content is displayed in a more compact and organized way, according to the resource type.</li> <li>The application descriptor file: <code>app/AndroidManifest.xml</code>, with information associated with it. As we will see, this is one of the most important files in our project, as it defines aspects such as the application name, package, icon, and its different components.</li> </ul>"},{"location":"U01/UD1/#gradle-scripts","title":"Gradle Scripts","text":""},{"location":"U01/UD1/#general-build-script","title":"General Build Script","text":"<p>As mentioned, an Android project defines a general configuration script <code>build.gradle.kts</code> for the project, located in the root folder, and another located in the <code>app</code> folder, which refers to the application module itself.</p> <p>The content of the general build script will have the following structure:</p> <pre><code>plugins {\nalias(libs.plugins.android.application) apply false\nalias(libs.plugins.kotlin.android) apply false\nalias(libs.plugins.kotlin.compose) apply false\n}\n</code></pre> <p>It contains aliases to the plugins it uses, defined in the version catalog file <code>libs.versions.toml</code>.</p> <p>In previous versions, plugins were specified in this same file, but now this catalog is used to manage the versions of plugins and dependencies, to facilitate maintenance and version updates, since all are defined in the same place.</p> <p>This file, located in the <code>gradle</code> folder, contains, among other things:</p> <pre><code>[versions]\nagp = \"8.13.0\"\nkotlin = \"2.0.21\"\n...\n\n[libraries]\n...\n\n[plugins]\nandroid-application = { id = \"com.android.application\", version.ref = \"agp\" }\nkotlin-android = { id = \"org.jetbrains.kotlin.android\", version.ref = \"kotlin\" }\nkotlin-compose = { id = \"org.jetbrains.kotlin.plugin.compose\", version.ref = \"kotlin\" }\n</code></pre> <p>This means it uses the plugins <code>com.android.application</code> (it's an Android application), <code>kotlin-android</code> (it's a Kotlin application) and <code>kotlin-compose</code>, with versions <code>8.13.0</code> for the first and <code>2.0.21</code> for the second.</p> <p>The utility of these plugins is to correctly configure the project build process, ensuring that the Kotlin code is compiled properly and packaged correctly for Android.</p> <p>Although by default plugins are loaded immediately, we can use the <code>apply false</code> syntax to load them later in the configuration files of each module.</p>"},{"location":"U01/UD1/#module-scripts","title":"Module Scripts","text":"<p>The build file most important is the <code>build.gradle.kts</code> of the application module itself. The main blocks that compose it are the following:</p> <pre><code>plugins {\nalias(libs.plugins.android.application)\nalias(libs.plugins.kotlin.android)\nalias(libs.plugins.kotlin.compose)\n}\n</code></pre> <p>This is where the plugins that the module will depend on are specified; specifically those defined in the general build file.</p> <pre><code>android {\nnamespace = \"com.example.helloandroid\"\ncompileSdk = 36\n\ndefaultConfig {\napplicationId = \"com.example.helloandroid\"\nminSdk = 24\ntargetSdk = 36\nversionCode = 1\nversionName = \"1.0\"\n\ntestInstrumentationRunner = \"androidx.test.runner.AndroidJUnitRunner\"\n}\n\nbuildTypes {\nrelease {\nisMinifyEnabled = false\nproguardFiles(\ngetDefaultProguardFile(\"proguard-android-optimize.txt\"),\n\"proguard-rules.pro\"\n)\n}\n}\ncompileOptions {\nsourceCompatibility = JavaVersion.VERSION_11\ntargetCompatibility = JavaVersion.VERSION_11\n}\nkotlinOptions {\njvmTarget = \"11\"\n}\nbuildFeatures {\ncompose = true\n}\n}\n</code></pre> <p>This <code>android</code> block is where some of the most important aspects of the application are configured. It contains the namespace of our application (<code>namespace</code>) and the SDK version it was developed with (<code>compileSdk</code>).</p> <p>Furthermore, it includes several sub-blocks, such as:</p> <ul> <li><code>defaultConfig</code>: Specifies the default configuration, with parameters such as the application ID (<code>applicationId</code>), the minimum SDK version the application will work with (<code>minSdk</code>), or the version it was developed for (<code>targetSdk</code>), among others.</li> <li><code>buildTypes</code>: Where parameters for the different builds can be specified. When creating a module, two builds are created by default: <code>release</code> and <code>debug</code>. Here we specify options like code optimization with Proguard, etc.</li> <li><code>compileOptions</code>, where the Java version to be used to compile the project (<code>sourceCompatibility</code>) and the Java version the compilation will target (<code>targetCompatibility</code>) are specified. In this case, the value <code>JavaVersion.VERSION_1_8</code> refers to Java version 8.</li> <li><code>kotlinOptions</code> specifies some options for Kotlin; in this case <code>jvmTarget</code>, which indicates the Java version that will be used for the Kotlin code.</li> </ul> <p>And finally, we have the following project dependencies block:</p> <pre><code>dependencies {\nimplementation(libs.androidx.core.ktx)\nimplementation(libs.androidx.lifecycle.runtime.ktx)\nimplementation(libs.androidx.activity.compose)\nimplementation(platform(libs.androidx.compose.bom))\nimplementation(libs.androidx.compose.ui)\nimplementation(libs.androidx.compose.ui.graphics)\nimplementation(libs.androidx.compose.ui.tooling.preview)\nimplementation(libs.androidx.compose.material3)\ntestImplementation(libs.junit)\nandroidTestImplementation(libs.androidx.junit)\nandroidTestImplementation(libs.androidx.espresso.core)\nandroidTestImplementation(platform(libs.androidx.compose.bom))\nandroidTestImplementation(libs.androidx.compose.ui.test.junit4)\ndebugImplementation(libs.androidx.compose.ui.tooling)\ndebugImplementation(libs.androidx.compose.ui.test.manifest)\n}\n</code></pre> <p>Among these dependencies, we highlight the Jetpack libraries (<code>libs.androidx.core.ktx</code>), as well as the Compose libraries (<code>libs.androidx.compose...</code>), among others. Note that we are also using aliases here, and the name and versions of the libraries are specified in the <code>gradle/libs.versions.toml</code> file.</p> <p>At this point, we we can see how, unlike other types of Gradle applications, the main class (<code>mainClass</code>) is not specified, and the <code>application</code> section doesn't even exist. As we will see next, the entry point will be specified in the Manifest file.</p>"},{"location":"U01/UD1/#the-androidmanifestxml-file-and-application-components","title":"The AndroidManifest.xml File and Application Components","text":"<p>The Manifest file is a file specific to each application that contains information about it. This information is used by the Android build tools, the system itself, and Google Play.</p> <p>Among the information we can find in it, we can highlight:</p> <ul> <li>The different components of the application and their properties: Activities (<code>&lt;activity&gt;</code>), Services (<code>&lt;service&gt;</code>), Broadcast Receivers (<code>&lt;receiver&gt;</code>), and Content Providers (<code>&lt;provider&gt;</code>). We will discuss these components later.</li> <li>The application's permissions to access protected system resources or other applications, as well as the permissions that other applications must possess to access this application's content.</li> <li>The different hardware and software features that our application will need, so that Google Play prevents its installation on devices that do not have these features.</li> </ul> <p>As an example, let's look at the <code>AndroidManifest.xml</code> of a typical \"Hello World\" application, like the one we created. The general structure of the file is as follows:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\nxmlns:tools=\"http://schemas.android.com/tools\"&gt;\n\n&lt;application&gt; ...\n    &lt;/application&gt;\n&lt;/manifest&gt;\n</code></pre> <p>As we can see, the root element <code>manifest</code> defines two namespaces:</p> <ul> <li><code>xmlns:android</code>, with which we can define Android-specific attributes (<code>android:</code>) in the document, which serve to define the application's behavior and its interaction with the system. Furthermore, it allows us to define information related to components (activities, services, etc.).</li> <li><code>xmlns:tools</code> allows us to use certain debugging and helper tools from the IDE, but it has no effect on the application's operation.</li> </ul> <p>In older versions of Android Studio, with Gradle prior to 7.3, the package name was also specified in the <code>manifest</code> tag, instead of in the project's Gradle build file. Therefore, in old projects, you might find it in this file.</p> <p>Let's now move on to the <code>application</code> element, which contains all the information about the application:</p> <pre><code>&lt;application\nandroid:allowBackup=\"true\"\nandroid:dataExtractionRules=\"@xml/data_extraction_rules\"\nandroid:fullBackupContent=\"@xml/backup_rules\"\nandroid:icon=\"@mipmap/ic_launcher\"\nandroid:label=\"@string/app_name\"\nandroid:roundIcon=\"@mipmap/ic_launcher_round\"\nandroid:supportsRtl=\"true\"\nandroid:theme=\"@style/Theme.HelloAndroid\"&gt;\n&lt;activity&gt; ... &lt;/activity&gt;\n&lt;/application&gt;\n</code></pre> <p>As we can see, several Android-specific attributes are defined here, such as the icon, label, or theme that defines the application's appearance. Many of these elements are referenced preceded by the <code>@</code> symbol, which indicates that they refer to application resources.</p> <p>Inside <code>application</code>, as mentioned, the different components of the application are defined. In this case, there is a single activity:</p> <pre><code>&lt;activity\nandroid:name=\".MainActivity\"\nandroid:exported=\"true\"\nandroid:label=\"@string/app_name\"\nandroid:theme=\"@style/Theme.HelloAndroid\"&gt;\n&lt;intent-filter&gt;\n&lt;action android:name=\"android.intent.action.MAIN\" /&gt;\n&lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;\n&lt;/intent-filter&gt;\n&lt;/activity&gt;\n</code></pre> <p>With this, we indicate that the application contains an activity named <code>.MainActivity</code> (actually <code>com.example.helloandroid.MainActivity</code>), and that this activity can receive messages from outside the application (<code>android:exported=\"true\"</code>), or in other words, that this activity will be an entry point to our application.</p> <p>Furthermore, an <code>intent-filter</code> element is defined, which specifies the actions this activity will react to. In this case, the action <code>android.intent.action.MAIN</code> is defined with the category <code>android.intent.category.LAUNCHER</code>. With <code>MAIN</code> we indicate that this is the entry point to the application, and by specifying the <code>LAUNCHER</code> category, we indicate that this activity should appear in the application launcher.</p> <p>Within this same <code>application</code> element, we will define the rest of the application's components. Any components not included will not be visible to the system.</p>"},{"location":"U01/UD1/#application-resources","title":"Application Resources","text":"<p>The application's resources folder (<code>res</code>) contains, organized in subfolders, the different types of resources used by the application. When programming any application, it is convenient to keep resources external to the application to facilitate their independent maintenance.</p> <p>Although there are several physical folders for the different types of resources, the Android view presents us with a logical organization of all of them. Among these logical folders we can find:</p> <ul> <li><code>drawable/</code>: Contains graphic design elements that can be drawn on the device screen: not only images but also layer lists, states, or levels, among many others.</li> <li><code>mipmap/</code>: Contains the different application icons, in different densities (dpi).</li> <li><code>layout/</code>: For apps that use XML layouts, contains the layouts of different parts of the user interface, in XML format.</li> <li><code>values/</code>: Contains files in XML format with simple values, such as character strings, integer values, or colors.</li> <li><code>xml/</code>: XML files that can be read at runtime, with some special configurations.</li> </ul>"},{"location":"U02/U02.1%20-%20Kotlin/","title":"The Kotlin language","text":"<p>Kotlin is a cross-platform, statically typed, general-purpose high-level programming language with type inference. Kotlin is designed to interoperate fully with Java, and the JVM version of Kotlin's standard library depends on the Java Class Library. </p> <p>Kotlin mainly targets the JVM, but also compiles to JavaScript or native code.Language development costs are borne by JetBrains, while the Kotlin Foundation protects the Kotlin trademark.</p> <p>The Android Kotlin compiler emits Java 8 bytecode by default (which runs in any later JVM), but allows targeting Java 9 up to 20, for optimizing. </p> <p>On 7 May 2019, Google announced that the Kotlin programming language had become its preferred language for Android app developers. Since the release of Android Studio 3.0 in October 2017, Kotlin has been included as an alternative to the standard Java compiler.</p> <p>References:</p> <ul> <li>Kotlin docs</li> <li>Kotlin for Android</li> <li>Kotlin playground</li> </ul>"},{"location":"U02/U02.1%20-%20Kotlin/#hello-world","title":"Hello world","text":"<p>Open the Kotlin Playground and write and execute this code:</p> <pre><code>fun main() {\nprintln(\"Hello, world!\")\n}\n</code></pre> <p><code>fun main()</code> is the entry point of the program. All Kotlin programs are required to have a main function, which is the specific place in your code where the program starts running. </p> <p><code>println</code> is a function that takes an argument as a String and outputs its content to the console.</p> <p>Tip</p> <p>You can also run Kotlin code in Android Studio creating a new file on an exisiting project and running that file.</p>"},{"location":"U02/U02.1%20-%20Kotlin/#variables","title":"Variables","text":"<p>To create a variable, use <code>var</code> or <code>val</code>, and assign a value to it with the equal sign (<code>=</code>):</p> <pre><code>var name = \"Mary\"\nval birthyear = 1974\n</code></pre> <p>The difference between <code>var</code> and <code>val</code> is that variables declared with the <code>var</code> keyword can be modified, while <code>val</code> variables cannot. <code>val</code> variables are immutable.</p> <p>Kotlin uses type inference, but you can specify the type when create a variable:</p> <pre><code>var name: String = \"Mary\"\nval birthyear: Int = 1974\n</code></pre> <p>The general rule for naming Kotlin variables are:</p> <ul> <li>Names can contain letters, digits, underscores, and dollar signs.</li> <li>Names should start with a letter, <code>$</code> and <code>_</code> </li> <li>Names are case sensitive (\"myVar\" and \"myvar\" are different variables)</li> <li>Names should start with a lowercase letter and it cannot contain whitespace</li> <li>Reserved words (like Kotlin keywords, such as var or String) cannot be used as names</li> </ul>"},{"location":"U02/U02.1%20-%20Kotlin/#types","title":"Types","text":"<p>In Kotlin, everything is an object in the sense that you can call member functions and properties on any variable.</p> <p>For integer numbers, there are four types with different sizes and value ranges:</p> <p></p> <p>When you initialize a variable with no explicit type specification, the compiler automatically infers the type with the smallest range enough to represent the value starting from Int. If it doesn't exceed the range of Int, the type is Int. If it does exceed that range, the type is Long. To specify the Long value explicitly, append the suffix L to the value. To use the Byte or Short type, specify it explicitly in the declaration. </p> <pre><code>val one = 1 // Int\nval threeBillion = 3000000000 // Long\nval oneLong = 1L // Long\nval oneByte: Byte = 1\n</code></pre> <p>Info</p> <p>In addition to signed integer types, Kotlin also provides unsigned integer types</p> <p>For real numbers, Kotlin provides floating-point types Float and Double that adhere to the IEEE 754 standard. Float reflects the IEEE 754 single precision, while Double reflects double precision.</p> <p></p> <p>For variables initialized with fractional numbers, the compiler infers the Double type.</p> <p>The String data type is used to store a sequence of characters (text). String values must be surrounded by double quotes:</p> <pre><code>val myText: String = \"Hello World\"\n</code></pre> <p>String literals may contain template expressions (pieces of code that are evaluated and whose results are concatenated into a string). When a template expression is processed, Kotlin automatically calls the <code>.toString()</code> function on the expression's result to convert it into a string. A template expression starts with a dollar sign ($) and consists of a variable name:</p> <pre><code>var name: String = \"Mary\"\nval age: Int = 34\nprintln(\"Hello $name!\")\nprintln(\"Yout age is $age\")\n</code></pre> <p>Template expressions can also hold an expression in curly braces:</p> <pre><code>val num1 = 3\nval num2 = 4\nprintln(\"$num1 + $num2 is ${num1 + num2}\")\n</code></pre> <p>The Boolean data type can only take the values <code>true</code> or <code>false</code>:</p> <pre><code>val isTrue: Boolean = true\nval isFalse: Boolean = false\n</code></pre> <p>The Char data type is used to store a single character. A <code>char</code> value must be surrounded by single quotes:</p> <pre><code>val letter = 'A'\n</code></pre>"},{"location":"U02/U02.1%20-%20Kotlin/#type-conversion","title":"Type Conversion","text":"<p>In Kotlin, numeric type conversion is different from Java. For example, it is not possible to convert an Int type to a Long type with the following code:</p> <pre><code>val x: Int = 5\nval y: Long = x\nprintln(y) // Error: Type mismatch \n</code></pre> <p>To convert a numeric data type to another type, you must use one of the following functions: <code>toByte()</code>, <code>toShort()</code>, <code>toInt()</code>, <code>toLong()</code>, <code>toFloat()</code>, <code>toDouble()</code>, <code>toString()</code> or <code>toChar()</code>:</p> <pre><code>val x: Int = 5\nval y: Long = x.toLong()\nprintln(y)\n</code></pre>"},{"location":"U02/U02.1%20-%20Kotlin/#nullable-types-and-elvis-operator","title":"Nullable types and Elvis operator","text":"<p>Kotlin is a safe language, and among other things, it prevents us from programming errors such as NullPointerException since it does not allow variable values to be null by default.</p> <p>If we want to specify that a variable can contain a null value, it is necessary to explicitly define it as nullable. To do this, when we define it, we add a question mark <code>?</code> to its type:</p> <pre><code>var name: String? = null //Nullable type\nvar age: Int = 50   //Non-nullable type\nage = null //Error\n</code></pre> <p>In addition, Kotlin also provides us with the <code>?:</code> operator, known as the Elvis operator, to specify an alternative value when the variable is null.</p> <pre><code>var name : String? = null\nprintln(name.length) // Error\nprintln(name?.length ?: -1) //prints -1\nname = Mary\nprintln(name?.length ?: -1) //prints 4\n</code></pre> <p>In this example we've used the <code>?.</code> safe call operator. It prevents to cause an exception when the variable is null and Kotlin can't call the member function (length in this case).</p>"},{"location":"U02/U02.1%20-%20Kotlin/#constants","title":"Constants","text":"<p>We can declare constants in Kotlin using the <code>const</code> keyword. Constants must be initialized with a value at the time of declaration, and their value cannot be changed later. Constants can only be of primitive types and String.</p> <pre><code>const val PI = 3.14159\nconst val APP_NAME = \"MyKotlinApp\"\n</code></pre> <p>Tip</p> <p>Use snake_case for naming constants: all uppercase letters with words separated by underscores.</p> <p>The difference between <code>val</code> and <code>const val</code> is that <code>val</code> can be assigned a value at runtime, while <code>const val</code> must be assigned a value at compile time. Additionally, <code>const val</code> can only be used for top-level or object-level properties, while <code>val</code> can be used in any scope.</p>"},{"location":"U02/U02.1%20-%20Kotlin/#operators","title":"Operators","text":""},{"location":"U02/U02.1%20-%20Kotlin/#arithmetic-operators","title":"Arithmetic Operators","text":"Operator Name Description Example + Addition Adds together two values x + y - Subtraction Subtracts one value from another x - y * Multiplication Multiplies two values x * y / Division Divides one value from another x / y % Modulus Returns the division remainder x % y ++ Increment Increases the value by 1 ++x -- Decrement Decreases the value by 1 --x"},{"location":"U02/U02.1%20-%20Kotlin/#assignment-operators","title":"Assignment Operators","text":"Operator Example Same As = x = 5 x = 5 += x += 3 x = x + 3 -= x -= 3 x = x - 3 *= x *= 3 x = x * 3 /= x /= 3 x = x / 3 %= x %= 3 x = x % 3"},{"location":"U02/U02.1%20-%20Kotlin/#comparison-operators","title":"Comparison Operators","text":"<p>Comparison operators are used to compare two values, and returns a Boolean value: either <code>true</code> or <code>false</code>.</p> Operator Name Example == Equal to x == y != Not equal x != y &gt; Greater than x &gt; y &lt; Less than x &lt; y &gt;= Greater than or equal to x &gt;= y &lt;= Less than or equal to x &lt;= y <p>The <code>===</code> operator (and its negated counterpart <code>!==</code>) checks for referencial equality. <code>a === b</code> evaluates to true if and only if <code>a</code> and <code>b</code> point to the same object:</p> <pre><code>fun main() {\nvar a = \"Hello\"\nvar b = a\nvar c = \"world\"\nvar d = \"world\"\n\nprintln(a === b)\n// true\nprintln(a === c)\n// false\nprintln(c === d)\n// true\n}\n</code></pre> <p>For values represented by primitive types at runtime (for example, <code>Int</code>), the <code>===</code> equality check is equivalent to the <code>==</code> check.</p>"},{"location":"U02/U02.1%20-%20Kotlin/#logical-operators","title":"Logical Operators","text":"Operator Name Description Example &amp;&amp; Logical and Returns true if both statements are true <code>x &lt; 5 &amp;&amp;  x &lt; 10</code> || Logical or Returns true if one of the statements is true <code>x &lt; 5 || x &lt; 4</code> ! Logical not Reverse the result, returns false if the result is true <code>!(x &lt; 5)</code>"},{"location":"U02/U02.1%20-%20Kotlin/#comments","title":"Comments","text":"<p>Kotlin has single-line comments and multi-line comments:</p> <pre><code>// This is a single-line comment\n\n/* This is\n  a multi-line\n  comment */\n</code></pre>"},{"location":"U02/U02.1%20-%20Kotlin/#control-structures","title":"Control structures","text":""},{"location":"U02/U02.1%20-%20Kotlin/#if-else","title":"if - else","text":"<p>The structure is similar to other languages:</p> <pre><code>if (condition1) {\n// block of code to be executed if condition1 is true\n} else if (condition2) {\n// block of code to be executed if the condition1 is false and condition2 is true\n} else {\n// block of code to be executed if the condition1 is false and condition2 is false\n}\n</code></pre> <p>In Kotlin, <code>if-else</code> can return a value for each case that can be assigned to a variable:</p> <pre><code>val message = if (age &lt; 18) {\n\"You are under-age.\"\n} else {\n\"You are adult.\"\n}\n</code></pre> <p>Warning</p> <p>When using <code>if</code> as an expression, you must also include <code>else</code> (required).</p> <p>That can be shortened to:</p> <pre><code>val msg = if (age &lt; 18) \"You are under-age.\" else \"You are adult.\"\n</code></pre> <p>This is equivalent to the ternary operator of other languages.</p>"},{"location":"U02/U02.1%20-%20Kotlin/#when","title":"when","text":"<p>The <code>when</code> statement is similar to <code>switch-case</code> of C/Java:</p> <pre><code>when (trafficLightColor) {\n\"Red\" -&gt; println(\"Stop\")\n\"Yellow\" -&gt; println(\"Slow\")\n\"Green\" -&gt; println(\"Go\")\nelse -&gt; println(\"Invalid traffic-light color\")\n}\n</code></pre> <p>In the same way that if, when can return the result and can be assigned to a variable:</p> <pre><code>val msg = when (trafficLightColor) {\n\"Red\" -&gt; \"Stop\"\n\"Yellow\" -&gt; \"Slow\"\n\"Green\" -&gt; \"Go\"\nelse -&gt; \"Invalid traffic-light color\"\n}\n\nprintln(msg)\n</code></pre>"},{"location":"U02/U02.1%20-%20Kotlin/#while-and-do-while","title":"while and do-while","text":"<p><code>while</code> and <code>do-while</code> loops are similar to C/Java:</p> <pre><code>while (condition) {\n// code block to be executed\n}\n</code></pre> <pre><code>do {\n// code block to be executed\n}\nwhile (condition);\n</code></pre> <p>In the same way, we have <code>break</code> and <code>continue</code> statements.</p>"},{"location":"U02/U02.1%20-%20Kotlin/#for","title":"for","text":"<p>Unlike Java and other programming languages, there is no traditional <code>for</code> loop in Kotlin.</p> <p>In Kotlin, the <code>for</code> loop is used to loop through arrays, ranges, and other things that contains a countable number of values.</p> <p>To loop through array elements, use the <code>for</code> loop together with the <code>in</code> operator:</p> <pre><code>val numbers = arrayOf(10, 14, 2, 15, 20)\nfor (x in numbers) {\nprintln(x)\n}\n</code></pre> <p>With the <code>for</code> loop, we can also iterate ranges:</p> <pre><code>for (x in 0..10) {\nprintln(x)\n} </code></pre>"},{"location":"U02/U02.1%20-%20Kotlin/#functions","title":"Functions","text":""},{"location":"U02/U02.1%20-%20Kotlin/#definition-and-invocation","title":"Definition and invocation","text":"<p>To declare a function in Kotlin we do:</p> <pre><code>fun funcName(param1 : Type1, param2 : Type2...) : ReturnType {\n// function body\nreturn\n}\n</code></pre> <p>Some examples:</p> <pre><code>fun simplefunction() {\nprintln(\"Simple function\")\n}\n\nfun functionWithParams(name: String): Unit\n{\nprintln(\"Hello $name\")\n}\n\nfun sum(x: Int, y: Int): Int {\nreturn (x + y)\n}\n\n//Function call\nprintln(sum(4, 5)) //prints 9\n</code></pre> <p>We look at some features of function declarations:</p> <ul> <li>They are declared using the keyword fun</li> <li>Names start with lower case and are expressed in camelCase</li> <li>Function parameters are specified after the name, in parentheses, and in the form parameter : Type. These types must necessarily be specified</li> <li>The return type of the function may be specified after the parenthesis with the argument list, followed by <code>:</code>.</li> <li>When the function does not return any significant value, its default return type is <code>Unit</code> , which would be the equivalent of <code>void</code> in Java or C.</li> </ul> <p>Warning</p> <p>Unlike in some languages, such as Java, where a function can change the value passed into a parameter, parameters in Kotlin are immutable. You cannot reassign the value of a parameter from within the function body.</p>"},{"location":"U02/U02.1%20-%20Kotlin/#named-parameters","title":"Named parameters","text":"<p>You can use named parameters when call a function:</p> <pre><code>fun hello(name: String, age: Int)\n{\nprintln(\"Hello $name, you are $age years old\")\n}\n\nhello(age = 16, name = \"Sean\") // Hello Sean, you are 16 years old\n</code></pre> <p>In this case, you can write the arguments in any order.</p>"},{"location":"U02/U02.1%20-%20Kotlin/#default-arguments","title":"Default arguments","text":"<p>Function parameters can also specify default arguments.</p> <pre><code>fun hello(name: String = \"Nonamed\", age: Int)\n{\nprintln(\"Hello $name, you are $age years old\")\n}\n\nhello(age = 16, name = \"Sean\") // Hello Sean, you are 16 years old\nhello(age = 16) // Hello Nonamed, you are 16 years old\n</code></pre>"},{"location":"U02/U02.1%20-%20Kotlin/#single-expression-functions","title":"Single-expression functions","text":"<p>When the function body consists of a single expression, the curly braces can be omitted and the body specified after an = symbol:</p> <pre><code>fun double(x: Int): Int = x * 2\n</code></pre> <p>Explicitly declaring the return type is optional when this can be inferred by the compiler:</p> <pre><code>fun double(x: Int) = x * 2\n</code></pre>"},{"location":"U02/U02.1%20-%20Kotlin/#lambda-expressions","title":"Lambda expressions","text":"<p>Lambda expressions provide a concise syntax to define a function without the <code>fun</code> keyword. You can store a lambda expression directly in a variable without a function reference on another function.</p> <p>Before the assignment operator (<code>=</code>), you add the <code>val</code> or <code>var</code> keyword followed by the name of the variable, which is what you use when you call the function. After the assignment operator (<code>=</code>) is the lambda expression, which consists of a pair of curly braces that form the function body:</p> <pre><code>fun main() {\nhello() // prints \"Hello world!\"\n}\n\nval hello = {\nprintln(\"Hello world!\")\n}\n</code></pre> <p>You can assign the lambda function to a variable and use it as a function too:</p> <pre><code>fun main() {\nval myHello = hello\nmyHello() // prints \"Hello world!\"\n}\n\nval hello = {\nprintln(\"Hello world!\")\n}\n</code></pre> <p>The full syntactic form of lambda expressions is as follows:</p> <pre><code>val sum: (Int, Int) -&gt; Int = { x: Int, y: Int -&gt; x + y }\n</code></pre> <ul> <li> <p>A lambda expression is always surrounded by curly braces.</p> </li> <li> <p>Parameter declarations in the full syntactic form go inside curly braces and have optional type annotations.</p> </li> <li> <p>The body goes after the <code>-&gt;</code>.</p> </li> <li> <p>If the inferred return type of the lambda is not Unit, the last (or possibly single) expression inside the lambda body is treated as the return value.</p> </li> </ul> <p>If you leave all the optional annotations out, what's left looks like this:</p> <pre><code>val sum = { x: Int, y: Int -&gt; x + y }\n</code></pre> <p>Another example of a lambda expression without arguments and return type:</p> <pre><code>val hello: () -&gt; Unit = { println(\"Hello world!\") }\n</code></pre>"},{"location":"U02/U02.1%20-%20Kotlin/#trailing-lambdas","title":"Trailing lambdas","text":"<p>If the last parameter of a function is a function, then a lambda expression passed as the corresponding argument can be placed outside the parentheses:</p> <pre><code>val numbers = listOf(1, 2, 3)\nval sum = numbers.fold(0) { acc, i -&gt; acc + i }\nprintln(sum) // prints 6\n</code></pre> <p>Such syntax is also known as trailing lambda.</p> <p>If the lambda is the only argument in that call, the parentheses can be omitted entirely:</p> <pre><code>run { println(\"...\") }\n</code></pre>"},{"location":"U02/U02.1%20-%20Kotlin/#it-for-single-parameter-functions","title":"<code>it</code> for single parameter functions","text":"<p>If the lambda has a single argument, we can use the keyword <code>it</code>, which represents that argument passed to the lambda function.</p> <p>The expression:</p> <pre><code>array.forEach { item -&gt; println(item * 4) }\n</code></pre> <p>can be shortened to:</p> <pre><code>array.forEach { println(it * 4) }\n</code></pre>"},{"location":"U02/U02.1%20-%20Kotlin/#classes-and-objects","title":"Classes and objects","text":"<p>Kotlin is an object-oriented programming language, and everything in Kotlin is associated with classes and objects, along with their properties and methods.</p>"},{"location":"U02/U02.1%20-%20Kotlin/#defining-a-class","title":"Defining a class","text":"<p>To define a class in Kotlin, use the <code>class</code> keyword followed by the class name and curly braces. Class names should start with an uppercase letter and use camelCase.</p> <pre><code>class Car {\nvar color: String = \"Red\"\nvar model: String = \"Toyota\"\nvar year: Int = 2020\n\nfun start() {\nprintln(\"Car started\")\n}\n\nfun stop() {\nprintln(\"Car stopped\")\n}\n}\n</code></pre> <p>To create an instance of a class (an object), use the class name followed by parentheses:</p> <pre><code>val myCar = Car()\nmyCar.color = \"Blue\"\nmyCar.start() // prints \"Car started\"\n</code></pre> <p>As you can see, we access the properties and methods of the class using the dot (<code>.</code>) notation.</p> <p>You can define class properties using <code>val</code> or <code>var</code>. Properties defined with <code>val</code> are read-only and cannot be modified after initialization, while properties defined with <code>var</code> can be modified.</p>"},{"location":"U02/U02.1%20-%20Kotlin/#getter-and-setter-functions-in-properties","title":"Getter and setter functions in properties","text":"<p>Kotlin provides built-in getter and setter functions for class properties. </p> <pre><code>class Person {\nvar name: String = \"\"\nget() = field\nset(value) { field = value\n} }\n</code></pre> <p>You can customize these functions if needed.</p> <pre><code>class Person {\nvar name: String = \"John\"\nget() = field.uppercase() // Custom getter\nset(value) {\nfield = value.trim() } // Custom setter\n}\n</code></pre> <p>To access the property, you can use the dot notation:</p> <pre><code>val person = Person()\nprintln(person.name) // prints \"JOHN\"\nperson.name = \"  Alice  \"\nprintln(person.name) // prints \"ALICE\"\n</code></pre> <p>Remember that the properties defined with <code>val</code> cannot have a setter function, as they are read-only. And therefore, you cannot modify their value after initialization:</p> <pre><code>class Person {\nval id: Int = 0\nget() = field\n// set(value) { field = value } // Error: Val cannot have a setter\n}\n\nval person = Person()\nperson.id = 5 // Error: Val cannot be reassigned\n</code></pre>"},{"location":"U02/U02.1%20-%20Kotlin/#constructors","title":"Constructors","text":"<p>The primary purpose of the constructor is to initialize the properties of the class when an object is created.</p> <p>A default constructor is provided by Kotlin if you don't define any constructors in your class. However, you can define your own constructors.</p> <pre><code>class Person(val id: Int, var name: String) {\nfun displayInfo() {\nprintln(\"ID: $id, Name: $name\")\n}\n} val person = Person(1, \"John\")\nperson.displayInfo() // prints \"ID: 1, Name: John\"\n</code></pre> <p>You can also define a secondary constructor using the <code>constructor</code> keyword:</p> <pre><code>class Person(val id: Int) {\nvar name: String = \"\"\n\nconstructor(id: Int, name: String) : this(id) {\nthis.name = name\n}\n\nfun displayInfo() {\nprintln(\"ID: $id, Name: $name\")\n}\n}\n\nfun main() {\nval person1 = Person(1)\nval person2 = Person(2, \"Alice\")\nperson1.displayInfo() // prints \"ID: 1, Name: \"\nperson2.displayInfo() // prints \"ID: 2, Name: Alice\"\n}\n</code></pre>"},{"location":"U02/U02.1%20-%20Kotlin/#inheritance","title":"Inheritance","text":"<p>Kotlin supports inheritance, allowing you to create a new class based on an existing class. The new class (subclass) inherits properties and methods from the existing class (superclass).</p> <p>To enable inheritance, the superclass must be marked with the <code>open</code> keyword:</p> <pre><code>open class Animal {\nopen fun sound() {\nprintln(\"Animal makes a sound\")\n}\n}\n\nclass Dog : Animal() {\noverride fun sound() {\nprintln(\"Dog barks\")\n}\n}\n</code></pre> <p>In this example, the <code>Animal</code> class is the superclass, and the <code>Dog</code> class is the subclass that inherits from <code>Animal</code>. The <code>sound</code> method in the <code>Dog</code> class overrides the method in the <code>Animal</code> class.</p> <p>Note how we must call the constructor of the superclass using parentheses <code>()</code>. If the superclass has a primary constructor with parameters, you must provide the required arguments when calling it.</p> <pre><code>open class Animal(val name: String) {\nopen fun sound() {\nprintln(\"$name makes a sound\")\n}\n}\n\nclass Dog(name: String) : Animal(name) {\noverride fun sound() {\nprintln(\"$name barks\")\n}\n}\n\nfun main() {\nval dog = Dog(\"Buddy\")\ndog.sound() // prints \"Buddy barks\"\n}\n</code></pre>"},{"location":"U02/U02.1%20-%20Kotlin/#overriding-methods-and-properties","title":"Overriding methods and properties","text":"<p>To override a method in a subclass, you must use the <code>override</code> keyword. The method in the superclass must be marked with the <code>open</code> keyword to allow it to be overridden.</p> <pre><code>open class Animal {\nopen fun sound() {\nprintln(\"Animal makes a sound\")\n}\n} class Cat : Animal() {\noverride fun sound() {\nprintln(\"Cat meows\")\n}\n}\n\nfun main() {    val cat = Cat()\ncat.sound() // prints \"Cat meows\"\n}\n</code></pre> <p>Similar to methods, you can also override properties in a subclass. The property in the superclass must be marked with the <code>open</code> keyword to allow it to be overridden.</p> <pre><code>open class Person {\nopen var name: String = \"John\"\n} class Student : Person() {\noverride var name: String = \"Alice\"\n}\n\nfun main() {\nval student = Student()\nprintln(student.name) // prints \"Alice\"\n}\n</code></pre>"},{"location":"U02/U02.1%20-%20Kotlin/#calling-superclass-methods","title":"Calling superclass methods","text":"<p>You can call a method from the superclass using the <code>super</code> keyword:</p> <pre><code>open class Animal {\nopen fun sound() {\nprintln(\"Animal makes a sound\")\n}\n}\n\nclass Dog : Animal() {\noverride fun sound() {\nsuper.sound() // Call the superclass method\nprintln(\"Dog barks\")\n}\n}\n\nfun main() {\nval dog = Dog()\ndog.sound() // prints \"Animal makes a sound\" followed by \"Dog barks\"\n}   </code></pre>"},{"location":"U02/U02.1%20-%20Kotlin/#has-a-relationships","title":"HAS-A relationships","text":"<p>In addition to inheritance (IS-A relationship), Kotlin also supports composition (HAS-A relationship). This means that a class can contain references to other classes as properties.</p> <pre><code>class Engine(val horsePower: Int) {\nfun start() {\nprintln(\"Engine with $horsePower HP started\")\n}\n}\n\nclass Car(val model: String, val engine: Engine) {\nfun start() {\nengine.start()\nprintln(\"$model car started\")\n}\n} fun main() {\nval engine = Engine(150)\nval car = Car(\"Toyota\", engine)\ncar.start() // prints \"Engine with 150 HP started\" followed by \"Toyota car started\"\n}\n</code></pre>"},{"location":"U02/U02.1%20-%20Kotlin/#visibility-modifiers","title":"Visibility modifiers","text":"<p>Kotlin provides several visibility modifiers to control the accessibility of classes, objects, interfaces, constructors, functions, properties, and their setters.</p> <ol> <li>Public: The default visibility modifier. The member is visible everywhere.</li> <li>Private: The member is visible only within the class or file where it is declared.</li> <li>Protected: The member is visible within the class and its subclasses.</li> <li>Internal: The member is visible within the same module.</li> </ol> <pre><code>class Example {\nprivate var privateVar: Int = 1\nprotected var protectedVar: Int = 2\ninternal var internalVar: Int = 3\npublic var publicVar: Int = 4\n} fun main() {\nval example = Example()\n\nprintln(example.publicVar) // Accessible\nprintln(example.privateVar) // Error: Not accessible\nprintln(example.protectedVar) // Error: Not accessible\nprintln(example.internalVar) // Accessible if in the same module\n}\n</code></pre> <p>Info</p> <p>A module is a collection of source files and build settings that let you divide your project into discrete units of functionality. Your project can have one or many modules. You can independently build, test, and debug each module.</p> <p>In an Android project, a module is typically an Android app or a library.</p> <p>A package is like a directory or a folder that groups related classes, whereas a module provides a container for your app's source code, resource files, and app-level settings. A module can contain multiple packages.</p> <p>You can also apply visibility modifiers to methods:</p> <pre><code>class Example {\nprivate fun privateMethod() {\nprintln(\"Private method\")\n}\n}\n\nfun main() {\nval example = Example()\nexample.privateMethod() // Error: Not accessible\n}\n</code></pre> <p>And to constructors:</p> <pre><code>class Example private constructor(val value: Int) {\ncompanion object {\nfun create(value: Int): Example {\nreturn Example(value)\n}\n}\n}\n\nfun main() {\nval example = Example.create(5) // Correct way to create an instance\nval example2 = Example(5) // Error: Constructor is private\n}\n</code></pre> <p>Info</p> <p>In this example we are using a companion object to provide a factory method for creating instances of the class, since the constructor is private.</p> <p>This table helps you determine the appropriate visibility modifiers based on where the property or methods of a class or constructor should be accessible:</p> Modifier Accessible in same class Accessible in subclass Accessible in same module Accessible outside module private \u2714 \ud835\uddeb \ud835\uddeb \ud835\uddeb protected \u2714 \u2714 \ud835\uddeb \ud835\uddeb internal \u2714 \u2714 \u2714 \ud835\uddeb public \u2714 \u2714 \u2714 \u2714"},{"location":"U02/U02.1%20-%20Kotlin/#property-delegation","title":"Property delegation","text":"<p>Property delegation is a design pattern that allows you to delegate the responsibility of getting and setting a property to another object. In Kotlin, you can use the <code>by</code> keyword to delegate a property to another object.</p> <p>In Android development, we use delegates for example to use the remembered state in Jetpack Compose:</p> <pre><code>var name by rememberSaveable { mutableStateOf(\"John\") }\n</code></pre> <p>In order to use the <code>by</code> keyword, <code>rememberSaveable</code> and <code>mutableStateOf</code>, you need the next imports:</p> <pre><code>import androidx.compose.runtime.getValue\nimport androidx.compose.runtime.mutableStateOf\nimport androidx.compose.runtime.rememberSaveable\nimport androidx.compose.runtime.setValue\n</code></pre>"},{"location":"U02/U02.1%20-%20Kotlin/#data-classes","title":"Data classes","text":"<p>A data class is a special type of class in Kotlin that is used to hold data. Data classes automatically generate useful methods such as <code>toString()</code>, <code>equals()</code>, <code>hashCode()</code>, and <code>copy()</code> based on the properties defined in the primary constructor.</p> <pre><code>data class User(val name: String, val age: Int)\n\nfun main() {\nval user1 = User(\"Alice\", 30)\nval user2 = User(\"Alice\", 30)\n\nprintln(user1) // User(name=Alice, age=30)\nprintln(user1 == user2) // true\nprintln(user1.copy(age = 31)) // User(name=Alice, age=31)\n}\n</code></pre> <p>A data class is equivalent to a Java class with only properties, getters, setters, <code>toString()</code>, <code>equals()</code>, and <code>hashCode()</code> methods.</p> <p>The <code>copy</code> function creates a new instance of the data class with the same property values as the original instance, but allows you to modify specific properties. In the example above, we created a new <code>User</code> instance with the same name as <code>user1</code>, but with a different age.</p>"},{"location":"U02/U02.1%20-%20Kotlin/#generic-classes","title":"Generic classes","text":"<p>Generics allow you to create classes, interfaces, and functions that can work with different data types while providing type safety. You can define a generic class by adding a type parameter in angle brackets (<code>&lt;&gt;</code>) after the class name.</p> <pre><code>class Box&lt;T&gt;(val value: T) {\nfun getVal(): T {\nreturn value\n}\n}   fun main() {\nval intBox = Box(123)\nval strBox = Box(\"Hello\")\n\nprintln(intBox.getVal()) // prints 123\nprintln(strBox.getVal()) // prints \"Hello\"\n}\n</code></pre>"},{"location":"U02/U02.1%20-%20Kotlin/#enum-classes","title":"Enum classes","text":"<p>An enum class is a special type of class in Kotlin that represents a group of related constants. Each constant is an instance of the enum class.</p> <pre><code>enum class Direction {\nNORTH, SOUTH, EAST, WEST\n}   fun main() {\nval dir = Direction.NORTH\nprintln(dir) // prints \"NORTH\"\n}\n</code></pre>"},{"location":"U02/U02.1%20-%20Kotlin/#singleton-objects","title":"Singleton objects","text":"<p>In Kotlin, you can create a singleton object using the <code>object</code> keyword. A singleton object is a class that has only one instance throughout the application.</p> <pre><code>object Database {\nfun connect() {\nprintln(\"Connected to the database\")\n}\n}   fun main() {\nDatabase.connect() // prints \"Connected to the database\"\n}\n</code></pre> <p>You can also create companion objects within a class. A companion object is an object that is associated with a class and can access its private members.</p> <pre><code>class MyClass {\ncompanion object {\nfun create(): MyClass {\nreturn MyClass()\n}\n}\n}   fun main() {\nval myClass = MyClass.create()\n} // creates an instance of MyClass\n</code></pre> <p>An example of companion object is the <code>Modifier</code> object in Jetpack Compose:</p> <pre><code>import androidx.compose.ui.Modifier\n\nval myModifier = Modifier.padding(16.dp).fillMaxWidth()\n</code></pre>"},{"location":"U02/U02.1%20-%20Kotlin/#interfaces","title":"Interfaces","text":"<p>An interface is a contract that defines a set of methods and properties that a class must implement. In Kotlin, you can define an interface using the <code>interface</code> keyword.</p> <pre><code>interface Shape {\nfun area(): Double\nfun perimeter(): Double\n}\n\nclass Circle(private val radius: Double) : Shape {\noverride fun area(): Double {\nreturn Math.PI * radius * radius\n}\n\noverride fun perimeter(): Double {\nreturn 2 * Math.PI * radius\n}\n}\n\nfun main() {\nval circle = Circle(5.0)\nprintln(\"Area: ${circle.area()}\") // prints \"Area: 78.53981633974483\"\nprintln(\"Perimeter: ${circle.perimeter()}\") // prints \"Perimeter: 31.41592653589793\"\n}\n</code></pre>"},{"location":"U02/U02.1%20-%20Kotlin/#collections","title":"Collections","text":"<p>Kotlin provides several collection types to store and manipulate groups of related data. The most commonly used collection types are lists, sets, and maps.</p>"},{"location":"U02/U02.1%20-%20Kotlin/#arrays","title":"Arrays","text":"<p>An array is a collection of elements of the same type. You can create an array using the <code>arrayOf</code> function or the <code>Array</code> class.</p> <pre><code>val numbers = arrayOf(1, 2, 3, 4, 5)\nval strings = Array(3) { i -&gt; \"Item $i\" } // creates an array of strings with 3 elements\n</code></pre> <p>You can access the elements of an array using their index:</p> <pre><code>println(numbers[0]) // prints 1\nnumbers[1] = 10\nprintln(numbers[1]) // prints 10\n</code></pre> <p>You can also use the <code>size</code> property to get the number of elements in an array:</p> <pre><code>println(numbers.size) // prints 5\n</code></pre> <p>To acces all the elements of an array, you can use a <code>for</code> loop:</p> <pre><code>for (num in numbers) {\nprintln(num)\n}\n</code></pre> <p>Or the <code>forEach</code> method:</p> <pre><code>numbers.forEach { num -&gt; println(num) }\n</code></pre>"},{"location":"U02/U02.1%20-%20Kotlin/#lists","title":"Lists","text":"<p>A list is an ordered collection of elements that can contain duplicates. You can create a list using the <code>listOf</code> function for an immutable list or the <code>mutableListOf</code> function for a mutable list.</p> <pre><code>val immutableList = listOf(1, 2, 3, 4, 5)\nval mutableList = mutableListOf(1, 2, 3, 4, 5)\n</code></pre> <p>You can access the elements of a list using their index, use the <code>size</code> property, and iterate through the elements in the same way as with arrays.</p> <p>You can add or remove elements from a mutable list using the <code>add</code> and <code>remove</code> methods:</p> <pre><code>mutableList.add(6)\nmutableList.remove(2)\nprintln(mutableList) // prints [1, 3, 4, 5, 6]\n</code></pre> <p>With removeAt you can remove an element at a specific index:</p> <pre><code>mutableList.removeAt(0)\nprintln(mutableList) // prints [3, 4, 5, 6]\n</code></pre> <p>Lists provides the <code>contains</code> method to check if an element is in the list:</p> <pre><code>println(mutableList.contains(4)) // prints true\nprintln(mutableList.contains(2)) // prints false\n</code></pre> <p>Lists also provide many useful methods for manipulating and transforming the data, such as <code>filter</code>, <code>map</code>, <code>reduce</code>, <code>sort</code>, and more.</p>"},{"location":"U02/U02.2%20Basic%20Android/","title":"Unit 2.2. Introduction to Mobile Development","text":"<p>In this unit we will learn the basics of Jetpack Compose. We will see the different components that make up a Compose application and how to create user interfaces with Compose.</p>"},{"location":"U02/U02.2%20Basic%20Android/#getting-started-with-jetpack-compose","title":"Getting Started with Jetpack Compose","text":"<p>Jetpack Compose is a modern toolkit for building Android UIs. It simplifies and accelerates UI development on Android with less code, powerful tools, and intuitive Kotlin APIs. You can build then UI by defining composable functions that describe your UI.</p> <p>To get started with Jetpack Compose, you need to set up your development environment. This includes installing Android Studio and the necessary SDKs. Once your environment is set up, you can create a new Compose project using the \"Empty Activity\" template and start building your user interface.</p> <p>Info</p> <p>To view how was developing with XML views, create a new project with \"Empty Views Activity\" template.</p>"},{"location":"U02/U02.2%20Basic%20Android/#composable-functions","title":"Composable Functions","text":"<p>A composable function is a special type of function that can be used to define a part of your UI. Composable functions are annotated with the <code>@Composable</code> annotation. Here is an example of a simple composable function that displays a text:</p> <pre><code>@Composable\nfun Greeting(name: String) {\nText(text = \"Hello, $name!\")\n}\n</code></pre> <p>An annotation is a special kind of metadata that can be added to code elements such as classes, functions, or properties. Annotations provide additional information about the code and can be used by the compiler or runtime to modify behavior or perform specific actions.</p> <p>Some annotations can take parameters, which allow you to provide additional information or configuration. For example, the <code>@Composable</code> annotation does not take any parameters, but other annotations like <code>@Preview</code> can take parameters to customize the preview behavior:</p> <pre><code>@Preview(showBackground = true)\n@Composable\nfun DefaultPreview() {\nGreeting(\"Android\")\n}\n</code></pre> <ul> <li>Composable functions can accept arguments, just like regular functions. In the example above, the <code>Greeting</code> function takes a <code>name</code> parameter and uses it to display a personalized greeting. They can also return values, although it's not common practice in Compose.</li> <li>Composable functions can be nested, allowing you to create complex UIs by combining smaller, reusable components. For example, you can create a <code>UserProfile</code> composable that includes a <code>ProfilePicture</code> and a <code>UserName</code> composable.</li> <li>The name of a composable function should be descriptive and follow the standard naming conventions for functions in Kotlin. It's common to use PascalCase for composable function names, as they represent UI components. Examples: <code>UserProfile</code>, <code>LoginButton</code>, <code>ProductList</code>.</li> </ul>"},{"location":"U02/U02.2%20Basic%20Android/#modifiers","title":"Modifiers","text":"<p>Modifiers are used to change the appearance or behavior of a composable function. They can be used to set properties such as size, padding, background color, and more. Modifiers are applied to composable functions using the <code>Modifier</code> class. Here is an example of how to use modifiers to set the padding and background color of a <code>Text</code> composable:</p> <pre><code>Text(\ntext = \"Hello, World!\",\nmodifier = Modifier\n.padding(16.dp)\n.background(Color.LightGray)\n)\n</code></pre> <p>Passing modifiers to custom composables is a common practice in Jetpack Compose. It allows you to provide flexibility and customization options for the composable's appearance and behavior. By accepting a <code>Modifier</code> parameter, you enable users of your composable to apply their own modifiers, such as padding, size, or click handling.</p> <p>Here is an example of a custom composable that accepts a <code>Modifier</code> parameter:</p> <pre><code>@Composable\nfun CustomButton(\nonClick: () -&gt; Unit,\nmodifier: Modifier = Modifier\n) {\nButton(\nonClick = onClick,\nmodifier = modifier\n) {\nText(\"Custom Button\")\n}\n}\n</code></pre> <p>Info</p> <p>In the example above, the <code>CustomButton</code> composable accepts a <code>modifier</code> parameter of the type <code>Modifier</code> with a default value of <code>Modifier</code> (a companion object that provides default values for the <code>Modifier</code> class).</p> <p>We can call this <code>CustomButton</code> composable and pass our own modifiers to customize its appearance:</p> <pre><code>CustomButton(\nonClick = { /* Handle click */ },\nmodifier = Modifier\n.padding(8.dp)\n.background(Color.Blue)\n)\n</code></pre> <p>dp and sp</p> <p>dp and sp are units of measurement used in Android development to ensure that UI elements are displayed consistently across different screen sizes and densities.</p> <ul> <li> <p>dp (density-independent pixels): A unit of measurement that is based on the physical density of the screen. It is used for defining layout dimensions and spacing. 1 dp is equivalent to one pixel on a 160 dpi screen. </p> </li> <li> <p>sp (scale-independent pixels): A unit of measurement that is similar to dp but is also scaled based on the user's font size preference. It is primarily used for defining font sizes. 1 sp is equivalent to one pixel on a 160 dpi screen, but it can be scaled up or down based on the user's font size settings.</p> </li> </ul>"},{"location":"U02/U02.2%20Basic%20Android/#lifecycle-of-composables","title":"Lifecycle of composables","text":"<p>Composable functions have a lifecycle that is managed by the Compose runtime. The lifecycle of a composable function includes the following stages: 1. Composition: When a composable function is called, it is composed, and its UI elements are created and added to the UI tree. 2. Recomposition: When the state of a composable function changes, it is recomposed, and its UI elements are updated to reflect the new state. 3. Disposal: When a composable function is no longer needed, it is disposed of, and its UI elements are removed from the UI tree.</p> <p></p>"},{"location":"U02/U02.2%20Basic%20Android/#layouts-and-ui-components","title":"Layouts and UI Components","text":""},{"location":"U02/U02.2%20Basic%20Android/#common-layouts","title":"Common Layouts","text":"<p>Jetpack Compose provides several layout components that help you arrange your UI elements. Some of the most commonly used layouts include:</p>"},{"location":"U02/U02.2%20Basic%20Android/#column","title":"Column","text":"<p>Arranges its children in a vertical sequence.</p> <pre><code>Column {\nText(\"Item 1\")\nText(\"Item 2\")\nText(\"Item 3\")\n}\n</code></pre>"},{"location":"U02/U02.2%20Basic%20Android/#row","title":"Row","text":"<p>Arranges its children in a horizontal sequence.</p> <pre><code>Row {\nText(\"Item 1\")\nText(\"Item 2\")\nText(\"Item 3\")\n}\n</code></pre>"},{"location":"U02/U02.2%20Basic%20Android/#box","title":"Box","text":"<p>Stacks its children on top of each other.</p> <pre><code>Box {\nText(\"Item 1\")\nText(\"Item 2\")\n}\n</code></pre> <p></p>"},{"location":"U02/U02.2%20Basic%20Android/#lazycolumn","title":"LazyColumn","text":"<p>A vertically scrolling list that only composes and lays out the currently visible items.</p> <pre><code>LazyColumn {\nitems(100) { index -&gt;\n\nText(\"Item #$index\")\n}\n}\n</code></pre>"},{"location":"U02/U02.2%20Basic%20Android/#spacer","title":"Spacer","text":"<p>A spacer is a composable that creates an empty space between UI elements. It can be used to adjust the layout and improve the visual appearance of your UI using modifiers to set its width and height, like <code>Modifier.width()</code> and <code>Modifier.height()</code>.</p> <pre><code>Row {\nText(\"Item 1\")\nSpacer(modifier = Modifier.width(16.dp))\nText(\"Item 2\")\n}\n</code></pre>"},{"location":"U02/U02.2%20Basic%20Android/#dividers","title":"Dividers","text":"<p>A divider is a composable that creates a visual divider between UI elements. You can implement dividers in your app using the <code>HorizontalDivider</code> and <code>VerticalDivider</code>.</p> <pre><code>Column {\nText(\"Item 1\")\nHorizontalDivider(\nthickness = 2.dp,\ncolor = Color.DarkGray\n)\nText(\"Item 2\")\n}\n</code></pre> <pre><code>Row {\nText(\"Item 1\")\nVerticalDivider()\nText(\"Item 2\")\n}\n</code></pre> <p>Layouts in Compose</p>"},{"location":"U02/U02.2%20Basic%20Android/#ui-components","title":"UI Components","text":"<p>Jetpack Compose provides a variety of UI components that you can use to build your user interface. Some of the most commonly used components include:</p>"},{"location":"U02/U02.2%20Basic%20Android/#text","title":"Text","text":"<p>Displays a text string.</p> <pre><code>Text(\"Hello, World!\")\n</code></pre> <p>But the recommendation is to display text from resources:</p> <pre><code>Text(stringResource(R.string.hello_world))\n</code></pre> <p>In this example, <code>R.string.hello_world</code> is a reference to a string resource defined in the <code>res/values/strings.xml</code> file.</p> <p>You can change the color, font size, font style, and more by using parameters:</p> <pre><code>Text(\ntext = \"Hello, World!\",\ncolor = Color.Red,\nfontSize = 24.sp,\nfontStyle = FontStyle.Italic,\nfontWeight = FontWeight.Bold,\nfontFamily = FontFamily.Serif,\ntextAlign = TextAlign.Center,\n)\n</code></pre> <p>You can also use the <code>style</code> parameter:</p> <pre><code>Text(\ntext = \"Hello, World!\",\nstyle = TextStyle(\nfontSize = 20.sp,\nfontWeight = FontWeight.Bold,\ncolor = Color.Blue\n)\n)\n</code></pre> <p>Don't forget to import the necessary classes:</p> <pre><code>import androidx.compose.ui.graphics.Color\nimport androidx.compose.ui.text.TextStyle\n... </code></pre> <p>Text in Compose</p>"},{"location":"U02/U02.2%20Basic%20Android/#text-fields","title":"Text fields","text":"<p>A text field allows the user to enter and edit text.</p> <pre><code>var state by rememberSaveable { mutableStateOf(\"Hello\") }\nTextField(\nvalue = state,\nonValueChange = { state = it },\nlabel = { Text(\"Label\") },\n)\n</code></pre> <p></p> <p>In this code we use <code>rememberSaveable</code> to save the state of the text field across recompositions and configuration changes, such as screen rotations. And <code>mutableStateOf</code> to create a mutable state variable that holds the current value of the text field.</p> <p>You can also use <code>OutlinedTextField</code> for a different style:</p> <pre><code>var state by rememberSaveable { mutableStateOf(\"Hello\") }\nOutlinedTextField(\nvalue = state,\nonValueChange = { state = it },\nlabel = { Text(\"Label\") },\n)\n</code></pre> <p></p> <p>Other parameters you can use are <code>placeholder</code>, <code>leadingIcon</code>, <code>trailingIcon</code>, <code>isError</code>, <code>singleLine</code>, <code>maxLines</code>, <code>keyboardOptions</code>, <code>keyboardActions</code>, etc.</p> <p>TextField</p>"},{"location":"U02/U02.2%20Basic%20Android/#images","title":"Images","text":"<p>To display an image, you can use the <code>Image</code> composable. You can load images from resources, URLs, or other sources.</p> <pre><code>Image(\npainter = painterResource(R.drawable.ic_launcher_foreground),\ncontentDescription = \"My Image\",\n)\n</code></pre> <p><code>painterResource</code> is used to load an image from resources.</p> <p>You also need to provide a content description for accessibility purposes.</p> <p>Images</p>"},{"location":"U02/U02.2%20Basic%20Android/#buttons","title":"Buttons","text":"<p>A button is a clickable component that can be used to perform an action when clicked.</p> <p>There are several types of buttons available in Jetpack Compose, each with its own appearance and purpose:</p> Type Appearance Purpose Filled Solid background with contrasting text. High-emphasis buttons. These are for primary actions in an application, such as \"submit\" and \"save.\" The shadow effect highlights the button's importance. Filled tonal Background color varies to match the surface. Also for primary or significant actions. Filled tonal buttons provide more visual weight and suit functions such as \"add to cart\" and \"Sign in.\" Elevated Stands out by having a shadow. Serves a similar purpose to tonal buttons. Increase elevation to make the button appear even more prominently. Outlined Features a border with no fill. Medium-emphasis buttons, containing actions that are important but not primary. They pair well with other buttons to indicate alternative, secondary actions like \"Cancel\" or \"Back.\" Text Displays text with no background or border. Low-emphasis buttons, ideal for less critical actions such as navigational links, or secondary functions like \"Learn More\" or \"View details.\" <p></p> <pre><code>Button(\nonClick = { /* Handle click */ }) {\nText(\"Click Me\")\n}\n</code></pre> <p>Parameters:</p> <ul> <li>onClick:     The function that the system calls when the user presses the button.</li> <li>enabled:     When false, this parameter makes the button appear unavailable and inactive.</li> <li>contentPadding:     The padding within the button.</li> </ul> <p>Buttons</p>"},{"location":"U02/U02.2%20Basic%20Android/#floating-action-button-fab","title":"Floating Action Button (FAB)","text":"<p>A Floating Action Button (FAB) is a circular button that floats above the UI and is used for a primary action in an application.</p> <pre><code>FloatingActionButton(\nonClick = { /* Handle click */ }\n) {\nIcon(Icons.Filled.Add, contentDescription = \"Add\")\n}\n</code></pre> <p>In Material Design, there are four types of FAB:</p> <ul> <li>FAB: A floating action button of ordinary size.</li> <li>Small FAB: A smaller floating action button.</li> <li>Large FAB: A larger floating action button.</li> <li>Extended FAB: A floating action button that contains more than just an icon.</li> </ul> <p></p> <p>Some parameters you can use: * shape: The shape of the FAB. * containerColor: The background color of the FAB. * contentColor: The color of the content inside the FAB. * elevation: The elevation of the FAB.</p> <pre><code>FloatingActionButton(\nonClick = { /* Handle click */ },\nshape = CircleShape,\ncontainerColor = Color.DarkGray,\ncontentColor = Color.White,\nelevation = FloatingActionButtonDefaults.elevation(8.dp)\n) {\nIcon(Icons.Filled.Add, contentDescription = \"Add\")\n}\n</code></pre> <p>FAB</p> <p>More buttons:</p> <ul> <li>Icon buttons</li> <li>Segmented buttons</li> </ul>"},{"location":"U02/U02.2%20Basic%20Android/#snackbar","title":"Snackbar","text":"<p>A Snackbar is a small banner that appears at the bottom of the screen to provide feedback about an operation. It can also contain an action button.</p> <p>To implement a snackbar, you first create <code>SnackbarHost</code>, which includes a <code>SnackbarHostState</code> property. <code>SnackbarHostState</code> provides access to the <code>showSnackbar()</code> function which you can use to display your snackbar.This suspending function requires a <code>CoroutineScope</code> such as with using <code>rememberCoroutineScope</code> - and can be called in response to UI events to show a Snackbar.</p> <pre><code>val snackbarHostState = remember { SnackbarHostState() }\nval scope = rememberCoroutineScope()\nButton(onClick = {\nscope.launch {\nsnackbarHostState.showSnackbar(\"Hello, Snackbar!\")\n}\n}) {\nText(\"Show Snackbar\")\n}\nSnackbarHost(hostState = snackbarHostState)\n</code></pre> <p></p> <p>You can provide an optional action and adjust the duration of the Snackbar:</p> <pre><code>val snackbarHostState = remember { SnackbarHostState() }\nval scope = rememberCoroutineScope()\nButton(onClick = {\nscope.launch {\nval result = snackbarHostState\n.showSnackbar(\nmessage = \"Snackbar\",\nactionLabel = \"Action\",\n// Defaults to SnackbarDuration.Short\nduration = SnackbarDuration.Indefinite\n)\nwhen (result) {\nSnackbarResult.ActionPerformed -&gt; {\n/* Handle snackbar action performed */\n}\nSnackbarResult.Dismissed -&gt; {\n/* Handle snackbar dismissed */\n}\n}\n}\n}) {\nText(\"Show Snackbar\")\n}\nSnackbarHost(hostState = snackbarHostState)\n</code></pre> <p>Some parameters: * actionLabel: The label for the action button. * duration: The duration for which the snackbar is displayed. It can be <code>SnackbarDuration.Short</code>, <code>SnackbarDuration.Long</code>, or <code>SnackbarDuration.Indefinite</code>.</p> <p>Snackbar</p>"},{"location":"U02/U02.2%20Basic%20Android/#cards","title":"Cards","text":"<p>A <code>Card</code> is a composable that displays content and actions on a single topic. Cards are used to group related information and make it easier to scan and understand.</p> <pre><code>Card(\nmodifier = Modifier.padding(16.dp),\nelevation = CardDefaults.cardElevation(\ndefaultElevation = 6.dp\n)\n) {\nColumn(modifier = Modifier.padding(16.dp)) {\nText(\"Card Title\", fontWeight = FontWeight.Bold)\nSpacer(modifier = Modifier.height(8.dp))\nText(\"Card content goes here.\")\nSpacer(modifier = Modifier.height(8.dp))\nButton(onClick = { /* Handle click */ }) {\nText(\"Click me\")\n}\n}\n}\n</code></pre> <p></p> <p>Similar to <code>Card</code> is <code>ElevatedCard</code>, which has a more pronounced shadow effect.</p> <p>Cards</p>"},{"location":"U02/U02.2%20Basic%20Android/#surface","title":"Surface","text":"<p>A <code>Surface</code> is a composable that provides a background for other UI elements. It can be used to create cards, buttons, and other components that need a background.</p> <pre><code>Surface(\nmodifier = Modifier.padding(16.dp),\ncolor = MaterialTheme.colorScheme.primary,\nshape = RoundedCornerShape(8.dp),\nshadowElevation = 4.dp\n) {\nText(\ntext = \"Hello, Surface!\",\nmodifier = Modifier.padding(16.dp),\ncolor = Color.White\n)\n}\n</code></pre> <p></p>"},{"location":"U02/U02.2%20Basic%20Android/#scaffold","title":"Scaffold","text":"<p>A <code>Scaffold</code> is a layout structure that provides a framework for implementing the basic material design layout structure. It includes slots for the most common top-level material components such as <code>TopAppBar</code>, <code>BottomAppBar</code> and <code>FloatingActionButton</code>.</p> <p>You usually pass a lambda to the <code>Scaffold</code> content parameter, which provides the inner padding values to be applied to the content inside the scaffold.</p> <pre><code>Scaffold(\ntopBar = {\nTopAppBar(\ntitle = { Text(\"My App\") },\ncolors = topAppBarColors(\ncontainerColor = MaterialTheme.colorScheme.primaryContainer,\ntitleContentColor = MaterialTheme.colorScheme.primary,\n),\n)\n},\nfloatingActionButton = {\nFloatingActionButton(onClick = { /* Handle click */ }) {\nIcon(Icons.Filled.Add, contentDescription = \"Add\")\n}\n},\nbottomBar = {\nBottomAppBar {\nText(\ntext = \"Bottom App Bar\",\nmodifier = Modifier.padding(16.dp),\ncolor = MaterialTheme.colorScheme.onPrimaryContainer\n)\n}\n},\n) { innerPadding -&gt;\nColumn(modifier = Modifier.padding(innerPadding)) {\nText(\"Hello, Scaffold!\") }\n}\n</code></pre> <p></p> <p>Scaffold</p> <p>App bars</p>"},{"location":"U02/U02.2%20Basic%20Android/#other-components","title":"Other components","text":"<ul> <li>Checkbox</li> <li>Radio Button</li> <li>Switch</li> <li>Progress Indicator</li> <li>Slider</li> <li>Tabs</li> <li>Menus</li> <li>Dialogs</li> <li>Tooltips</li> <li>Badges</li> <li>Chips</li> </ul>"},{"location":"U02/U02.2%20Basic%20Android/#theming-and-styling","title":"Theming and Styling","text":"<p>It's very easy to apply theming and styling in Jetpack Compose. You can use the <code>MaterialTheme</code> composable to apply a material design theme to your app.</p> <p><pre><code>class MainActivity : ComponentActivity() {\noverride fun onCreate(savedInstanceState: Bundle?) {\nsuper.onCreate(savedInstanceState)\nsetContent {\nMaterialTheme {\n// Your app content goes here\n}\n}\n}\n}\n</code></pre> You can create your own custom theme by defining colors, typography, and shapes. You can then apply your custom theme using the <code>MaterialTheme</code> composable.</p> <pre><code>@Composable\nfun MyAppTheme(content: @Composable () -&gt; Unit) {\nMaterialTheme(\ncolorScheme = lightColorScheme(\nprimary = Color(0xFF6200EE),\nsecondary = Color(0xFF03DAC5)\n),\ntypography = MaterialTheme.typography.copy(\nbodyLarge = TextStyle(\nfontFamily = FontFamily.Serif,\nfontWeight = FontWeight.Normal,\nfontSize = 16.sp\n)\n),\nshapes = MaterialTheme.shapes.copy(\nsmall = RoundedCornerShape(4.dp),\nmedium = RoundedCornerShape(8.dp),\nlarge = RoundedCornerShape(12.dp)\n),\ncontent = content\n)\n}\n</code></pre> <p>It's a good practice to create a separate file for your theme, colors, typography, and shapes. For example, you can create a file named <code>Theme.kt</code> and define your custom theme there.</p> <pre><code>@Composable\nfun MyAppTheme(content: @Composable () -&gt; Unit) {\nMaterialTheme(\ncolors = myColorPalette,\ntypography = myTypography,\nshapes = myShapes,\ncontent = content\n)\n}\n</code></pre> <p>An example of <code>myTypography</code>:</p> <pre><code>val myTypography = Typography(\nbodyLarge = TextStyle(\nfontFamily = FontFamily.Serif,\nfontWeight = FontWeight.Normal,\nfontSize = 16.sp\n)\n)\n</code></pre> <p><code>myShapes</code> example:</p> <pre><code>val myShapes = Shapes(\nsmall = RoundedCornerShape(4.dp),\nmedium = RoundedCornerShape(8.dp),\nlarge = RoundedCornerShape(12.dp)\n)\n</code></pre> <p>And <code>myColorPalette</code>:</p> <pre><code>val myColorPalette = lightColorScheme(\nprimary = Color(0xFF6200EE),\nsecondary = Color(0xFF03DAC5),\nbackground = Color(0xFFFFFFFF),\nsurface = Color(0xFFFFFFFF),\nonPrimary = Color(0xFFFFFFFF),\nonSecondary = Color(0xFF000000),\nonBackground = Color(0xFF000000),\nonSurface = Color(0xFF000000),\n)\n</code></pre>"},{"location":"U02/U02.3%20Android%20architecture/","title":"Unit 2.3. Android architecture","text":"<p>Android architecture is a set of guidelines and best practices for building Android applications. It provides a structured approach to app development, making it easier to manage complexity and maintain code quality. The key components of Android architecture include:</p> <ol> <li> <p>Activities and Fragments: The building blocks of the user interface in Android. Activities represent a single screen, while fragments are reusable components that can be embedded within activities.</p> </li> <li> <p>ViewModel: A class that holds and manages UI-related data in a lifecycle-conscious way. ViewModels survive configuration changes, such as screen rotations, making them ideal for storing UI state.</p> </li> <li> <p>LiveData: A data holder class that can be observed for changes. LiveData is lifecycle-aware, meaning it only updates active observers, helping to prevent memory leaks and crashes.</p> </li> <li> <p>Repository: A class that abstracts data access from multiple sources, such as a local database and a remote server. Repositories provide a clean API for data access, making it easier to switch between data sources.</p> </li> <li> <p>Room: A persistence library that provides an abstraction layer over SQLite. Room simplifies database access and allows for compile-time verification of SQL queries.</p> </li> <li> <p>Dependency Injection: A design pattern that allows for the decoupling of components in an application. In Android, popular DI frameworks include Dagger and Hilt.</p> </li> </ol> <p>By following these architectural guidelines, developers can create robust, maintainable, and testable Android applications.</p>"},{"location":"U02/U02.3%20Android%20architecture/#references","title":"References","text":"<ul> <li>Guide to App Architecture</li> </ul>"},{"location":"U02/U02.3%20Android%20architecture/#activities","title":"Activities","text":"<p>Activities are the entry point for interacting with the user in an Android application. Each activity is a single screen with a user interface, and it is responsible for managing the lifecycle of the UI components it contains.</p> <p>Every activity has what is known as a lifecycle, which consists of the different states that an activity can go through, from when the activity first initializes to its destruction, at which time the operating system (OS) reclaims its memory. Typically, the entry point of a program is the <code>main()</code> method. Android activities, however, begin with the <code>onCreate()</code> method.  As the user starts your app, navigates between activities, navigates inside and outside of your app, the activity changes state.</p> <p>The following diagram shows all the activity lifecycle states. As their names indicate, these states represent the status of the activity. An activity can go back and forth between states throughout the lifecycle.</p> <p>Note</p> <p>An Android app can have multiple activities. However, it is recommended to have a single activity.</p> <p></p> <p>Note</p> <p>The <code>onRestart()</code> method is not called every time the state transitions between Created and Started. It is only called if <code>onStop()</code> was called and the activity is subsequently restarted.</p> <p>The lifecycle states are:</p> <ul> <li><code>onCreate()</code>: Activity is being created.</li> <li><code>onStart()</code>: Activity becomes visible.</li> <li><code>onResume()</code>: Activity starts interacting with the user, having focus.</li> <li><code>onPause()</code>: Activity is partially visible, but not in focus.</li> <li><code>onStop()</code>: Activity is completely hidden, but still in memory.</li> <li><code>onDestroy()</code>: Activity is being destroyed.</li> <li><code>onRestart()</code>: Activity is being restarted after being stopped.</li> </ul> <p>Task: exploring lifecycle</p> <ol> <li>Create a new project from the source code of this GitHub repository.</li> <li>Open the <code>MainActivity.kt</code> file and examine the lifecycle methods that have been overridden: <code>onStart</code>, <code>onResume</code>, <code>onPause</code>, <code>onStop</code>, <code>onRestart</code>, <code>onDestroy</code>... Note how thre's a <code>Log.d</code> statement in each method.</li> <li>Run the app on an emulator or a physical device and inspect the logcat output. You should see the lifecycle methods being called as you interact with the app (e.g., opening, closing, navigating away from the app).</li> <li>Do the next to observe the lifecycle methods being called:<ul> <li>Rotate the device to see how the activity is recreated.</li> <li>Press the home button to send the app to the background and then return to it.</li> <li>Open another app to see how your activity is paused and stopped.</li> <li>Press the shared button to share content from your app. See how the activity is paused and resumed.</li> <li>With the app open, go to Setting and make a change, for example, change the device's rotation setting. See how the activity is recreated.</li> </ul> </li> </ol>"},{"location":"U02/U02.3%20Android%20architecture/#lifecycle-of-a-composable","title":"Lifecycle of a composable","text":"<p>The UI of your app is initially built from running composable functions in a process called Composition.</p> <p>When the state of your app changes, a recomposition is scheduled. Recomposition is when Compose re-executes the composable functions whose state might have changed and creates an updated UI. The Composition is updated to reflect these changes.</p> <p>Composable functions have their own lifecycle that is independent of the Activity lifecycle. Its lifecycle is composed of the events: enters the Composition, recomposing 0 or more times, and then leaving the Composition.</p> <p></p> <p>In order for Compose to track and trigger a recomposition, it needs to know when state has changed. To indicate to Compose that it should track an object's state, the object needs to be of type State or MutableState. The State type is immutable and can only be read. A MutableState type is mutable and allows reads and writes.</p> <p>To create the mutable variable revenue, you declare it using <code>mutableStateOf</code> and an initial value.</p> <p>To instruct Compose to retain and reuse its value during recompositions, you need to declare it with the <code>rememberSaveable</code> function. This function tells Compose to save and restore the value across recompositions and configuration changes, such as screen rotations.</p> <pre><code>var revenue by rememberSaveable { mutableStateOf(0) }\n</code></pre> <p>Info</p> <p>You can also use <code>remember</code> instead of <code>rememberSaveable</code>. The difference is that <code>remember</code> only retains the value during recompositions, but not across configuration changes, i.e., if the screen is rotated or the activity is recreated.</p>"},{"location":"U02/U02.3%20Android%20architecture/#the-log-class","title":"The Log class","text":"<p>The <code>Log</code> class in Android is used for logging messages that can help developers debug their applications. It provides a way to print messages to the logcat, which is a system-wide logging facility that collects and displays log messages from various sources, including the Android system and applications.</p> <p>First, you must import the <code>Log</code> class at the top of your Kotlin file:</p> <pre><code>import android.util.Log\n</code></pre> <p>A good practice is to define a constant for the log tag, which is a string that identifies the source of the log message (usually the activity's name). This helps in filtering log messages in logcat.</p> <pre><code>private const val TAG = \"MainActivity\"\n</code></pre> <p>Then, you can use the various logging methods provided by the <code>Log</code> class to log messages at different levels of severity:</p> <pre><code>Log.v(TAG, \"Verbose log message\")\nLog.d(TAG, \"Debug log message\")\nLog.i(TAG, \"Info log message\")\nLog.w(TAG, \"Warning log message\")\nLog.e(TAG, \"Error log message\")\n</code></pre>"},{"location":"U02/U02.3%20Android%20architecture/#intents","title":"Intents","text":"<p>An Intent in Android is a messaging object that you can use to request an action from another app component. Intents are used for various purposes, such as starting activities, services, or broadcasting messages.</p> <p>There are two main types of intents:</p> <ul> <li>Explicit Intents: These intents specify the exact component (activity, service, etc.) to start by providing the class name. They are typically used for starting activities within the same application.</li> </ul> <p>Example of an explicit intent to start a new activity:</p> <pre><code>val intent = Intent(this, SecondActivity::class.java)\nstartActivity(intent)\n</code></pre> <ul> <li>Implicit Intents: These intents do not specify a specific component but instead declare a general action to perform. The Android system then determines the best component to handle the intent based on the action and data provided.</li> </ul> <p>Example of an implicit intent to view a webpage:</p> <pre><code>val intent = Intent(\nIntent.ACTION_VIEW,\nUri.parse(\"https://www.example.com\")\n)\nstartActivity(intent)\n</code></pre>"},{"location":"U02/U02.3%20Android%20architecture/#intent-filters","title":"Intent Filters","text":"<p>An Intent Filter is a declaration in the AndroidManifest.xml file that specifies the types of intents an activity, service, or broadcast receiver can respond to. Intent filters allow components to be discovered and invoked by other applications based on the actions and data they can handle.</p> <p>For example, to declare an activity that can handle the \"VIEW\" action for web URLs, you would add the following intent filter to the activity in the AndroidManifest.xml file:</p> <pre><code>&lt;activity android:name=\".SecondActivity\"&gt;\n&lt;intent-filter&gt;\n&lt;action android:name=\"android.intent.action.VIEW\" /&gt;\n&lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;\n&lt;data android:scheme=\"http\" /&gt;\n&lt;data android:scheme=\"https\" /&gt;\n&lt;/intent-filter&gt;\n&lt;/activity&gt;\n</code></pre> <p>This intent filter specifies that <code>SecondActivity</code> can handle the \"VIEW\" action for both \"http\" and \"https\" schemes.</p>"}]}